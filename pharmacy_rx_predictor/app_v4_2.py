"""
è–¬å±€ å¹´é–“å‡¦æ–¹ç®‹æšæ•° å¤šé¢çš„äºˆæ¸¬ãƒ„ãƒ¼ãƒ« v4.2
==========================================
v4.2 ä¸»ãªå¤‰æ›´ç‚¹: è¨ºç™‚ç§‘åˆ¥ç²¾åº¦å‘ä¸Š + å¹´é½¢è£œæ­£ + ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰

  ã€v4.2 æ”¹å–„æ¦‚è¦ã€‘
  ä¸‹è¨˜5ç‚¹ã‚’æ”¹å–„ã—ã€æœªæ ¡æ­£çŠ¶æ…‹ã§ã®M1/M2ç²¾åº¦ã‚’å¼•ãä¸Šã’ã‚‹ã€‚

  1. è¨ºç™‚ç§‘åˆ¥å¤–æ¥æ‚£è€…æ•°ãƒ†ãƒ¼ãƒ–ãƒ« (SPECIALTY_OUTPATIENT_TABLE)
     ã€ŒåŒ»å¸«æ•°ã ã‘ã§ä¸€å¾‹20/40/70äºº/æ—¥ã€â†’ã€Œè¨ºç™‚ç§‘ã”ã¨ã«çµ±è¨ˆçš„åŸºç¤å€¤ã€ã¸åˆ·æ–°ã€‚
     å‡ºå…¸: åšç”ŸåŠ´åƒçœã€ŒåŒ»ç™‚æ–½è¨­èª¿æŸ»ã€2020å¹´ ç„¡åºŠè¨ºç™‚æ‰€ã®è¨ºç™‚ç§‘åˆ¥1æ—¥å¹³å‡å¤–æ¥æ‚£è€…æ•°ã€‚
     ä¾‹) æ•´å½¢å¤–ç§‘48/æ—¥ãƒ»çœ¼ç§‘54/æ—¥ãƒ»è€³é¼»ç§‘50/æ—¥ vs æ—§ä¸€å¾‹20/æ—¥ã€‚

  2. åå‰ãƒ™ãƒ¼ã‚¹è¨ºç™‚ç§‘æ¤œå‡ºã® OSM ã‚¿ã‚°è£œå®Œ (search_nearby æ”¹ä¿®)
     OSMã‚¿ã‚°ã« speciality ãŒç„¡ã„æ–½è¨­ã‚’æ–½è¨­åï¼ˆæ—¥æœ¬èªï¼‰ã§ã‚‚è¨ºç™‚ç§‘æ¨å®šã—ã€
     å¤–æ¥æ‚£è€…æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ç…§åˆç²¾åº¦ã‚’å‘ä¸Šã€‚

  3. è¨ºç™‚ç§‘åˆ¥ SPECIALTY_RX_RATES ãƒã‚°ä¿®æ­£
     ã€Œæ­¯ç§‘ã€ã€Œæ¶ˆåŒ–å™¨å†…ç§‘/æ¶ˆåŒ–å™¨å¤–ç§‘ã€ã€Œç²¾ç¥ç§‘/å¿ƒç™‚å†…ç§‘ã€ã€Œç¥çµŒå†…ç§‘/è„³ç¥çµŒå†…ç§‘ã€
     ã€Œç”£å©¦äººç§‘/å©¦äººç§‘ã€ãŒ SPECIALTY_RX_RATES ã«å­˜åœ¨ã›ãš
     "ä¸æ˜/ãã®ä»–(0.68)" ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¦ã„ãŸå•é¡Œã‚’ä¿®æ­£ã€‚
     ä¾‹) æ­¯ç§‘: 0.68â†’0.08ã€ç²¾ç¥ç§‘/å¿ƒç™‚å†…ç§‘: 0.68â†’0.85ã€‚

  4. äººå£å¯†åº¦å¸¯åˆ¥å¹´é½¢åˆ†å¸ƒ (DENSITY_AGE_DISTRIBUTION) â†’ Method2 æ”¹å–„
     å…¨å›½å›ºå®šå€¤ã§ã¯ãªãéƒ½å¸‚éƒ¨ï¼ˆé«˜å¯†åº¦=è‹¥å¹´å¤šã‚ï¼‰/è¾²æ‘éƒ¨ï¼ˆä½å¯†åº¦=é«˜é½¢å¤šã‚ï¼‰
     ã®å¹´é½¢æ§‹æˆå·®ã‚’åæ˜ ã€‚M2 ã®å‡¦æ–¹ç®‹ãƒ—ãƒ¼ãƒ«è¨ˆç®—ç²¾åº¦ã‚’å‘ä¸Šã€‚
     ä¾‹) è¶…é«˜å¯†åº¦: 65+20% â† æ—§28.3% / è¶…ä½å¯†åº¦: 65+38% â† æ—§28.3%ã€‚

  5. ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰æ¨å¥¨å€¤ (calc_smart_blend_weight)
     æœªæ ¡æ­£æ™‚ã®ã€Œå˜ç´”å¹³å‡ã€ã‚’ã€ãƒ‡ãƒ¼ã‚¿å“è³ªã‚·ã‚°ãƒŠãƒ«ã«åŸºã¥ãå‹•çš„é‡ã¿ã¸å¤‰æ›´ã€‚
     ã‚·ã‚°ãƒŠãƒ«: äººå£å¯†åº¦ãƒ»MHLWç¢ºèªæ¸ˆã¿æ–½è¨­æ•°ãƒ»åŒ»ç™‚æ©Ÿé–¢ç·æ•°ã‹ã‚‰ M1/M2 ã®
     ã©ã¡ã‚‰ãŒä¿¡é ¼ã§ãã‚‹ã‹ã‚’è‡ªå‹•åˆ¤å®šï¼ˆæ ¡æ­£å®Ÿæ–½å¾Œã¯ v4.1 ã® w* ãŒå„ªå…ˆï¼‰ã€‚

  6. åŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£ã‚’æ»‘ã‚‰ã‹æŒ‡æ•°æ¸›è¡°ã«å¤‰æ›´ (apply_clinic_congestion_factor)
     æ®µéšçš„ã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°ï¼ˆ0.85/0.70/0.60/0.50ï¼‰â†’æŒ‡æ•°æ¸›è¡°
     factor = max(0.50, exp(âˆ’0.035Ã—max(0, nâˆ’5)) ã§é–¾å€¤ã‚¸ãƒ£ãƒ³ãƒ—ã‚’å»ƒæ­¢ã€‚

v4.1 ã‹ã‚‰ã®ç¶™æ‰¿:
  - CalibrationEngineï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ‰ãƒªãƒ–ãƒ³æ ¡æ­£ã‚¨ãƒ³ã‚¸ãƒ³ï¼‰
  - ã€ŒğŸ”¬ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ã€ã‚¿ãƒ–

v4.1 ä¸»ãªå¤‰æ›´ç‚¹: ãƒ‡ãƒ¼ã‚¿ãƒ‰ãƒªãƒ–ãƒ³æ ¡æ­£ã‚¨ãƒ³ã‚¸ãƒ³

  â˜… MHLWã®å®Ÿç¸¾å‡¦æ–¹ç®‹ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ãŸè‡ªå‹•ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ï¼ˆæ–°æ©Ÿèƒ½ï¼‰

  ã€èƒŒæ™¯ã¨ç›®çš„ã€‘
    å¾“æ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¤–æ¥æ‚£è€…æ•°ãƒ»æµå…¥ä¿‚æ•°ãƒ»ã‚·ã‚§ã‚¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’
    çµ±è¨ˆè³‡æ–™ã‚„æ¥­ç•ŒçŸ¥è¦‹ã‹ã‚‰æ‰‹å‹•è¨­å®šã—ã¦ã„ãŸã€‚
    v4.1 ã§ã¯ã€ŒMHLWã«å‡¦æ–¹ç®‹æšæ•°ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹è–¬å±€ï¼ˆå®Ÿç¸¾å€¤ï¼‰ã€ã‚’æ ¡æ­£ã‚»ãƒƒãƒˆã¨ã—ã¦æ´»ç”¨ã—ã€
    ä½æ‰€ã®ã¿ã®æƒ…å ±ã‹ã‚‰äºˆæ¸¬ã—ãŸå€¤ã¨å®Ÿç¸¾å€¤ã‚’æ¯”è¼ƒã™ã‚‹ã“ã¨ã§ã€æœ€ã‚‚ç²¾åº¦ãŒé«˜ã„
    è£œæ­£ä¿‚æ•°ãƒ»ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ã‚’è‡ªå‹•å°å‡ºã™ã‚‹ã€‚

  1. CalibrationEngineï¼ˆæ–°è¨­ï¼‰
     MHLWã§éƒ½é“åºœçœŒãƒ»åœ°åŸŸã‚’æŒ‡å®šã—ã¦å‡¦æ–¹ç®‹å®Ÿç¸¾ã®ã‚ã‚‹è–¬å±€ã‚’è‡ªå‹•åé›†ã—ã€
     ä½æ‰€ã®ã¿ã®æƒ…å ±ã§æ–¹æ³•â‘ ãƒ»â‘¡ã«ã‚ˆã‚‹äºˆæ¸¬ã‚’å®Ÿè¡Œã€‚
     å®Ÿç¸¾ã¨ã®èª¤å·®ã‹ã‚‰ä»¥ä¸‹ã‚’å°å‡º:
       ãƒ»å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•° Î±1(density), Î±2(density)  â€¦ å¹¾ä½•å¹³å‡ã§ä¹—ç®—ãƒã‚¤ã‚¢ã‚¹ã‚’é™¤å»
       ãƒ»æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ w*  â€¦ MAPE(w)ã‚’æœ€å°åŒ–ã™ã‚‹M1:M2ã®æ··åˆæ¯”ç‡

  2. æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é©ç”¨
     - æœªæ ¡æ­£æ™‚: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§äºˆæ¸¬ï¼ˆv3.2ç›¸å½“ï¼‰
     - æ ¡æ­£å¾Œ:   final = w* Ã— (Î±1 Ã— M1) + (1-w*) Ã— (Î±2 Ã— M2)
     æ ¡æ­£çµæœã¯ã€ŒğŸ”¬ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ã€ã‚¿ãƒ–ã§ç¢ºèªãƒ»é©ç”¨ãƒ»CSVå‡ºåŠ›å¯èƒ½

  3. æ–°è¦ã‚¿ãƒ–ã€ŒğŸ”¬ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ã€
     - éƒ½é“åºœçœŒãƒ»åé›†ä»¶æ•°ã‚’æŒ‡å®šã—ã¦ãƒãƒƒãƒæ ¡æ­£å®Ÿè¡Œ
     - MAPE / RMSE / ãƒã‚¤ã‚¢ã‚¹ / å¯†åº¦å¸¯åˆ¥èª¤å·® ã®å¯è¦–åŒ–
     - æ¨å¥¨è£œæ­£ä¿‚æ•°ã®ç¢ºèªã¨ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯é©ç”¨

  v3.2 ã‹ã‚‰ã®ç¶™æ‰¿ï¼ˆåŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£ãƒ»ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¤–æ¥æ•°æ”¹å–„ï¼‰:
    - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¤–æ¥æ‚£è€…æ•°: ç„¡åºŠè¨ºç™‚æ‰€â‰ˆ20äºº/æ—¥ï¼ˆåšåŠ´çœã€ŒåŒ»ç™‚æ–½è¨­èª¿æŸ»ã€2020å¹´ï¼‰
    - åŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£: æœªç¢ºèªæ–½è¨­ãŒ6ä»¶ä»¥ä¸Šã®å ´åˆã«æ®µéšçš„åœ§ç¸®ï¼ˆæœ€å¤§0.50Ã—ï¼‰
    - æ®‹ä½™ã‚·ã‚§ã‚¢ãƒ¢ãƒ‡ãƒ«ï¼ˆæ—¢å­˜é–€å‰è–¬å±€ã®å‹•çš„åˆ¤å®šï¼‰

v3.2 Changelogï¼ˆå‚ç…§ã®ã¿ï¼‰:
  1. ç«¶åˆè–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ã‚’è‡ªå‹•å–å¾—ï¼ˆå¸¸æ™‚å®Ÿè¡Œï¼‰
     æ—¢å­˜è–¬å±€åˆ†æãƒ¢ãƒ¼ãƒ‰ãƒ»æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰ä¸¡æ–¹ã§ã€è¿‘éš£è–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ã‚’
     åˆ†æå®Ÿè¡Œæ™‚ã«è‡ªå‹•ã§MHLWã‹ã‚‰å–å¾—ï¼ˆä¸Šä½10è–¬å±€ï¼‰
  2. ç«¶åˆè–¬å±€ã®OSMæ¤œç´¢ã‚¿ã‚°ã‚’æ‹¡å……ï¼ˆshop/healthcare=pharmacyã‚‚å¯¾å¿œï¼‰
  3. æ®‹ä½™ã‚·ã‚§ã‚¢ãƒ¢ãƒ‡ãƒ«ï¼ˆæ—¢å­˜é–€å‰è–¬å±€ã®å‹•çš„åˆ¤å®šï¼‰
  4. MHLWåŒ»ç™‚æ©Ÿé–¢ã‚¨ãƒªã‚¢è‡ªå‹•è£œå¡«
"""

import csv
import dataclasses
import io
import math
import re
import time
import urllib.parse
from dataclasses import dataclass, field
from datetime import datetime
from typing import Callable, Dict, List, Optional, Tuple

import folium
import requests
import streamlit as st
from bs4 import BeautifulSoup
from streamlit_folium import st_folium

# ---------------------------------------------------------------------------
# å®šæ•°ãƒ»çµ±è¨ˆãƒ‡ãƒ¼ã‚¿
# ---------------------------------------------------------------------------

PREFECTURES = [
    "åŒ—æµ·é“", "é’æ£®çœŒ", "å²©æ‰‹çœŒ", "å®®åŸçœŒ", "ç§‹ç”°çœŒ", "å±±å½¢çœŒ", "ç¦å³¶çœŒ",
    "èŒ¨åŸçœŒ", "æ ƒæœ¨çœŒ", "ç¾¤é¦¬çœŒ", "åŸ¼ç‰çœŒ", "åƒè‘‰çœŒ", "æ±äº¬éƒ½", "ç¥å¥ˆå·çœŒ",
    "æ–°æ½ŸçœŒ", "å¯Œå±±çœŒ", "çŸ³å·çœŒ", "ç¦äº•çœŒ", "å±±æ¢¨çœŒ", "é•·é‡çœŒ",
    "å²é˜œçœŒ", "é™å²¡çœŒ", "æ„›çŸ¥çœŒ", "ä¸‰é‡çœŒ",
    "æ»‹è³€çœŒ", "äº¬éƒ½åºœ", "å¤§é˜ªåºœ", "å…µåº«çœŒ", "å¥ˆè‰¯çœŒ", "å’Œæ­Œå±±çœŒ",
    "é³¥å–çœŒ", "å³¶æ ¹çœŒ", "å²¡å±±çœŒ", "åºƒå³¶çœŒ", "å±±å£çœŒ",
    "å¾³å³¶çœŒ", "é¦™å·çœŒ", "æ„›åª›çœŒ", "é«˜çŸ¥çœŒ",
    "ç¦å²¡çœŒ", "ä½è³€çœŒ", "é•·å´çœŒ", "ç†Šæœ¬çœŒ", "å¤§åˆ†çœŒ", "å®®å´çœŒ", "é¹¿å…å³¶çœŒ", "æ²–ç¸„çœŒ",
]
PREFECTURE_CODES: Dict[str, str] = {
    "åŒ—æµ·é“": "01", "é’æ£®çœŒ": "02", "å²©æ‰‹çœŒ": "03", "å®®åŸçœŒ": "04", "ç§‹ç”°çœŒ": "05",
    "å±±å½¢çœŒ": "06", "ç¦å³¶çœŒ": "07", "èŒ¨åŸçœŒ": "08", "æ ƒæœ¨çœŒ": "09", "ç¾¤é¦¬çœŒ": "10",
    "åŸ¼ç‰çœŒ": "11", "åƒè‘‰çœŒ": "12", "æ±äº¬éƒ½": "13", "ç¥å¥ˆå·çœŒ": "14", "æ–°æ½ŸçœŒ": "15",
    "å¯Œå±±çœŒ": "16", "çŸ³å·çœŒ": "17", "ç¦äº•çœŒ": "18", "å±±æ¢¨çœŒ": "19", "é•·é‡çœŒ": "20",
    "å²é˜œçœŒ": "21", "é™å²¡çœŒ": "22", "æ„›çŸ¥çœŒ": "23", "ä¸‰é‡çœŒ": "24", "æ»‹è³€çœŒ": "25",
    "äº¬éƒ½åºœ": "26", "å¤§é˜ªåºœ": "27", "å…µåº«çœŒ": "28", "å¥ˆè‰¯çœŒ": "29", "å’Œæ­Œå±±çœŒ": "30",
    "é³¥å–çœŒ": "31", "å³¶æ ¹çœŒ": "32", "å²¡å±±çœŒ": "33", "åºƒå³¶çœŒ": "34", "å±±å£çœŒ": "35",
    "å¾³å³¶çœŒ": "36", "é¦™å·çœŒ": "37", "æ„›åª›çœŒ": "38", "é«˜çŸ¥çœŒ": "39", "ç¦å²¡çœŒ": "40",
    "ä½è³€çœŒ": "41", "é•·å´çœŒ": "42", "ç†Šæœ¬çœŒ": "43", "å¤§åˆ†çœŒ": "44", "å®®å´çœŒ": "45",
    "é¹¿å…å³¶çœŒ": "46", "æ²–ç¸„çœŒ": "47",
}

# é–€å‰è–¬å±€å‡¦æ–¹ç®‹æ•æ‰ç‡ï¼ˆv3.2ï¼‰
# åšç”ŸåŠ´åƒçœãƒ‡ãƒ¼ã‚¿ãŠã‚ˆã³æ¥­ç•Œå®Ÿæ…‹ã‚ˆã‚Š: åŒ»ç™‚æ©Ÿé–¢50mä»¥å†…ã®è–¬å±€ã¯åŒæ–½è¨­ã®å‡¦æ–¹ç®‹ã®
# æ¦‚ã­60ã€œ80%ã‚’æ•æ‰ã™ã‚‹ã€‚ä¸­å¤®å€¤ã¨ã—ã¦70%ã‚’æ¡ç”¨ã€‚
# å‡ºå…¸: èª¿å‰¤è–¬å±€æ¥­ç•Œå®Ÿæ…‹èª¿æŸ»ãƒ»é–€å‰è–¬å±€ã‚·ã‚§ã‚¢åˆ†æï¼ˆæ—¥æœ¬è–¬å‰¤å¸«ä¼šç­‰ï¼‰
GATE_PHARMACY_CAPTURE_RATE: float = 0.70   # æ—¢å­˜é–€å‰è–¬å±€ã®æ¨å®šå‡¦æ–¹ç®‹æ•æ‰ç‡

# å…¨å›½çµ±è¨ˆï¼ˆåšç”ŸåŠ´åƒçœã€Œèª¿å‰¤åŒ»ç™‚è²»ã®å‹•å‘ã€2022å¹´åº¦ï¼‰
NATIONAL_STATS = {
    "total_prescriptions": 885_000_000,
    "total_pharmacies": 61_860,
    "average_per_year": 14_305,
    "median_estimate": 8_000,
    "working_days": 305,
    "outpatient_rx_rate": 0.790,    # é™¢å¤–å‡¦æ–¹ç‡ï¼ˆå…¨å›½å¹³å‡ï¼‰ä»¤å’Œ4å¹´: ç¤¾ä¼šåŒ»ç™‚è¨ºç™‚è¡Œç‚ºåˆ¥çµ±è¨ˆ
    "prescription_per_visit": 0.69,  # å¤–æ¥1å—è¨ºã‚ãŸã‚Šå‡¦æ–¹ç®‹ç™ºè¡Œç‡ï¼ˆåŒ»ç§‘ã€æ­¯ç§‘é™¤å¤–ãƒ»è¨ºç™‚ç§‘åŠ é‡å¹³å‡ï¼‰
}

# çµ±è¨ˆæ•°å€¤ã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å‚ç…§ï¼ˆv2.2æ–°è¦è¿½åŠ ï¼‰
STAT_REFERENCES: Dict[str, Dict] = {
    "é™¢å¤–å‡¦æ–¹ç‡": {
        "value": "79.0%ï¼ˆä»¤å’Œ4å¹´åº¦ï¼‰",
        "source": "åšç”ŸåŠ´åƒçœã€Œç¤¾ä¼šåŒ»ç™‚è¨ºç™‚è¡Œç‚ºåˆ¥çµ±è¨ˆã€ä»¤å’Œ4ï¼ˆ2022ï¼‰å¹´",
        "url": "https://www.mhlw.go.jp/toukei/saikin/hw/sinryo/tyosa22/index.html",
        "note": "å…¨å›½è–¬å±€ã«ãŠã‘ã‚‹é™¢å¤–å‡¦æ–¹ç®‹ï¼ˆèª¿å‰¤è–¬å±€ã§èª¿å‰¤ï¼‰ã®å‰²åˆã€‚2000å¹´ä»£ã‹ã‚‰ä¸€è²«ã—ã¦ä¸Šæ˜‡ä¸­ã€‚"
               "ä»¤å’Œ4ï¼ˆ2022ï¼‰å¹´: 79.1%ã€ä»¤å’Œ5ï¼ˆ2023ï¼‰å¹´: 80.2%ã€ä»¤å’Œ6ï¼ˆ2024ï¼‰å¹´: 81.4%ã€‚"
               "æœ¬ãƒ„ãƒ¼ãƒ«ã¯ä»¤å’Œ4å¹´åº¦å€¤ 79.0% ã‚’æ¡ç”¨ï¼ˆv3.1æ›´æ–°ï¼‰ã€‚ç—…é™¢è¦æ¨¡ãƒ»åœ°åŸŸã«ã‚ˆã‚Šå·®ç•°ã‚ã‚Šã€‚",
    },
    "å‡¦æ–¹ç®‹ç™ºè¡Œç‡ï¼ˆå¤–æ¥1å—è¨ºã‚ãŸã‚Šï¼‰": {
        "value": "69%ï¼ˆåŒ»ç§‘å¤–æ¥ã®ã¿ãƒ»æ­¯ç§‘é™¤å¤–ï¼‰",
        "source": "SPECIALTY_RX_RATESï¼ˆè¨ºç™‚ç§‘åˆ¥å‡¦æ–¹ç‡ï¼‰ã®è¨ºç™‚ç§‘ã‚·ã‚§ã‚¢åŠ é‡å¹³å‡ã«ã‚ˆã‚Šç®—å‡º",
        "url": "https://www.mhlw.go.jp/toukei/list/35-34.html",
        "note": "å¤–æ¥æ‚£è€…1å›ã®å—è¨ºã‚ãŸã‚Šå‡¦æ–¹ç®‹ãŒç™ºè¡Œã•ã‚Œã‚‹ç¢ºç‡ï¼ˆåŒ»ç§‘ã®ã¿ï¼‰ã€‚"
               "å†…ç§‘35%Ã—76%ã€æ•´å½¢å¤–ç§‘12%Ã—72%ã€çœ¼ç§‘9%Ã—52%ã€çš®è†šç§‘8%Ã—64%ç­‰ã®åŠ é‡å¹³å‡â‰ˆ69%ã€‚"
               "æ­¯ç§‘ï¼ˆå‡¦æ–¹ç‡~22%ï¼‰ã‚’å«ã‚€å…¨ç§‘å¹³å‡ã§ã¯ç´„65%ã¨ãªã‚‹ãŒã€èª¿å‰¤è–¬å±€ã¸ã®å‡¦æ–¹ç®‹ã¯"
               "åŒ»ç§‘ç”±æ¥ã®ã¿ã®ãŸã‚ã€åŒ»ç§‘åŠ é‡å¹³å‡ã®69%ã‚’æ¡ç”¨ï¼ˆv3.1æ›´æ–°ï¼‰ã€‚",
    },
    "å¹´é–“ç¨¼åƒæ—¥æ•°": {
        "value": "305æ—¥",
        "source": "åšç”ŸåŠ´åƒçœã€Œè–¬å±€ãƒ»è–¬å‰¤å¸«å®Ÿæ…‹èª¿æŸ»ã€æ¥­ç•Œæ…£è¡Œ",
        "url": "https://www.mhlw.go.jp/stf/seisakunitsuite/bunya/kenkou_iryou/iyakuhin/yakkyoku_yakuzaisi/index.html",
        "note": "åœŸæ—¥ãƒ»ç¥æ—¥ãƒ»å¹´æœ«å¹´å§‹ï¼ˆç´„7æ—¥ï¼‰ã‚’é™¤ãå¹´é–“ç¨¼åƒæ—¥æ•°ã€‚è–¬å±€ã®è¦æ¨¡ã‚„ç«‹åœ°ã«ã‚ˆã‚Š240ã€œ320æ—¥ç¨‹åº¦ã®å¹…ãŒã‚ã‚‹ã€‚",
    },
    "å¹´é½¢å±¤åˆ¥å¤–æ¥å—è¨ºç‡": {
        "value": "0-14æ­³: 9.8å›/å¹´, 15-44æ­³: 7.2å›/å¹´, 45-64æ­³: 11.3å›/å¹´, 65-74æ­³: 19.2å›/å¹´, 75æ­³ä»¥ä¸Š: 22.1å›/å¹´",
        "source": "åšç”ŸåŠ´åƒçœã€Œæ‚£è€…èª¿æŸ»ã€2020å¹´ï¼ˆ3å¹´ã”ã¨å®Ÿæ–½ï¼‰",
        "url": "https://www.mhlw.go.jp/toukei/saikin/hw/kanja/20/index.html",
        "note": (
            "æ‚£è€…èª¿æŸ»ã®å¤–æ¥å—ç™‚ç‡ï¼ˆ1æ—¥ã‚ãŸã‚Šå¤–æ¥æ‚£è€…æ•°/10ä¸‡äººï¼‰Ã— 365æ—¥ã§å°å‡ºã—ãŸå¹´é–“å—è¨ºå›æ•°ã€‚"
            "æ‚£è€…èª¿æŸ»ã®å¤–æ¥å—ç™‚ç‡ï¼ˆ1æ—¥ã‚ãŸã‚Šå¤–æ¥æ‚£è€…æ•°/10ä¸‡äººï¼‰Ã— 365æ—¥ã§å°å‡ºã—ãŸå¹´é–“å—è¨ºå›æ•°ï¼ˆåŒ»ç§‘ï¼‹æ­¯ç§‘å«ã‚€ï¼‰ã€‚"
            "åŠ é‡å¹³å‡ã¯ç´„12.4å›/äºº/å¹´ã§ã€OECDçµ±è¨ˆï¼ˆæ—¥æœ¬: 12.6å›/äºº/å¹´ãƒ»2019å¹´ï¼‰ã¨æ•´åˆã€‚"
            "ãªãŠåšç”ŸåŠ´åƒçœã€ŒåŒ»ç™‚ä¿é™ºã«é–¢ã™ã‚‹åŸºç¤è³‡æ–™ ä»¤å’Œ4å¹´åº¦ã€ã®å…¥é™¢å¤–å—è¨ºç‡ï¼ˆä»¶/äººï¼‰ã¯"
            "ç·è¨ˆ8.22ä»¶/å¹´ï¼ˆä¿é™ºè«‹æ±‚ä»¶æ•°ãƒ™ãƒ¼ã‚¹ï¼‰ã ãŒã€1ä»¶â‰’1.5å›ã®æ›ç®—ã§12.3å›/å¹´ã¨ãªã‚ŠOECDã¨æ•´åˆã€‚"
            "æ‚£è€…èª¿æŸ»ãƒ™ãƒ¼ã‚¹ã®ç¾è¡Œå€¤ã‚’ç¶­æŒï¼ˆv3.1ï¼‰ã€‚75æ­³ä»¥ä¸Šã¯æ…¢æ€§ç–¾æ‚£ã«ã‚ˆã‚‹ç¶™ç¶šå—è¨ºãŒå¤šãæœ€ã‚‚é«˜ã„ã€‚"
        ),
    },
    "æ—¥æœ¬ã®å¹´é½¢åˆ†å¸ƒ": {
        "value": "0-14æ­³: 11.9%, 15-44æ­³: 34.2%, 45-64æ­³: 25.6%, 65-74æ­³: 14.5%, 75æ­³ä»¥ä¸Š: 13.8%",
        "source": "ç·å‹™çœã€Œå›½å‹¢èª¿æŸ»ã€2020å¹´",
        "url": "https://www.stat.go.jp/data/kokusei/2020/",
        "note": "5å¹´ã”ã¨ã®å…¨æ•°èª¿æŸ»ã€‚å°‘å­é«˜é½¢åŒ–ã«ã‚ˆã‚Š75æ­³ä»¥ä¸Šã®å‰²åˆãŒä¸Šæ˜‡ä¸­ï¼ˆ2020å¹´: 13.8% â†’ 2025å¹´æ¨è¨ˆ: 16%è¶…ï¼‰ã€‚",
    },
    "è¨ºç™‚ç§‘åˆ¥å‡¦æ–¹ç®‹ç™ºè¡Œç‡": {
        "value": "å¾ªç’°å™¨88%, ç³–å°¿ç—…90%, ç²¾ç¥ç§‘85%, å†…ç§‘76%, æ•´å½¢å¤–ç§‘72%, çš®è†šç§‘64%, å°å…ç§‘62%, çœ¼ç§‘52%",
        "source": "åšç”ŸåŠ´åƒçœã€Œå—ç™‚è¡Œå‹•èª¿æŸ»ã€ã€Œç¤¾ä¼šåŒ»ç™‚è¨ºç™‚è¡Œç‚ºåˆ¥çµ±è¨ˆã€è¤‡æ•°å¹´åº¦ã®åˆ†æã‚ˆã‚Šæ¨è¨ˆ",
        "url": "https://www.mhlw.go.jp/toukei/list/35-34.html",
        "note": "æ…¢æ€§ç–¾æ‚£ãŒå¤šã„ç§‘ï¼ˆå¾ªç’°å™¨ãƒ»ç³–å°¿ç—…ãƒ»ç²¾ç¥ç§‘ï¼‰ã¯å‡¦æ–¹ç‡ãŒé«˜ãã€å‡¦ç½®ãƒ»æ‰‹è¡“ä¸­å¿ƒã®ç§‘ï¼ˆçœ¼ç§‘ãƒ»ãƒªãƒãƒ“ãƒªï¼‰ã¯ä½ã„ã€‚ã„ãšã‚Œã‚‚é™¢å¤–å‡¦æ–¹ç‡(79.0%)ã‚’ã•ã‚‰ã«ä¹—ã˜ã‚‹ã€‚",
    },
    "äººå£å¯†åº¦ãƒ‡ãƒ¼ã‚¿": {
        "value": "æ±äº¬éƒ½åƒä»£ç”°åŒº: 4,073äºº/kmÂ²ã€œè±Šå³¶åŒº: 22,449äºº/kmÂ²ï¼ˆåŒºã”ã¨ã«ç•°ãªã‚‹ï¼‰",
        "source": "ç·å‹™çœã€Œå›½å‹¢èª¿æŸ»ã€2020å¹´ï¼ˆe-Statæ²è¼‰ã®å¸‚åŒºç”ºæ‘åˆ¥äººå£å¯†åº¦ï¼‰",
        "url": "https://www.e-stat.go.jp/stat-search/files?page=1&toukei=00200521",
        "note": "ãƒ„ãƒ¼ãƒ«ã§ã¯æ±äº¬23åŒºãƒ»å¤§é˜ª24åŒºï¼ˆåŒºåˆ¥ï¼‰ã€æ”¿ä»¤æŒ‡å®šéƒ½å¸‚ãƒ»ä¸»è¦å¸‚ï¼ˆå¸‚åˆ¥ï¼‰ã€ãã®ä»–ï¼ˆéƒ½é“åºœçœŒåˆ¥ï¼‰ã®3æ®µéšã§å¯†åº¦ã‚’è‡ªå‹•åˆ¤å®šã€‚",
    },
    "å…¨å›½è–¬å±€çµ±è¨ˆ": {
        "value": "è–¬å±€æ•°: 61,860è»’, å¹´é–“å‡¦æ–¹ç®‹å—ä»˜ç·æ•°: 8.85å„„æš, 1è–¬å±€ã‚ãŸã‚Šå¹´é–“å¹³å‡: 14,305æš",
        "source": "åšç”ŸåŠ´åƒçœã€Œèª¿å‰¤åŒ»ç™‚è²»ã®å‹•å‘ã€2022å¹´åº¦",
        "url": "https://www.mhlw.go.jp/topics/medias/med/",
        "note": "è–¬å±€æ•°ãƒ»å‡¦æ–¹ç®‹æ•°ã¯å¢—åŠ å‚¾å‘ã€‚1è–¬å±€ã‚ãŸã‚Šå¹³å‡14,305æšã ãŒä¸­å¤®å€¤ã¯ç´„8,000æšã¨æ¨è¨ˆï¼ˆè¦æ¨¡æ ¼å·®ãŒå¤§ãã„ï¼‰ã€‚",
    },
}

# è¨ºç™‚ç§‘åˆ¥ å‡¦æ–¹ç®‹ç™ºè¡Œç‡
# v4.2: _SPECIALTY_KW_MAP ãŒç”Ÿæˆã™ã‚‹ã‚­ãƒ¼ï¼ˆè¤‡åˆåå«ã‚€ï¼‰ã‚’ç¶²ç¾…ã€‚
#       ãƒã‚°ä¿®æ­£: æ­¯ç§‘ãƒ»æ¶ˆåŒ–å™¨å†…ç§‘/æ¶ˆåŒ–å™¨å¤–ç§‘ ç­‰ãŒ "ä¸æ˜/ãã®ä»–" ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¦ã„ãŸå•é¡Œã‚’è§£æ¶ˆã€‚
SPECIALTY_RX_RATES: Dict[str, Tuple[float, str]] = {
    "ä¸€èˆ¬å†…ç§‘":             (0.76, "å†…ç§‘ç³»å…¨èˆ¬ï¼ˆæ…¢æ€§ç–¾æ‚£ãŒå¤šãé«˜å‡¦æ–¹ç‡ï¼‰"),
    "å¾ªç’°å™¨å†…ç§‘":           (0.88, "é«˜è¡€åœ§ãƒ»å¿ƒç–¾æ‚£ã¯ç¶™ç¶šå‡¦æ–¹ãŒå¤šã„"),
    "æ¶ˆåŒ–å™¨å†…ç§‘":           (0.74, "èƒƒè…¸ç–¾æ‚£ã¯è–¬ç‰©ç™‚æ³•ãŒä¸»ä½“"),
    "æ¶ˆåŒ–å™¨å†…ç§‘/æ¶ˆåŒ–å™¨å¤–ç§‘":(0.70, "å†…ç§‘ãƒ»å¤–ç§‘æ··åˆã€‚å¤–æ¥ã¯è–¬ç‰©ç™‚æ³•ä¸­å¿ƒã§ä¸­ç¨‹åº¦"),  # v4.2è¿½åŠ 
    "ç³–å°¿ç—…å†…ç§‘":           (0.90, "ã‚¤ãƒ³ã‚¹ãƒªãƒ³ãƒ»çµŒå£è¡€ç³–é™ä¸‹è–¬ã®ç¶™ç¶šå‡¦æ–¹"),
    "ç¥çµŒå†…ç§‘":             (0.82, "ç¥çµŒç–¾æ‚£ã¯è–¬ç‰©ç™‚æ³•ä¾å­˜åº¦é«˜"),
    "ç¥çµŒå†…ç§‘/è„³ç¥çµŒå†…ç§‘":  (0.82, "è„³ç¥çµŒç–¾æ‚£ã®è–¬ç‰©ç™‚æ³•ï¼ˆç¥çµŒå†…ç§‘ã¨åŒç­‰ï¼‰"),       # v4.2è¿½åŠ 
    "å‘¼å¸å™¨å†…ç§‘":           (0.78, "å–˜æ¯ãƒ»COPDç­‰ã®ç¶™ç¶šè–¬å¤šã„"),
    "å¤–ç§‘":                 (0.58, "è¡“å¾Œãƒ•ã‚©ãƒ­ãƒ¼ã®å‡¦æ–¹ã¯æ¯”è¼ƒçš„å°‘ãªã„"),
    "æ•´å½¢å¤–ç§‘":             (0.72, "é®ç—›è–¬ãƒ»æ¹¿å¸ƒç­‰ã®å‡¦æ–¹å¤šã„"),
    "çš®è†šç§‘":               (0.64, "å¤–ç”¨è–¬ãƒ»æŠ—ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼è–¬ãªã©"),
    "çœ¼ç§‘":                 (0.52, "ç‚¹çœ¼è–¬ã¯é™¢å†…äº¤ä»˜ã‚‚å¤šã„"),
    "è€³é¼»å’½å–‰ç§‘":           (0.58, "æŠ—èŒè–¬ç­‰ã®çŸ­æœŸå‡¦æ–¹ãŒå¤šã„"),
    "ç²¾ç¥ç§‘":               (0.85, "å‘ç²¾ç¥è–¬ã¯ç¶™ç¶šå‡¦æ–¹ãŒã»ã¼å¿…é ˆ"),
    "ç²¾ç¥ç§‘/å¿ƒç™‚å†…ç§‘":      (0.85, "å¿ƒç™‚å†…ç§‘å«ã‚€å‘ç²¾ç¥è–¬å‡¦æ–¹ï¼ˆç²¾ç¥ç§‘ã¨åŒç­‰ï¼‰"),      # v4.2è¿½åŠ 
    "å°å…ç§‘":               (0.62, "æ€¥æ€§ç–¾æ‚£ãŒå¤šãå‡¦æ–¹ã¯æ¯”è¼ƒçš„å°‘ãªã„"),
    "ç”£å©¦äººç§‘":             (0.44, "å¥è¨ºãƒ»åˆ†å¨©ãŒå¤šãè–¬å‡¦æ–¹ã¯å°‘ãªã„"),
    "ç”£å©¦äººç§‘/å©¦äººç§‘":      (0.44, "å©¦äººç§‘ç–¾æ‚£ã®å‡¦æ–¹ï¼ˆç”£å©¦äººç§‘ã¨åŒç­‰ï¼‰"),            # v4.2è¿½åŠ 
    "æ³Œå°¿å™¨ç§‘":             (0.70, "å‰ç«‹è…ºç–¾æ‚£ãƒ»éæ´»å‹•è†€èƒ±ç­‰ã®ç¶™ç¶šè–¬"),
    "ãƒªãƒãƒ“ãƒªç§‘":           (0.40, "ãƒªãƒãƒ“ãƒªä¸­å¿ƒã§å‡¦æ–¹ã¯å°‘ãªã„"),
    "æ­¯ç§‘":                 (0.08, "æ­¯ç§‘ã¯å‡¦æ–¹ç®‹è–¬å±€ã¸ã®å‡¦æ–¹ãŒã”ãå°‘ãªã„ï¼ˆé™¢å†…æŠ•ä¸ä¸­å¿ƒï¼‰"),  # v4.2è¿½åŠ 
    "ä¸æ˜/ãã®ä»–":          (0.68, "å…¨è¨ºç™‚ç§‘å¹³å‡å€¤ã‚’ä½¿ç”¨"),
}

# ---------------------------------------------------------------------------
# v4.2: è¨ºç™‚ç§‘åˆ¥ 1æ—¥å¹³å‡å¤–æ¥æ‚£è€…æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆç„¡åºŠè¨ºç™‚æ‰€ï¼‰
# ---------------------------------------------------------------------------
# å‡ºå…¸: åšç”ŸåŠ´åƒçœã€ŒåŒ»ç™‚æ–½è¨­èª¿æŸ»ã€2020å¹´
#       ç„¡åºŠä¸€èˆ¬è¨ºç™‚æ‰€ã«ãŠã‘ã‚‹è¨ºç™‚ç§‘åˆ¥1æ—¥å¹³å‡å¤–æ¥æ‚£è€…æ•°ï¼ˆå…¨å›½å¹³å‡ï¼‰
#   + æ¥­ç•Œå®Ÿæ…‹ãƒ»å…ˆè¡Œç ”ç©¶ã«ã‚ˆã‚‹åŒ»å¸«æ•°åˆ¥è£œæ­£ä¿‚æ•°
#
# ä½¿ç”¨æ³•:
#   æ¨å®šå¤–æ¥æ•° = base + per_dr Ã— max(0, doctors - 1)
#   ãŸã ã— OSM ã®ã¿å–å¾—æ–½è¨­ã¯è¦æ¨¡ãŒå°ã•ã‚ã®å‚¾å‘ãŒã‚ã‚‹ãŸã‚ Ã—0.85 ã§æ§ãˆã‚è£œæ­£
# ---------------------------------------------------------------------------
SPECIALTY_OUTPATIENT_TABLE: Dict[str, Dict] = {
    #                base  per_dr  cap   â† 1 åŒ»å¸«æ™‚ã®åŸºç¤å€¤ / è¿½åŠ åŒ»å¸«1äººã‚ãŸã‚Šå¢—åˆ† / ä¸Šé™
    "ä¸€èˆ¬å†…ç§‘":             {"base": 34, "per_dr": 10, "cap": 80},
    "å¾ªç’°å™¨å†…ç§‘":           {"base": 36, "per_dr":  9, "cap": 90},
    "æ¶ˆåŒ–å™¨å†…ç§‘":           {"base": 32, "per_dr":  8, "cap": 80},
    "æ¶ˆåŒ–å™¨å†…ç§‘/æ¶ˆåŒ–å™¨å¤–ç§‘":{"base": 28, "per_dr":  8, "cap": 70},
    "ç³–å°¿ç—…å†…ç§‘":           {"base": 26, "per_dr":  8, "cap": 70},
    "ç¥çµŒå†…ç§‘":             {"base": 28, "per_dr":  8, "cap": 70},
    "ç¥çµŒå†…ç§‘/è„³ç¥çµŒå†…ç§‘":  {"base": 28, "per_dr":  8, "cap": 70},
    "å‘¼å¸å™¨å†…ç§‘":           {"base": 30, "per_dr":  8, "cap": 75},
    "å¤–ç§‘":                 {"base": 18, "per_dr":  6, "cap": 55},
    "æ•´å½¢å¤–ç§‘":             {"base": 48, "per_dr": 12, "cap":120},  # æ•´å½¢ã¯ç‰¹ã«å¤šã„
    "çš®è†šç§‘":               {"base": 41, "per_dr":  8, "cap":100},
    "çœ¼ç§‘":                 {"base": 54, "per_dr":  8, "cap":130},  # çœ¼ç§‘ã‚‚ç‰¹ã«å¤šã„
    "è€³é¼»å’½å–‰ç§‘":           {"base": 50, "per_dr":  8, "cap":120},
    "ç²¾ç¥ç§‘":               {"base": 23, "per_dr":  8, "cap": 60},
    "ç²¾ç¥ç§‘/å¿ƒç™‚å†…ç§‘":      {"base": 23, "per_dr":  8, "cap": 60},
    "å°å…ç§‘":               {"base": 27, "per_dr":  9, "cap": 80},
    "ç”£å©¦äººç§‘":             {"base": 14, "per_dr":  5, "cap": 40},
    "ç”£å©¦äººç§‘/å©¦äººç§‘":      {"base": 14, "per_dr":  5, "cap": 40},
    "æ³Œå°¿å™¨ç§‘":             {"base": 28, "per_dr":  8, "cap": 70},
    "ãƒªãƒãƒ“ãƒªç§‘":           {"base": 15, "per_dr":  5, "cap": 40},
    "æ­¯ç§‘":                 {"base": 22, "per_dr":  6, "cap": 60},
    "ä¸æ˜/ãã®ä»–":          {"base": 20, "per_dr":  8, "cap": 70},  # æ§ãˆã‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
}

# ---------------------------------------------------------------------------
# v4.2: äººå£å¯†åº¦å¸¯åˆ¥ å¹´é½¢åˆ†å¸ƒãƒ†ãƒ¼ãƒ–ãƒ«
# ---------------------------------------------------------------------------
# å‡ºå…¸: ç·å‹™çœã€Œå›½å‹¢èª¿æŸ»ã€2020å¹´ + éƒ½å¸‚éƒ¨ãƒ»è¾²æ‘éƒ¨äººå£æ§‹æˆã®è£œæ­£æ¨è¨ˆ
#       (éƒ½å¸‚éƒ¨ã»ã©15-44æ­³ãŒå¤šãã€è¾²æ‘éƒ¨ã»ã©65æ­³ä»¥ä¸ŠãŒå¤šã„)
#
# å…¨å›½å¹³å‡ï¼ˆæ—§å›ºå®šå€¤ï¼‰: 65æ­³ä»¥ä¸Š 28.3%ï¼ˆ65-74: 14.5% + 75+: 13.8%ï¼‰
# è¶…é«˜å¯†åº¦ éƒ½å¿ƒéƒ¨:      65æ­³ä»¥ä¸Š 20%  ï¼ˆè‹¥å¹´å°±åŠ´è€…ãƒ»å˜èº«è€…ãŒå¤šã„ï¼‰
# è¶…ä½å¯†åº¦ è¾²æ‘:        65æ­³ä»¥ä¸Š 38%  ï¼ˆé«˜é½¢åŒ–ãŒé€²ã‚€éç–åœ°åŸŸï¼‰
# ---------------------------------------------------------------------------
DENSITY_AGE_DISTRIBUTION: Dict[str, Dict[str, float]] = {
    # å¯†åº¦å¸¯              0-14æ­³   15-44æ­³  45-64æ­³  65-74æ­³  75æ­³ä»¥ä¸Š
    "è¶…é«˜å¯†åº¦": {"0-14æ­³": 0.100, "15-44æ­³": 0.400, "45-64æ­³": 0.260, "65-74æ­³": 0.130, "75æ­³ä»¥ä¸Š": 0.110},
    "é«˜å¯†åº¦":   {"0-14æ­³": 0.112, "15-44æ­³": 0.368, "45-64æ­³": 0.260, "65-74æ­³": 0.140, "75æ­³ä»¥ä¸Š": 0.120},
    "ä¸­å¯†åº¦":   {"0-14æ­³": 0.119, "15-44æ­³": 0.342, "45-64æ­³": 0.256, "65-74æ­³": 0.145, "75æ­³ä»¥ä¸Š": 0.138},  # å…¨å›½å¹³å‡å€¤
    "ä½å¯†åº¦":   {"0-14æ­³": 0.115, "15-44æ­³": 0.295, "45-64æ­³": 0.255, "65-74æ­³": 0.175, "75æ­³ä»¥ä¸Š": 0.160},
    "è¶…ä½å¯†åº¦": {"0-14æ­³": 0.100, "15-44æ­³": 0.255, "45-64æ­³": 0.245, "65-74æ­³": 0.200, "75æ­³ä»¥ä¸Š": 0.200},
}

OSM_SPECIALTY_MAP: Dict[str, str] = {
    "general": "ä¸€èˆ¬å†…ç§‘", "general_practitioner": "ä¸€èˆ¬å†…ç§‘", "internal": "ä¸€èˆ¬å†…ç§‘",
    "cardiology": "å¾ªç’°å™¨å†…ç§‘",
    "gastroenterology": "æ¶ˆåŒ–å™¨å†…ç§‘",
    "diabetes": "ç³–å°¿ç—…å†…ç§‘", "endocrinology": "ç³–å°¿ç—…å†…ç§‘",
    "neurology": "ç¥çµŒå†…ç§‘",
    "pulmonology": "å‘¼å¸å™¨å†…ç§‘", "respiratory": "å‘¼å¸å™¨å†…ç§‘",
    "surgery": "å¤–ç§‘",
    "orthopaedics": "æ•´å½¢å¤–ç§‘", "orthopedics": "æ•´å½¢å¤–ç§‘",
    "dermatology": "çš®è†šç§‘",
    "ophthalmology": "çœ¼ç§‘",
    "otolaryngology": "è€³é¼»å’½å–‰ç§‘", "ent": "è€³é¼»å’½å–‰ç§‘",
    "psychiatry": "ç²¾ç¥ç§‘", "mental_health": "ç²¾ç¥ç§‘",
    "paediatrics": "å°å…ç§‘", "pediatrics": "å°å…ç§‘",
    "gynaecology": "ç”£å©¦äººç§‘", "obstetrics": "ç”£å©¦äººç§‘",
    "urology": "æ³Œå°¿å™¨ç§‘",
    "rehabilitation": "ãƒªãƒãƒ“ãƒªç§‘",
}

VISIT_RATE_BY_AGE: Dict[str, float] = {
    "0-14æ­³":  9.8,
    "15-44æ­³": 7.2,
    "45-64æ­³": 11.3,
    "65-74æ­³": 19.2,
    "75æ­³ä»¥ä¸Š": 22.1,
}

AGE_DISTRIBUTION: Dict[str, float] = {
    "0-14æ­³":  0.119,
    "15-44æ­³": 0.342,
    "45-64æ­³": 0.256,
    "65-74æ­³": 0.145,
    "75æ­³ä»¥ä¸Š": 0.138,
}

MAJOR_CHAINS = [
    "ã‚¦ã‚¨ãƒ«ã‚·ã‚¢", "ãƒ„ãƒ«ãƒ", "ãƒãƒ„ãƒ¢ãƒˆã‚­ãƒ¨ã‚·", "ãƒãƒ„ã‚­ãƒ¨", "ã‚¹ã‚®è–¬å±€",
    "ã‚³ã‚¹ãƒ¢ã‚¹è–¬å“", "ã‚¯ãƒªã‚¨ã‚¤ãƒˆ", "ã‚µãƒ³ãƒ‰ãƒ©ãƒƒã‚°", "ã‚«ãƒ¯ãƒè–¬å“",
    "æ—¥æœ¬èª¿å‰¤", "ã‚¯ã‚ªãƒ¼ãƒ«", "ã‚¢ã‚¤ãƒ³", "ãƒ•ã‚¡ãƒ¼ãƒãƒ©ã‚¤ã‚º", "ç·åˆãƒ¡ãƒ‡ã‚£ã‚«ãƒ«",
]

# ---------------------------------------------------------------------------
# äººå£å¯†åº¦ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆ2020å¹´å›½å‹¢èª¿æŸ»ï¼‰
# ---------------------------------------------------------------------------

TOKYO_WARD_DENSITY: Dict[str, int] = {
    "åƒä»£ç”°åŒº":  4073, "ä¸­å¤®åŒº":  13762, "æ¸¯åŒº":    10649, "æ–°å®¿åŒº":  18235,
    "æ–‡äº¬åŒº":   20105, "å°æ±åŒº":  19419, "å¢¨ç”°åŒº":  19508, "æ±Ÿæ±åŒº":  13943,
    "å“å·åŒº":   17617, "ç›®é»’åŒº":  18984, "å¤§ç”°åŒº":  12461, "ä¸–ç”°è°·åŒº": 16006,
    "æ¸‹è°·åŒº":   15608, "ä¸­é‡åŒº":  20539, "æ‰ä¸¦åŒº":  16524, "è±Šå³¶åŒº":  22449,
    "åŒ—åŒº":     17974, "è’å·åŒº":  21222, "æ¿æ©‹åŒº":  17598, "ç·´é¦¬åŒº":  14587,
    "è¶³ç«‹åŒº":   13752, "è‘›é£¾åŒº":  13802, "æ±Ÿæˆ¸å·åŒº": 13329,
}

OSAKA_WARD_DENSITY: Dict[str, int] = {
    "éƒ½å³¶åŒº":  13500, "ç¦å³¶åŒº":  11000, "æ­¤èŠ±åŒº":   6700, "è¥¿åŒº":   12500,
    "æ¸¯åŒº":    12000, "å¤§æ­£åŒº":  10500, "å¤©ç‹å¯ºåŒº": 15500, "æµªé€ŸåŒº":  15000,
    "è¥¿æ·€å·åŒº":  9500, "æ±æ·€å·åŒº": 17000, "æ±æˆåŒº":  19000, "ç”Ÿé‡åŒº":  18000,
    "æ—­åŒº":    15000, "åŸæ±åŒº":  18000, "é˜¿å€é‡åŒº": 15500, "ä½å‰åŒº":  14500,
    "æ±ä½å‰åŒº": 15500, "è¥¿æˆåŒº":  18000, "æ·€å·åŒº":  15500, "é¶´è¦‹åŒº":  12000,
    "ä½ä¹‹æ±ŸåŒº":  8500, "å¹³é‡åŒº":  13500, "åŒ—åŒº":     9500, "ä¸­å¤®åŒº":   7000,
}

CITY_DENSITY: Dict[str, int] = {
    "æœ­å¹Œå¸‚":    1882, "ä»™å°å¸‚":    1510, "ã•ã„ãŸã¾å¸‚": 5527, "åƒè‘‰å¸‚":    3625,
    "æ¨ªæµœå¸‚":    8717, "å·å´å¸‚":   10235, "ç›¸æ¨¡åŸå¸‚":   2716,
    "æ–°æ½Ÿå¸‚":    1100, "é™å²¡å¸‚":     496, "æµœæ¾å¸‚":      537,
    "åå¤å±‹å¸‚":  7138, "äº¬éƒ½å¸‚":    2804, "å¤§é˜ªå¸‚":    12110, "å ºå¸‚":     5219,
    "ç¥æˆ¸å¸‚":    2799, "å²¡å±±å¸‚":     942, "åºƒå³¶å¸‚":     1625, "åŒ—ä¹å·å¸‚":  1994,
    "ç¦å²¡å¸‚":    4990, "ç†Šæœ¬å¸‚":    1891,
    "æ—­å·å¸‚":     454, "å‡½é¤¨å¸‚":     566, "é’æ£®å¸‚":      753, "ç››å²¡å¸‚":     757,
    "ç§‹ç”°å¸‚":     629, "å±±å½¢å¸‚":     844, "ç¦å³¶å¸‚":      619, "éƒ¡å±±å¸‚":     768,
    "ã„ã‚ãå¸‚":   268, "æ°´æˆ¸å¸‚":    2122, "å®‡éƒ½å®®å¸‚":   1255, "å‰æ©‹å¸‚":     966,
    "é«˜å´å¸‚":    1062, "å·è¶Šå¸‚":    3017, "èˆ¹æ©‹å¸‚":     7068, "æŸå¸‚":      4022,
    "å…«ç‹å­å¸‚":  2584, "åºœä¸­å¸‚":    7029, "èª¿å¸ƒå¸‚":     8225, "ç”ºç”°å¸‚":    4965,
    "è—¤æ²¢å¸‚":    5046, "æ¨ªé ˆè³€å¸‚":  3665, "é•·é‡å¸‚":      648, "å²é˜œå¸‚":    2098,
    "è±Šæ©‹å¸‚":    2031, "è±Šç”°å¸‚":     989, "å²¡å´å¸‚":     1575, "ä¸€å®®å¸‚":    3030,
    "å¤§æ´¥å¸‚":    1070, "å¹ç”°å¸‚":   10267, "é«˜æ§»å¸‚":     4898, "æ±å¤§é˜ªå¸‚":  9267,
    "å§«è·¯å¸‚":    1150, "å°¼å´å¸‚":    8116, "è¥¿å®®å¸‚":     3796, "å¥ˆè‰¯å¸‚":    1087,
    "å’Œæ­Œå±±å¸‚":  2310, "å€‰æ•·å¸‚":     849, "ç¦å±±å¸‚":      953, "å‘‰å¸‚":       786,
    "ä¸‹é–¢å¸‚":     552, "é«˜æ¾å¸‚":    1583, "æ¾å±±å¸‚":     1140, "é«˜çŸ¥å¸‚":    1106,
    "ä¹…ç•™ç±³å¸‚":  2045, "é•·å´å¸‚":    1641, "ä½ä¸–ä¿å¸‚":    638, "å¤§åˆ†å¸‚":     861,
    "å®®å´å¸‚":     849, "é¹¿å…å³¶å¸‚":  1439, "é‚£è¦‡å¸‚":     8356,
    "å·å£å¸‚":    7230, "è¶Šè°·å¸‚":    5630, "è‰åŠ å¸‚":     8270, "æ˜¥æ—¥éƒ¨å¸‚":  2810,
    "æ¾æˆ¸å¸‚":    6230, "å¸‚å·å¸‚":    6610, "æµ¦å®‰å¸‚":    10490, "å¸‚åŸå¸‚":    1090,
    "æ‰€æ²¢å¸‚":    3640, "å¹³å¡šå¸‚":    3490, "åšæœ¨å¸‚":     2070, "å¤§å’Œå¸‚":    6610,
}

PREFECTURE_DENSITY: Dict[str, int] = {
    "åŒ—æµ·é“":  64, "é’æ£®çœŒ": 130, "å²©æ‰‹çœŒ":  84, "å®®åŸçœŒ": 321, "ç§‹ç”°çœŒ":  86,
    "å±±å½¢çœŒ": 116, "ç¦å³¶çœŒ": 139, "èŒ¨åŸçœŒ": 476, "æ ƒæœ¨çœŒ": 307, "ç¾¤é¦¬çœŒ": 309,
    "åŸ¼ç‰çœŒ": 1927, "åƒè‘‰çœŒ": 1211, "æ±äº¬éƒ½": 6263, "ç¥å¥ˆå·çœŒ": 3810,
    "æ–°æ½ŸçœŒ": 179, "å¯Œå±±çœŒ": 247, "çŸ³å·çœŒ": 277, "ç¦äº•çœŒ": 189, "å±±æ¢¨çœŒ": 185,
    "é•·é‡çœŒ": 155, "å²é˜œçœŒ": 191, "é™å²¡çœŒ": 469, "æ„›çŸ¥çœŒ": 1457, "ä¸‰é‡çœŒ": 309,
    "æ»‹è³€çœŒ": 351, "äº¬éƒ½åºœ": 566, "å¤§é˜ªåºœ": 4631, "å…µåº«çœŒ": 652, "å¥ˆè‰¯çœŒ": 366,
    "å’Œæ­Œå±±çœŒ": 196, "é³¥å–çœŒ": 162, "å³¶æ ¹çœŒ": 103, "å²¡å±±çœŒ": 270, "åºƒå³¶çœŒ": 336,
    "å±±å£çœŒ": 224, "å¾³å³¶çœŒ": 184, "é¦™å·çœŒ": 519, "æ„›åª›çœŒ": 241, "é«˜çŸ¥çœŒ": 102,
    "ç¦å²¡çœŒ": 1023, "ä½è³€çœŒ": 340, "é•·å´çœŒ": 330, "ç†Šæœ¬çœŒ": 238, "å¤§åˆ†çœŒ": 182,
    "å®®å´çœŒ": 141, "é¹¿å…å³¶çœŒ": 179, "æ²–ç¸„çœŒ": 637,
}

# ---------------------------------------------------------------------------
# ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹
# ---------------------------------------------------------------------------

@dataclass
class PharmacyCandidate:
    name: str
    address: str
    href: str
    pref_cd: str = ""
    kikan_cd: str = ""

@dataclass
class NearbyFacility:
    name: str
    facility_type: str
    lat: float
    lon: float
    distance_m: float
    specialty: str = "ä¸æ˜/ãã®ä»–"
    daily_outpatients: int = 0
    beds: int = 0
    has_inhouse_pharmacy: bool = False
    has_gate_pharmacy: bool = False
    osm_tags: Dict = field(default_factory=dict)
    mhlw_annual_outpatients: Optional[int] = None  # å‡¦æ–¹ç®‹æšæ•°ï¼ˆè–¬å±€ï¼‰or å¹´é–“å¤–æ¥æ•°ï¼ˆåŒ»ç™‚æ©Ÿé–¢ï¼‰
    is_manual: bool = False   # v2.4: æ‰‹å‹•è¿½åŠ æ–½è¨­ãƒ•ãƒ©ã‚°ï¼ˆOSMæœªåéŒ²ï¼‰
    source: str = "osm"       # v2.6: "osm" | "mhlw" | "manual"


# ---------------------------------------------------------------------------
# v2.6 è£œåŠ©é–¢æ•°: è·é›¢è¨ˆç®—ãƒ»è¨ºç™‚ç§‘æ¨å®šãƒ»ã‚¨ãƒªã‚¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
# ---------------------------------------------------------------------------

def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """2ç‚¹é–“ã®å¤§åœè·é›¢ã‚’ãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ã§è¨ˆç®—ï¼ˆHaversineå…¬å¼ï¼‰"""
    R = 6_371_000  # åœ°çƒåŠå¾„ [m]
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi    = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)
    a = math.sin(dphi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2) ** 2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))


# æ–½è¨­åã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ â†’ è¨ºç™‚ç§‘ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆé•·ã„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…ˆã«è©•ä¾¡ï¼‰
_SPECIALTY_KW_MAP: List[Tuple[List[str], str]] = [
    (["æ•´å½¢å¤–ç§‘"],                    "æ•´å½¢å¤–ç§‘"),
    (["å¾ªç’°å™¨"],                      "å¾ªç’°å™¨å†…ç§‘"),
    (["æ¶ˆåŒ–å™¨"],                      "æ¶ˆåŒ–å™¨å†…ç§‘/æ¶ˆåŒ–å™¨å¤–ç§‘"),
    (["å‘¼å¸å™¨"],                      "å‘¼å¸å™¨å†…ç§‘"),
    (["ç²¾ç¥ç§‘", "å¿ƒç™‚å†…ç§‘"],          "ç²¾ç¥ç§‘/å¿ƒç™‚å†…ç§‘"),
    (["ç¥çµŒå†…ç§‘", "è„³ç¥çµŒ"],          "ç¥çµŒå†…ç§‘/è„³ç¥çµŒå†…ç§‘"),
    (["å¤–ç§‘"],                        "å¤–ç§‘"),
    (["çš®è†šç§‘"],                      "çš®è†šç§‘"),
    (["æ³Œå°¿å™¨"],                      "æ³Œå°¿å™¨ç§‘"),
    (["çœ¼ç§‘"],                        "çœ¼ç§‘"),
    (["è€³é¼»"],                        "è€³é¼»å’½å–‰ç§‘"),
    (["ç”£å©¦äººç§‘", "å©¦äººç§‘"],          "ç”£å©¦äººç§‘/å©¦äººç§‘"),
    (["å°å…ç§‘"],                      "å°å…ç§‘"),
    (["æ­¯ç§‘"],                        "æ­¯ç§‘"),
    (["å†…ç§‘"],                        "ä¸€èˆ¬å†…ç§‘"),
]


def detect_specialty_from_name(name: str) -> str:
    """æ–½è¨­åã‹ã‚‰è¨ºç™‚ç§‘ï¼ˆSPECIALTY_RX_RATESã®ã‚­ãƒ¼ï¼‰ã‚’æ¨å®šã™ã‚‹"""
    for keywords, specialty in _SPECIALTY_KW_MAP:
        if any(kw in name for kw in keywords):
            return specialty
    return "ä¸æ˜/ãã®ä»–"


def extract_area_keyword(address: str) -> str:
    """
    ä½æ‰€ã‹ã‚‰æœ€å°è¡Œæ”¿åŒºç”»ã‚’MHLWæ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦æŠ½å‡ºã™ã‚‹ã€‚

    ä¾‹:
      "æ±äº¬éƒ½æ¿æ©‹åŒºæˆå¢—1ä¸ç›®12-3"       â†’ "æ¿æ©‹åŒº"
      "ç¥å¥ˆå·çœŒå·å´å¸‚ä¸­åŸåŒºæ–°ä¸¸å­æ±3ä¸ç›®" â†’ "ä¸­åŸåŒº"
      "å¤§é˜ªåºœå¤§é˜ªå¸‚åŒ—åŒºæ¢…ç”°1ä¸ç›®"        â†’ "åŒ—åŒº"
      "åŸ¼ç‰çœŒã•ã„ãŸã¾å¸‚æµ¦å’ŒåŒºå¸¸ç›¤"       â†’ "æµ¦å’ŒåŒº"
      "ç¦å²¡çœŒä¹…ç•™ç±³å¸‚é€šå¤–ç”º10-1"         â†’ "ä¹…ç•™ç±³å¸‚"
    """
    # æ”¿ä»¤å¸‚ã®åŒº: ã€Œå¸‚â—‹â—‹åŒºã€â†’ åŒºå
    m = re.search(r'å¸‚([^\d\sãƒ»]{1,6}?åŒº)', address)
    if m:
        return m.group(1)
    # æ±äº¬23åŒº: ã€Œéƒ½â—‹â—‹åŒºã€â†’ åŒºå
    m = re.search(r'éƒ½([^\d\sãƒ»]{1,6}?åŒº)', address)
    if m:
        return m.group(1)
    # ãã®ä»–: éƒ½é“åºœçœŒç›´å¾Œã®å¸‚åŒºç”ºæ‘
    m = re.search(r'[éƒ½é“åºœçœŒ]([^\d\sãƒ»]{2,8}?[å¸‚åŒºç”ºæ‘])', address)
    if m:
        return m.group(1)
    return address[:10]


@dataclass
class PredictionResult:
    method_name: str
    annual_rx: int
    min_val: int
    max_val: int
    confidence: str
    daily_rx: int
    breakdown: List[Dict] = field(default_factory=list)
    methodology: List[str] = field(default_factory=list)
    references: List[Dict] = field(default_factory=list)

@dataclass
class FullAnalysis:
    """æ—¢å­˜è–¬å±€åˆ†æãƒ¢ãƒ¼ãƒ‰ç”¨"""
    pharmacy_name: str
    pharmacy_address: str
    pharmacy_lat: float
    pharmacy_lon: float
    geocode_display: str
    geocoder_source: str
    mhlw_annual_rx: Optional[int]
    mhlw_source_url: str
    method1: Optional[PredictionResult]
    method2: Optional[PredictionResult]
    nearby_medical: List[NearbyFacility]
    nearby_pharmacies: List[NearbyFacility]
    area_density: int = 3000
    area_density_source: str = ""
    commercial_radius: int = 500
    commercial_radius_reason: str = ""
    is_gate_pharmacy: bool = False
    gate_pharmacy_reason: str = ""
    search_log: List[str] = field(default_factory=list)

@dataclass
class NewPharmacyConfig:
    """æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰ç”¨è¨­å®š"""
    address: str
    pharmacy_name: str = "é–‹å±€äºˆå®šè–¬å±€"
    scenario: str = "area_dual"     # "area_dual" | "combined" | "gate_only" | "all"
    gate_specialty: str = "ä¸€èˆ¬å†…ç§‘"
    gate_daily_outpatients: int = 50
    gate_has_inhouse: bool = False   # èª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯ãŒé™¢å†…è–¬å±€ã‚’æŒã¤ã‹
    fetch_nearby_rx: bool = False    # è¿‘éš£è–¬å±€ã®MHLWãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã‹
    fetch_mhlw_supplement: bool = False  # v2.6: MHLWã‹ã‚‰åŒ»ç™‚æ©Ÿé–¢ã‚’è‡ªå‹•è£œå¡«ã™ã‚‹ã‹

@dataclass
class NewPharmacyResult:
    """æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰ç”¨çµæœ"""
    config: NewPharmacyConfig
    lat: Optional[float]
    lon: Optional[float]
    geocode_display: str
    geocoder_source: str
    area_density: int
    area_density_source: str
    commercial_radius: int
    commercial_radius_reason: str
    is_gate: bool
    gate_reason: str
    nearby_medical: List[NearbyFacility]
    nearby_pharmacies: List[NearbyFacility]
    method1_gate: Optional[PredictionResult]   # ã‚·ãƒŠãƒªã‚ªA/C: æ–¹æ³•â‘ ï¼ˆé–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯è¾¼ã¿ï¼‰
    method1_area: Optional[PredictionResult]   # ã‚·ãƒŠãƒªã‚ªB/C: æ–¹æ³•â‘ ï¼ˆæ—¢å­˜è¿‘éš£æ–½è¨­ã®ã¿ï¼‰
    method2: Optional[PredictionResult]        # ã‚·ãƒŠãƒªã‚ªB/C: æ–¹æ³•â‘¡ï¼ˆå•†åœäººå£å‹•æ…‹ï¼‰
    search_log: List[str] = field(default_factory=list)


# ---------------------------------------------------------------------------
# 0-b. v4.1: æ ¡æ­£ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹
# ---------------------------------------------------------------------------

def _density_band(density: int) -> str:
    """äººå£å¯†åº¦ã‚’æ ¡æ­£ç”¨ãƒãƒ³ãƒ‰ãƒ©ãƒ™ãƒ«ã«å¤‰æ›"""
    if density >= 10_000: return "è¶…é«˜å¯†åº¦(â‰¥10k)"
    if density >= 5_000:  return "é«˜å¯†åº¦(5k-10k)"
    if density >= 2_000:  return "ä¸­å¯†åº¦(2k-5k)"
    if density >= 500:    return "ä½å¯†åº¦(500-2k)"
    return "è¶…ä½å¯†åº¦(<500)"


@dataclass
class CalibrationPoint:
    """æ ¡æ­£ã‚µãƒ³ãƒ—ãƒ«1ä»¶: å®Ÿç¸¾å‡¦æ–¹ç®‹æšæ•°ã¨ä½æ‰€ã®ã¿äºˆæ¸¬å€¤ã®æ¯”è¼ƒ"""
    name: str                              # è–¬å±€å
    address: str                           # ä½æ‰€
    actual_rx: int                         # MHLWã‹ã‚‰å–å¾—ã—ãŸå®Ÿç¸¾å€¤
    m1_rx: Optional[int] = None            # æ–¹æ³•â‘ ï¼ˆè¿‘éš£åŒ»ç™‚æ©Ÿé–¢ï¼‰äºˆæ¸¬å€¤
    m2_rx: Optional[int] = None            # æ–¹æ³•â‘¡ï¼ˆå•†åœäººå£ï¼‰äºˆæ¸¬å€¤
    area_density: int = 0                  # äººå£å¯†åº¦ (äºº/kmÂ²)
    n_medical: int = 0                     # æ¤œå‡ºã—ãŸåŒ»ç™‚æ©Ÿé–¢æ•°
    n_pharmacies: int = 0                  # æ¤œå‡ºã—ãŸç«¶åˆè–¬å±€æ•°
    is_gate: bool = False                  # é–€å‰è–¬å±€ãƒ•ãƒ©ã‚°
    error_log: List[str] = field(default_factory=list)  # ã‚¨ãƒ©ãƒ¼ãƒ»ãƒ­ã‚°

    # --- å°å‡ºãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ ---
    @property
    def density_band(self) -> str:
        return _density_band(self.area_density)

    @property
    def error_m1(self) -> Optional[float]:
        """æ–¹æ³•â‘ ã®ç›¸å¯¾èª¤å·® (predicted/actual - 1)"""
        if self.m1_rx is not None and self.actual_rx > 0:
            return self.m1_rx / self.actual_rx - 1.0
        return None

    @property
    def error_m2(self) -> Optional[float]:
        if self.m2_rx is not None and self.actual_rx > 0:
            return self.m2_rx / self.actual_rx - 1.0
        return None

    @property
    def ape_m1(self) -> Optional[float]:
        """æ–¹æ³•â‘ ã®çµ¶å¯¾èª¤å·®ç‡ (APE)"""
        e = self.error_m1
        return abs(e) if e is not None else None

    @property
    def ape_m2(self) -> Optional[float]:
        e = self.error_m2
        return abs(e) if e is not None else None


@dataclass
class CalibrationStats:
    """å…¨æ ¡æ­£ã‚µãƒ³ãƒ—ãƒ«ã®çµ±è¨ˆã‚µãƒãƒªãƒ¼"""
    n: int                                   # æœ‰åŠ¹ã‚µãƒ³ãƒ—ãƒ«æ•°
    mape_m1: float                           # æ–¹æ³•â‘ ã®MAPE (%)
    mape_m2: float                           # æ–¹æ³•â‘¡ã®MAPE (%)
    mape_optimal: float                      # æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰ã®MAPE (%)
    optimal_m1_weight: float                 # æœ€é©M1é‡ã¿ [0.0â€“1.0]
    bias_m1: float                           # æ–¹æ³•â‘ ã®å¹¾ä½•å¹³å‡ãƒã‚¤ã‚¢ã‚¹ (log scale)
    bias_m2: float                           # æ–¹æ³•â‘¡ã®å¹¾ä½•å¹³å‡ãƒã‚¤ã‚¢ã‚¹
    # å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•° {band: (alpha, n_samples)}
    # alpha = geometric_mean(actual / predicted) â†’ predicted Ã— alpha = è£œæ­£å¾Œæ¨è¨ˆ
    alpha_m1: Dict[str, Tuple[float, int]] = field(default_factory=dict)
    alpha_m2: Dict[str, Tuple[float, int]] = field(default_factory=dict)
    calibrated_at: str = ""                  # æ ¡æ­£å®Ÿè¡Œæ™‚åˆ»


# ---------------------------------------------------------------------------
# 1. äººå£å¯†åº¦ãƒ»å•†åœåŠå¾„ è‡ªå‹•è¨ˆç®—
# ---------------------------------------------------------------------------

def get_population_density(address: str) -> Tuple[int, str]:
    if not address:
        return 3000, "ä½æ‰€ä¸æ˜ï¼ˆä¸­é«˜å¯†åº¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰"
    addr = address.strip()
    if "æ±äº¬éƒ½" in addr:
        for ward, density in TOKYO_WARD_DENSITY.items():
            if ward in addr:
                return density, f"{ward}ï¼ˆæ±äº¬éƒ½ï¼‰ 2020å¹´å›½å‹¢èª¿æŸ»"
        return 6263, "æ±äº¬éƒ½å¹³å‡ï¼ˆåŒºæœªç‰¹å®šï¼‰ 2020å¹´å›½å‹¢èª¿æŸ»"
    if "å¤§é˜ªå¸‚" in addr:
        for ward, density in OSAKA_WARD_DENSITY.items():
            if ward in addr:
                return density, f"å¤§é˜ªå¸‚{ward} 2020å¹´å›½å‹¢èª¿æŸ»"
        return 12110, "å¤§é˜ªå¸‚å¹³å‡ï¼ˆåŒºæœªç‰¹å®šï¼‰ 2020å¹´å›½å‹¢èª¿æŸ»"
    for city, density in CITY_DENSITY.items():
        if city in addr:
            return density, f"{city} å¹³å‡äººå£å¯†åº¦ 2020å¹´å›½å‹¢èª¿æŸ»"
    for pref, density in PREFECTURE_DENSITY.items():
        if pref in addr:
            return density, f"{pref} å¹³å‡äººå£å¯†åº¦ 2020å¹´å›½å‹¢èª¿æŸ»"
    return 1500, "ä½æ‰€è§£æä¸èƒ½ï¼ˆä¸­å¯†åº¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ 1,500äºº/kmÂ²ï¼‰"


def detect_gate_pharmacy(
    pharmacy_name: str,
    nearby_medical: List[NearbyFacility],
) -> Tuple[bool, str]:
    gate_keywords = ["é–€å‰", "ç—…é™¢å‰", "åŒ»é™¢å‰", "ã‚¯ãƒªãƒ‹ãƒƒã‚¯å‰", "é™¢å‰"]
    for kw in gate_keywords:
        if kw in pharmacy_name:
            return True, f"è–¬å±€åã«ã€Œ{kw}ã€ãŒå«ã¾ã‚Œã‚‹"
    if nearby_medical:
        for fac in sorted(nearby_medical, key=lambda f: f.distance_m):
            if fac.distance_m <= 80:
                return True, f"ã€Œ{fac.name}ã€({fac.distance_m:.0f}m)ã«éš£æ¥"
        for fac in nearby_medical[:5]:
            short = fac.name[:4]
            if len(short) >= 4 and short in pharmacy_name:
                return True, f"ã€Œ{fac.name}ã€ã®åç§°ãŒè–¬å±€åã«å«ã¾ã‚Œã‚‹"
    return False, "é€šå¸¸å•†åœå‹"


def calc_commercial_radius(
    density: int,
    is_gate: bool = False,
    gate_reason: str = "",
) -> Tuple[int, str]:
    if is_gate:
        return 300, f"é–€å‰è–¬å±€ï¼ˆ{gate_reason}ï¼‰â†’ åŒ»ç™‚æ©Ÿé–¢ä¾å­˜å‹ã®ãŸã‚300må›ºå®š"
    if density >= 12_000:
        r, note = 300,  "è¶…é«˜å¯†åº¦åœ°åŸŸï¼ˆ12,000äºº/kmÂ²ä»¥ä¸Šï¼‰å¾’æ­©5åˆ†åœ"
    elif density >= 6_000:
        r, note = 400,  "é«˜å¯†åº¦åœ°åŸŸï¼ˆ6,000ã€œ12,000äºº/kmÂ²ï¼‰å¾’æ­©7åˆ†åœ"
    elif density >= 3_000:
        r, note = 500,  "ä¸­é«˜å¯†åº¦åœ°åŸŸï¼ˆ3,000ã€œ6,000äºº/kmÂ²ï¼‰å¾’æ­©8åˆ†åœ"
    elif density >= 1_500:
        r, note = 700,  "ä¸­å¯†åº¦åœ°åŸŸï¼ˆ1,500ã€œ3,000äºº/kmÂ²ï¼‰å¾’æ­©12åˆ†åœ"
    elif density >= 500:
        r, note = 1000, "ä½å¯†åº¦åœ°åŸŸï¼ˆ500ã€œ1,500äºº/kmÂ²ï¼‰å¾’æ­©ãƒ»è‡ªè»¢è»Šåœ"
    else:
        r, note = 2000, "è¶…ä½å¯†åº¦åœ°åŸŸï¼ˆ500äºº/kmÂ²æœªæº€ï¼‰åºƒåŸŸå•†åœ"
    return r, f"{note}ï¼ˆå¯†åº¦: {density:,}äºº/kmÂ²ï¼‰"


# ---------------------------------------------------------------------------
# 2. ã‚¸ã‚ªã‚³ãƒ¼ãƒ€ãƒ¼ï¼ˆå›½åœŸåœ°ç†é™¢ GSI + Nominatim ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
# ---------------------------------------------------------------------------

class GeocoderService:
    """
    ä½æ‰€ â†’ ç·¯åº¦çµŒåº¦å¤‰æ›

    v2.2 å¤‰æ›´:
      [1st] å›½åœŸåœ°ç†é™¢ï¼ˆGSIï¼‰ã‚¸ã‚ªã‚³ãƒ¼ãƒ€ãƒ¼ â€” æ—¥æœ¬ä½æ‰€ã«ç‰¹åŒ–ãƒ»é«˜ç²¾åº¦ãƒ»APIã‚­ãƒ¼ä¸è¦
            https://msearch.gsi.go.jp/address-search/AddressSearch
      [2nd] Nominatim (OpenStreetMap) â€” å›½éš›çš„ãªåœ°åãƒ»æ–½è¨­åã«å¼·ã„
    """

    GSI_URL = "https://msearch.gsi.go.jp/address-search/AddressSearch"
    NOMINATIM_URL = "https://nominatim.openstreetmap.org/search"
    LAT_MIN, LAT_MAX = 24.0, 46.0
    LON_MIN, LON_MAX = 122.0, 154.0

    def _clean(self, address: str) -> str:
        a = re.sub(r"Googleãƒãƒƒãƒ—.*|Google Map.*", "", address).strip()
        trans = str.maketrans("ï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™ï¼", "0123456789-")
        a = a.translate(trans).replace("ã€€", " ")
        a = re.sub(r"ã€’\s*\d{3}[-âˆ’]\d{4}\s*", "", a).strip()
        return re.sub(r"\s+", " ", a).strip()

    def _is_japan(self, lat: float, lon: float) -> bool:
        return self.LAT_MIN <= lat <= self.LAT_MAX and self.LON_MIN <= lon <= self.LON_MAX

    def _build_variants(self, address: str) -> List[str]:
        variants: List[str] = [address]
        # å»ºç‰©åãƒ»å·å®¤é™¤å»
        short = re.sub(r"\d+(?:éš|F|æ£Ÿ|å·å®¤|å·).*$", "", address).strip()
        if short and short != address:
            variants.append(short)
        # ã‚¹ãƒšãƒ¼ã‚¹åˆ†å‰²ã§çŸ­ç¸®
        parts = address.split()
        for n in [4, 3]:
            if len(parts) > n:
                v = " ".join(parts[:n])
                if v not in variants:
                    variants.append(v)
        # éƒ½é“åºœçœŒ+å¸‚åŒºã®ã¿
        m = re.match(r"((?:æ±äº¬éƒ½|å¤§é˜ªåºœ|äº¬éƒ½åºœ|åŒ—æµ·é“)|.+?[éƒ½é“åºœçœŒ])(.+?[å¸‚åŒºç”ºæ‘])", address)
        if m:
            v = m.group(1) + m.group(2)
            if v not in variants:
                variants.append(v)
        return variants[:6]

    def _try_gsi(self, query: str) -> Optional[Tuple[float, float, str]]:
        headers = {"User-Agent": "PharmacyRxPredictor"}
        try:
            r = requests.get(self.GSI_URL, params={"q": query}, headers=headers, timeout=8)
            if r.status_code == 200:
                data = r.json()
                if data:
                    coords = data[0].get("geometry", {}).get("coordinates", [])
                    if len(coords) == 2:
                        lon, lat = float(coords[0]), float(coords[1])
                        if self._is_japan(lat, lon):
                            title = data[0].get("properties", {}).get("title", query)
                            return lat, lon, title
        except Exception:
            pass
        return None

    def _try_nominatim(self, query: str) -> Optional[Tuple[float, float, str]]:
        headers = {"User-Agent": "PharmacyRxPredictor"}
        try:
            r = requests.get(
                self.NOMINATIM_URL,
                params={"q": query + " æ—¥æœ¬", "format": "json", "limit": 1},
                headers=headers, timeout=10,
            )
            if r.status_code == 200:
                data = r.json()
                if data:
                    lat, lon = float(data[0]["lat"]), float(data[0]["lon"])
                    if self._is_japan(lat, lon):
                        return lat, lon, data[0].get("display_name", query)
        except Exception:
            pass
        return None

    def geocode(self, address: str) -> Tuple[Optional[float], Optional[float], str, str]:
        """
        Returns: (lat, lon, status_message, geocoder_source_name)
        """
        if not address:
            return None, None, "ä½æ‰€ãŒç©ºã§ã™", ""
        clean = self._clean(address)
        variants = self._build_variants(clean)

        # â”€â”€ GSI Japan ã‚’å„ªå…ˆ
        for i, v in enumerate(variants):
            if i > 0:
                time.sleep(0.15)
            result = self._try_gsi(v)
            if result:
                lat, lon, title = result
                note = f"ï¼ˆçŸ­ç¸®ã‚¯ã‚¨ãƒª: {v}ï¼‰" if i > 0 else ""
                return lat, lon, f"ç·¯åº¦: {lat:.5f}, çµŒåº¦: {lon:.5f} [{title}]{note}", "å›½åœŸåœ°ç†é™¢ï¼ˆGSIï¼‰"

        # â”€â”€ Nominatim ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        time.sleep(1.1)
        for i, v in enumerate(variants):
            if i > 0:
                time.sleep(1.1)
            result = self._try_nominatim(v)
            if result:
                lat, lon, display = result
                note = f"ï¼ˆçŸ­ç¸®ã‚¯ã‚¨ãƒª: {v}ï¼‰" if i > 0 else ""
                return lat, lon, f"ç·¯åº¦: {lat:.5f}, çµŒåº¦: {lon:.5f}{note}", "Nominatim(OpenStreetMap)"

        return None, None, f"åº§æ¨™å–å¾—å¤±æ•—ï¼ˆè©¦è¡Œæ¸ˆ: {len(variants)}ãƒãƒªã‚¢ãƒ³ãƒˆï¼‰: {clean[:40]}", ""


# ---------------------------------------------------------------------------
# 3. è¿‘éš£æ–½è¨­æ¤œç´¢ï¼ˆOverpass APIï¼‰
# ---------------------------------------------------------------------------

class OverpassSearcher:
    URL = "https://overpass-api.de/api/interpreter"

    def search_nearby(
        self, lat: float, lon: float, radius: int = 800
    ) -> Tuple[List[NearbyFacility], List[NearbyFacility], str]:
        # v3.2: æ—¥æœ¬èªã‚¿ã‚°ãƒ»è¿½åŠ  healthcare ã‚¿ã‚°ã‚’æ‹¡å……ã€è–¬å±€ã‚¿ã‚°ã‚’æ‹¡å……
        # (shop=pharmacy / healthcare=pharmacy ã‚‚è¿½åŠ ã—ã€æ—¥æœ¬OSMã®è¡¨è¨˜ã‚†ã‚Œã«å¯¾å¿œ)
        query = f"""
[out:json][timeout:40];
(
  node["amenity"~"^(hospital|clinic|doctors|åŒ»é™¢|è¨ºç™‚æ‰€|ã‚¯ãƒªãƒ‹ãƒƒã‚¯)$"](around:{radius},{lat},{lon});
  way["amenity"~"^(hospital|clinic|doctors|åŒ»é™¢|è¨ºç™‚æ‰€|ã‚¯ãƒªãƒ‹ãƒƒã‚¯)$"](around:{radius},{lat},{lon});
  node["healthcare"~"^(hospital|clinic|doctor|centre|physiotherapist|rehabilitation|dialysis)$"](around:{radius},{lat},{lon});
  way["healthcare"~"^(hospital|clinic|doctor|centre|physiotherapist|rehabilitation|dialysis)$"](around:{radius},{lat},{lon});
  node["medical"](around:{radius},{lat},{lon});
  node["amenity"="pharmacy"](around:{radius},{lat},{lon});
  way["amenity"="pharmacy"](around:{radius},{lat},{lon});
  node["shop"="pharmacy"](around:{radius},{lat},{lon});
  way["shop"="pharmacy"](around:{radius},{lat},{lon});
  node["healthcare"="pharmacy"](around:{radius},{lat},{lon});
  way["healthcare"="pharmacy"](around:{radius},{lat},{lon});
);
out center tags;
"""
        try:
            r = requests.post(self.URL, data={"data": query}, timeout=30)
            r.raise_for_status()
            data = r.json()
        except requests.Timeout:
            return [], [], "Overpass APIã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"
        except Exception as e:
            return [], [], f"Overpass APIã‚¨ãƒ©ãƒ¼: {e}"

        medical, pharmacies = [], []
        for elem in data.get("elements", []):
            tags = elem.get("tags", {})
            name = tags.get("name", tags.get("name:ja", ""))
            if not name:
                continue
            if elem["type"] == "node":
                e_lat, e_lon = elem.get("lat", 0), elem.get("lon", 0)
            else:
                c = elem.get("center", {})
                e_lat, e_lon = c.get("lat", 0), c.get("lon", 0)
            if not (e_lat and e_lon):
                continue
            dist = self._haversine(lat, lon, e_lat, e_lon)
            # v3.2: amenity=pharmacy / shop=pharmacy / healthcare=pharmacy å…¨ã¦è–¬å±€ã¨ã—ã¦æ‰±ã†
            is_pharmacy_tag = (
                tags.get("amenity") == "pharmacy"
                or tags.get("shop") == "pharmacy"
                or tags.get("healthcare") == "pharmacy"
            )
            if is_pharmacy_tag:
                pharmacies.append(NearbyFacility(
                    name=name, facility_type="pharmacy",
                    lat=e_lat, lon=e_lon, distance_m=dist, osm_tags=tags,
                ))
                continue
            ftype = "hospital" if (
                tags.get("amenity") == "hospital" or
                tags.get("healthcare") == "hospital" or
                int(tags.get("beds", 0) or 0) >= 20
            ) else "clinic"
            sp_raw = tags.get("healthcare:speciality", tags.get("specialty", ""))
            specialty = OSM_SPECIALTY_MAP.get(sp_raw.lower(), "") if sp_raw else ""
            # v4.2: OSMã‚¿ã‚°ã« speciality ãŒãªã„å ´åˆã€æ–½è¨­åï¼ˆæ—¥æœ¬èªï¼‰ã‹ã‚‰è¨ºç™‚ç§‘ã‚’æ¨å®š
            if not specialty:
                specialty = detect_specialty_from_name(name)
            has_inhouse = tags.get("pharmacy", "") in ["yes", "dispensing"]
            beds = int(tags.get("beds", 0) or 0)
            # v4.2: è¨ºç™‚ç§‘ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ã£ãŸå¤–æ¥æ‚£è€…æ•°æ¨å®šï¼ˆspecialty ã‚’æ¸¡ã™ï¼‰
            daily_op = self._estimate_outpatients(ftype, beds, tags, specialty)
            medical.append(NearbyFacility(
                name=name, facility_type=ftype,
                lat=e_lat, lon=e_lon, distance_m=dist,
                specialty=specialty, daily_outpatients=daily_op,
                beds=beds, has_inhouse_pharmacy=has_inhouse, osm_tags=tags,
            ))
        medical.sort(key=lambda x: x.distance_m)
        pharmacies.sort(key=lambda x: x.distance_m)
        return medical, pharmacies, f"åŒ»ç™‚æ©Ÿé–¢{len(medical)}ä»¶ãƒ»è–¬å±€{len(pharmacies)}ä»¶"

    @staticmethod
    def _haversine(lat1, lon1, lat2, lon2) -> float:
        R = 6_371_000
        p1, p2 = math.radians(lat1), math.radians(lat2)
        dp, dl = math.radians(lat2 - lat1), math.radians(lon2 - lon1)
        a = math.sin(dp / 2) ** 2 + math.cos(p1) * math.cos(p2) * math.sin(dl / 2) ** 2
        return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    @staticmethod
    def _estimate_outpatients(
        ftype: str, beds: int, tags: Dict, specialty: str = "ä¸æ˜/ãã®ä»–"
    ) -> int:
        """
        v4.2: è¨ºç™‚ç§‘åˆ¥å¤–æ¥æ‚£è€…æ•°ãƒ†ãƒ¼ãƒ–ãƒ« (SPECIALTY_OUTPATIENT_TABLE) ã‚’ä½¿ç”¨ã€‚
        æ—§: åŒ»å¸«æ•°ã ã‘ã§ä¸€å¾‹ 20/40/70 â†’ æ–°: è¨ºç™‚ç§‘ã”ã¨ã®çµ±è¨ˆçš„åŸºç¤å€¤

        å‡ºå…¸: åšç”ŸåŠ´åƒçœã€ŒåŒ»ç™‚æ–½è¨­èª¿æŸ»ã€2020å¹´ ç„¡åºŠè¨ºç™‚æ‰€ è¨ºç™‚ç§‘åˆ¥1æ—¥å¹³å‡å¤–æ¥æ‚£è€…æ•°
        è¨ˆç®—å¼: base + per_dr Ã— max(0, doctors - 1)
        OSMè£œæ­£: Ã—0.85ï¼ˆOSMã®ã¿åéŒ²æ–½è¨­ã¯å…¨å›½å¹³å‡ã‚ˆã‚Šè¦æ¨¡å°ã®å‚¾å‘ï¼‰
        """
        if ftype == "hospital":
            if beds >= 300: return 1_000
            if beds >= 100: return 400
            return 150
        doctors = int(tags.get("staff:count", 0) or 0)
        sp_key = specialty if specialty in SPECIALTY_OUTPATIENT_TABLE else "ä¸æ˜/ãã®ä»–"
        sp_data = SPECIALTY_OUTPATIENT_TABLE[sp_key]
        base    = sp_data["base"]
        per_dr  = sp_data["per_dr"]
        cap     = sp_data["cap"]
        if doctors >= 2:
            estimated = base + per_dr * (doctors - 1)
        else:
            estimated = base  # åŒ»å¸«æ•°ä¸æ˜ or 1å â†’ åŸºç¤å€¤ã®ã¿
        # OSMåéŒ²ã®ã¿æ–½è¨­ã¯å°è¦æ¨¡å‚¾å‘ã®ãŸã‚æ§ãˆã‚è£œæ­£ï¼ˆÃ—0.85ï¼‰
        return max(5, min(cap, int(estimated * 0.85)))


# ---------------------------------------------------------------------------
# 4. åšç”ŸåŠ´åƒçœã‚¹ã‚¯ãƒ¬ã‚¤ãƒ‘ãƒ¼
# ---------------------------------------------------------------------------

class MHLWScraper:
    DOMAIN = "https://www.iryou.teikyouseido.mhlw.go.jp"
    BASE   = DOMAIN + "/znk-web"

    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": (
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                "AppleWebKit/537.36 Chrome/121.0.0.0 Safari/537.36"
            ),
            "Accept-Language": "ja-JP,ja;q=0.9",
        })
        self._initialized = False

    def initialize_session(self) -> bool:
        try:
            r = self.session.get(
                f"{self.BASE}/juminkanja/S2300/initialize", timeout=15,
            )
            self._initialized = r.status_code == 200
            return self._initialized
        except Exception:
            return False

    def search_pharmacy_candidates(
        self, keyword: str, pref_code: str = "", max_pages: int = 3
    ) -> Tuple[List[PharmacyCandidate], int, str]:
        return self._search_candidates(keyword, pref_code, max_pages, sjk="2")

    def search_medical_candidates(self, keyword: str, pref_code: str = ""):
        return self._search_candidates(keyword, pref_code, max_pages=1, sjk="1")

    def _search_candidates(self, keyword, pref_code, max_pages, sjk):
        if not self._initialized:
            self.initialize_session()
        try:
            r = self.session.get(
                f"{self.BASE}/juminkanja/S2300/yakkyokuSearch",
                params={"yakkyokuKeyword": keyword, "yakkyokuKeyword2": "", "searchJudgeKbn": "2"},
                headers={"ajaxFlag": "true"}, timeout=12,
            )
            if r.status_code != 200 or r.json().get("code") != "0":
                return [], 0, "æ¤œç´¢å¤±æ•—"
        except Exception as e:
            return [], 0, f"ã‚¨ãƒ©ãƒ¼: {e}"

        all_cands, total = [], 0
        encoded = urllib.parse.quote(keyword)
        for page in range(max_pages):
            params = {"sjk": sjk, "page": str(page), "size": "20", "sortNo": "1"}
            if pref_code:
                params["prefCd"] = pref_code
            try:
                r2 = self.session.get(
                    f"{self.BASE}/juminkanja/S2400/initialize/{encoded}/",
                    params=params, timeout=15,
                )
                if r2.status_code != 200:
                    break
                cands, t = self._parse_candidate_list(r2.text)
                if page == 0:
                    total = t
                all_cands.extend(cands)
                if not cands or len(all_cands) >= total:
                    break
                time.sleep(0.3)
            except Exception:
                break
        return all_cands, total, f"{len(all_cands)}ä»¶å–å¾—ï¼ˆå…¨{total}ä»¶ï¼‰"

    def _parse_candidate_list(self, html: str) -> Tuple[List[PharmacyCandidate], int]:
        soup = BeautifulSoup(html, "html.parser")
        cands, total = [], 0
        m = re.search(r"(\d{1,6})\s*ä»¶", soup.get_text())
        if m:
            total = int(m.group(1))
        for item in soup.find_all("div", class_="item"):
            h3 = item.find("h3", class_="name")
            if not h3:
                continue
            link = h3.find("a", href=True)
            if not link:
                continue
            name = link.get_text(strip=True)
            href = link.get("href", "")
            if not href:
                continue
            if href.startswith("/"):
                href = self.DOMAIN + href
            qp = dict(urllib.parse.parse_qsl(urllib.parse.urlparse(href).query))
            address = ""
            for dl in item.find_all("dl"):
                dt = dl.find("dt")
                if not dt:
                    continue
                img = dt.find("img")
                dt_text = dt.get_text(strip=True)
                if (img and "ä½æ‰€" in img.get("alt", "")) or any(
                    kw in dt_text for kw in ["ä½æ‰€", "æ‰€åœ¨åœ°"]
                ):
                    dd = dl.find("dd")
                    if dd:
                        for a in dd.find_all("a"):
                            a.decompose()
                        raw = dd.get_text(strip=True)
                        cleaned = re.sub(r"ã€’\s*\d{3}[-ï¼]\d{4}\s*", "", raw)
                        address = re.sub(r"\s+", " ", cleaned).strip()[:100]
                    break
            if name:
                cands.append(PharmacyCandidate(
                    name=name, address=address, href=href,
                    pref_cd=qp.get("prefCd", ""), kikan_cd=qp.get("kikanCd", ""),
                ))
        return cands, max(total, len(cands))

    def get_pharmacy_detail(self, candidate: PharmacyCandidate) -> Tuple[Optional[Dict], str]:
        if not self._initialized:
            self.initialize_session()
        if candidate.pref_cd and candidate.kikan_cd:
            url = (f"{self.BASE}/juminkanja/S2430/initialize"
                   f"?prefCd={candidate.pref_cd}&kikanCd={candidate.kikan_cd}&kikanKbn=5")
        else:
            url = candidate.href
        try:
            r = self.session.get(url, timeout=15)
            if r.status_code != 200:
                return None, f"HTTP {r.status_code}"
            data = self._parse_detail(r.text)
            data["source_url"] = url
            return data, "OK"
        except Exception as e:
            return None, str(e)

    def _parse_detail(self, html: str) -> Dict:
        soup = BeautifulSoup(html, "html.parser")
        fields: Dict[str, str] = {}
        for row in soup.find_all("tr"):
            cells = row.find_all(["th", "td"])
            if len(cells) >= 2:
                k = cells[0].get_text(strip=True)
                if k:
                    fields[k] = cells[1].get_text(strip=True)
        for dl in soup.find_all("dl"):
            for dt, dd in zip(dl.find_all("dt"), dl.find_all("dd")):
                k = dt.get_text(strip=True)
                if k:
                    fields[k] = dd.get_text(strip=True)
        data: Dict = {"all_fields": fields}
        for k, v in fields.items():
            if "æ‰€åœ¨åœ°" in k and "ãƒ•ãƒªã‚¬ãƒŠ" not in k and "è‹±èª" not in k:
                data["address"] = re.sub(r"Googleãƒãƒƒãƒ—.*", "", v).strip()
                break
        rx_annual = None
        for k, v in fields.items():
            if "ç·å–æ‰±å‡¦æ–¹ç®‹æ•°" in k:
                nums = re.findall(r"[\d,]+", v)
                if nums:
                    try:
                        n = int(nums[0].replace(",", ""))
                        if n > 0:
                            rx_annual = n
                            break
                    except (ValueError, OverflowError):
                        pass
        if rx_annual is None:
            full_text = soup.get_text(separator=" ")
            for pat, mult in [
                (r"ç·å–æ‰±å‡¦æ–¹ç®‹æ•°[^\d]*(\d{1,3}(?:,\d{3})*|\d{4,})\s*ä»¶", 1.0),
                (r"é€±\s*å¹³å‡[^\d]{0,15}(\d{1,4})\s*(?:å›|æš)", 52.14),
                (r"å¹´é–“[^\d]{0,15}(\d{1,6}(?:,\d{3})*)\s*(?:å›|ä»¶)", 1.0),
            ]:
                m = re.search(pat, full_text, re.DOTALL)
                if m:
                    try:
                        n = int(m.group(1).replace(",", ""))
                        if n > 0:
                            rx_annual = int(n * mult)
                            break
                    except (ValueError, OverflowError):
                        pass
        data["prescriptions_annual"] = rx_annual
        return data

    def get_medical_outpatient_data(self, facility_name: str) -> Optional[int]:
        if not self._initialized:
            self.initialize_session()
        cands, _, _ = self.search_medical_candidates(facility_name)
        if not cands:
            return None
        best = cands[0]
        for c in cands[:3]:
            if facility_name[:4] in c.name:
                best = c
                break
        try:
            r = self.session.get(best.href, timeout=12)
            if r.status_code != 200:
                return None
            soup = BeautifulSoup(r.text, "html.parser")
            for row in soup.find_all("tr"):
                cells = row.find_all(["th", "td"])
                if len(cells) >= 2:
                    k = cells[0].get_text(strip=True)
                    v = cells[1].get_text(strip=True)
                    if "å¤–æ¥" in k and ("æ‚£è€…" in k or "æ•°" in k):
                        nums = re.findall(r"[\d,]+", v)
                        if nums:
                            return int(nums[0].replace(",", ""))
        except Exception:
            pass
        return None

    def get_rx_for_nearby_pharmacies(
        self,
        pharmacy_names: List[str],
        limit: int = 5,
    ) -> Dict[str, Optional[int]]:
        """è¿‘éš£è–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ã‚’MHLWã‹ã‚‰ä¸€æ‹¬å–å¾—ï¼ˆæ–°è¦é–‹å±€ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰"""
        results: Dict[str, Optional[int]] = {}
        for name in pharmacy_names[:limit]:
            try:
                cands, _, _ = self.search_pharmacy_candidates(name, max_pages=1)
                if cands:
                    best = cands[0]
                    for c in cands[:3]:
                        if name[:4] in c.name or c.name[:4] in name:
                            best = c
                            break
                    detail, _ = self.get_pharmacy_detail(best)
                    results[name] = detail.get("prescriptions_annual") if detail else None
                else:
                    results[name] = None
            except Exception:
                results[name] = None
            time.sleep(0.6)
        return results

    # â”€â”€ v2.4 æ–°è¦: MHLWåŒ»ç™‚æ©Ÿé–¢æ¤œç´¢ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def search_clinic_by_keyword(
        self, keyword: str, pref_code: str = ""
    ) -> List[PharmacyCandidate]:
        """
        MHLWåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ã‚¯ãƒªãƒ‹ãƒƒã‚¯åãƒ»ä½æ‰€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢ (sjk=1: åŒ»ç™‚æ©Ÿé–¢)

        OSMã§æ¤œå‡ºã•ã‚Œãªã‹ã£ãŸã‚¯ãƒªãƒ‹ãƒƒã‚¯ã‚’åç§°ç­‰ã§æ¤œç´¢ã™ã‚‹ãŸã‚ã®è£œåŠ©æ©Ÿèƒ½ã€‚
        """
        cands, _, _ = self._search_candidates(keyword, pref_code, max_pages=2, sjk="1")
        return cands

    def search_medical_by_area(
        self, address: str, pref_code: str = "", max_pages: int = 5
    ) -> Tuple[List[PharmacyCandidate], str]:
        """
        ä½æ‰€ã‹ã‚‰ã‚¨ãƒªã‚¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è‡ªå‹•æŠ½å‡ºã—ã¦MHLWåŒ»ç™‚æ©Ÿé–¢ã‚’ä¸€æ‹¬æ¤œç´¢ (v2.6æ–°æ©Ÿèƒ½)

        OSMã§æœªåéŒ²ã®åŒ»ç™‚æ©Ÿé–¢ã‚’è‡ªå‹•è£œå¡«ã™ã‚‹ãŸã‚ã®ã‚¨ãƒªã‚¢ãƒ™ãƒ¼ã‚¹æ¤œç´¢ã€‚
        - å¸‚åŒºç”ºæ‘åã‚’ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦å…¨æ–½è¨­ã‚’æ¤œç´¢ï¼ˆsjk=1: åŒ»ç™‚æ©Ÿé–¢ï¼‰
        - ä½æ‰€ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã‚‹å€™è£œã®ã¿ã‚’è¿”ã™ï¼ˆåç§°ä¸€è‡´ã®èª¤ãƒ’ãƒƒãƒˆã‚’æ’é™¤ï¼‰
        - æœ€å¤§ max_pages Ã— 20 ä»¶ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 100ä»¶ï¼‰

        Returns:
            (candidates, log_message)
        """
        keyword = extract_area_keyword(address)
        cands, total, msg = self._search_candidates(keyword, pref_code, max_pages, sjk="1")
        # ä½æ‰€ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚€å€™è£œã®ã¿ã«çµã‚Šè¾¼ã‚€ï¼ˆåå‰ä¸€è‡´ã®èª¤ãƒ’ãƒƒãƒˆã‚’æ’é™¤ï¼‰
        filtered = [c for c in cands if c.address and keyword in c.address]
        return filtered, (
            f"MHLWã‚¨ãƒªã‚¢æ¤œç´¢: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰='{keyword}' â†’ "
            f"å…¨{total}ä»¶ä¸­ ä½æ‰€ä¸€è‡´{len(filtered)}ä»¶å–å¾—"
        )

    def get_clinic_daily_outpatients(
        self, candidate: PharmacyCandidate
    ) -> Tuple[Optional[int], str]:
        """
        MHLWåŒ»ç™‚æ©Ÿé–¢è©³ç´°ãƒšãƒ¼ã‚¸ã‹ã‚‰å¤–æ¥æ‚£è€…æ•°ï¼ˆ1æ—¥å¹³å‡ï¼‰ã‚’å–å¾—ã™ã‚‹ã€‚

        MHLW ã®å ±å‘Šå½¢å¼ã¯æ–½è¨­ã«ã‚ˆã£ã¦ç•°ãªã‚‹ãŸã‚ã€è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦ã¿ã‚‹ã€‚
        - ã€Œå¤–æ¥æ‚£è€…æ•°ã€ã€Œ1æ—¥å¹³å‡å¤–æ¥ã€ãªã©ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ¢ç´¢
        - å¹´é–“å€¤ãŒå¾—ã‚‰ã‚ŒãŸå ´åˆã¯ç¨¼åƒæ—¥æ•°(305)ã§å‰²ã£ã¦æ—¥æ¬¡æ›ç®—
        """
        if not self._initialized:
            self.initialize_session()
        if candidate.pref_cd and candidate.kikan_cd:
            url = (f"{self.BASE}/juminkanja/S2430/initialize"
                   f"?prefCd={candidate.pref_cd}&kikanCd={candidate.kikan_cd}&kikanKbn=1")
        else:
            url = candidate.href
        try:
            r = self.session.get(url, timeout=12)
            if r.status_code != 200:
                return None, f"HTTP {r.status_code}"
            soup = BeautifulSoup(r.text, "html.parser")
            fields: Dict[str, str] = {}
            for row in soup.find_all("tr"):
                cells = row.find_all(["th", "td"])
                if len(cells) >= 2:
                    k = cells[0].get_text(strip=True)
                    v = cells[1].get_text(strip=True)
                    if k:
                        fields[k] = v
            # 1æ—¥å¹³å‡å¤–æ¥æ‚£è€…æ•°ï¼ˆç›´æ¥è¨˜è¼‰ï¼‰
            for k, v in fields.items():
                if ("1æ—¥å¹³å‡" in k or "ä¸€æ—¥å¹³å‡" in k) and "å¤–æ¥" in k:
                    nums = re.findall(r"[\d,]+", v)
                    if nums:
                        try:
                            n = int(nums[0].replace(",", ""))
                            if 1 <= n <= 3000:
                                return n, f"MHLWå–å¾—: {k}"
                        except (ValueError, OverflowError):
                            pass
            # å¹´é–“å¤–æ¥æ‚£è€…æ•°ï¼ˆ305æ—¥ã§å‰²ã£ã¦æ—¥æ¬¡æ›ç®—ï¼‰
            for k, v in fields.items():
                if "å¤–æ¥" in k and ("æ‚£è€…" in k or "æ•°" in k) and "å¹´é–“" in k:
                    nums = re.findall(r"[\d,]+", v)
                    if nums:
                        try:
                            n = int(nums[0].replace(",", ""))
                            if n > 300:
                                daily = int(n / NATIONAL_STATS["working_days"])
                                return daily, f"MHLWå¹´é–“å€¤ã‹ã‚‰æ›ç®—({n:,}â†’{daily}/æ—¥)"
                        except (ValueError, OverflowError):
                            pass
            return None, "å¤–æ¥æ‚£è€…æ•°ã®è¨˜è¼‰ãªã—"
        except Exception as e:
            return None, f"å–å¾—ã‚¨ãƒ©ãƒ¼: {e}"


# ---------------------------------------------------------------------------
# 4-b. v4.1: æ ¡æ­£ã‚¨ãƒ³ã‚¸ãƒ³
# ---------------------------------------------------------------------------

class CalibrationEngine:
    """
    MHLWã®å®Ÿç¸¾å‡¦æ–¹ç®‹ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ãƒ¢ãƒ‡ãƒ«ã‚’æ ¡æ­£ã™ã‚‹ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆv4.1ï¼‰

    ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼:
      1. search_calibration_set()  â€¦ MHLWæ¤œç´¢ â†’ å®Ÿç¸¾Rxã‚ã‚Šè–¬å±€ã‚’åé›†
      2. run_batch()               â€¦ å„è–¬å±€ã‚’ä½æ‰€ã®ã¿ã§äºˆæ¸¬ â†’ CalibrationPoint ãƒªã‚¹ãƒˆ
      3. calc_stats()              â€¦ MAPEãƒ»è£œæ­£ä¿‚æ•°ãƒ»æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’è¨ˆç®—
      4. apply_correction()        â€¦ æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å®Ÿéš›ã®äºˆæ¸¬ã«é©ç”¨

    æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:
      â–  å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•° Î±(density)
           Î± = geometric_mean(actual / predicted) per density band
           â†’ systematic over/under-estimate ã‚’ä¹—ç®—ã§è£œæ­£
      â–  æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ w*
           MAPE(w) = mean(|wÃ—M1 + (1-w)Ã—M2 - actual| / actual) ã‚’æœ€å°åŒ–
    """

    def __init__(self):
        self._scraper = MHLWScraper()
        self._geocoder = GeocoderService()

    # â”€â”€ Step 1: æ ¡æ­£ç”¨è–¬å±€ã‚»ãƒƒãƒˆã®åé›† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def search_calibration_set(
        self,
        pref_code: str,
        keyword: str = "è–¬å±€",
        max_pharmacies: int = 30,
        min_rx: int = 1_000,
        progress_cb: Optional[Callable[[int, str], None]] = None,
    ) -> List[Tuple["PharmacyCandidate", int]]:
        """
        MHLWã§éƒ½é“åºœçœŒãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢ã—ã€å‡¦æ–¹ç®‹æšæ•°ãŒå–å¾—ã§ããŸè–¬å±€ã‚’è¿”ã™ã€‚

        Returns: List of (PharmacyCandidate, annual_rx)
        """
        if not self._scraper._initialized:
            self._scraper.initialize_session()

        # è–¬å±€å€™è£œã‚’æ¤œç´¢ï¼ˆæœ€å¤§3ãƒšãƒ¼ã‚¸ = 60ä»¶ï¼‰
        candidates, _, _ = self._scraper.search_pharmacy_candidates(
            keyword, pref_code, max_pages=3
        )
        if progress_cb:
            progress_cb(5, f"MHLWæ¤œç´¢: {len(candidates)}ä»¶ã®è–¬å±€å€™è£œã‚’å–å¾—")

        result: List[Tuple["PharmacyCandidate", int]] = []
        for i, cand in enumerate(candidates):
            if len(result) >= max_pharmacies:
                break
            if not cand.address:
                continue
            try:
                detail, _ = self._scraper.get_pharmacy_detail(cand)
                rx = detail.get("prescriptions_annual") if detail else None
                if rx and rx >= min_rx:
                    result.append((cand, rx))
            except Exception:
                pass
            time.sleep(0.5)
            if progress_cb:
                pct = int(5 + 40 * (i + 1) / max(len(candidates), 1))
                progress_cb(pct, f"MHLWè©³ç´°å–å¾—ä¸­ ({i+1}/{len(candidates)}) â€¦ æœ‰åŠ¹: {len(result)}ä»¶")

        if progress_cb:
            progress_cb(45, f"æ ¡æ­£ã‚»ãƒƒãƒˆåé›†å®Œäº†: {len(result)}ä»¶")
        return result

    # â”€â”€ Step 2: ä½æ‰€ã®ã¿ã§äºˆæ¸¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def predict_for_candidate(
        self,
        cand: "PharmacyCandidate",
        actual_rx: int,
    ) -> "CalibrationPoint":
        """
        1è–¬å±€ã«ã¤ã„ã¦ä½æ‰€ã®ã¿ã®æƒ…å ±ã§æ–¹æ³•â‘ ãƒ»â‘¡äºˆæ¸¬ã‚’å®Ÿè¡Œã— CalibrationPoint ã‚’è¿”ã™ã€‚
        """
        pt = CalibrationPoint(name=cand.name, address=cand.address, actual_rx=actual_rx)
        log: List[str] = []

        try:
            # 1. ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
            lat, lon, geo_msg, _ = self._geocoder.geocode(cand.address)
            log.append(f"[Geo] {geo_msg}")
            if not (lat and lon):
                log.append("âš  ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å¤±æ•— â†’ ã‚¹ã‚­ãƒƒãƒ—")
                pt.error_log = log
                return pt

            # 2. äººå£å¯†åº¦ãƒ»å•†åœåŠå¾„
            density, _ = get_population_density(cand.address)
            pt.area_density = density
            is_gate, gate_reason = detect_gate_pharmacy(cand.name, [])
            pt.is_gate = is_gate
            radius, _ = calc_commercial_radius(density, is_gate, gate_reason)
            search_r = max(int(radius * 1.5), 600)

            # 3. OSMæ¤œç´¢
            ov = OverpassSearcher()
            medical, pharmacies, ov_msg = ov.search_nearby(lat, lon, search_r)
            log.append(f"[OSM] {ov_msg}")
            pt.n_medical = len(medical)
            pt.n_pharmacies = len(pharmacies)

            # 4. MHLWåŒ»ç™‚æ©Ÿé–¢è£œå¡«ï¼ˆè»½é‡ç‰ˆ: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢ã®ã¿ï¼‰
            pref_code = ""
            for pn, pc in PREFECTURE_CODES.items():
                if pn in cand.address:
                    pref_code = pc
                    break
            new_facs, sup_log = fetch_mhlw_medical_supplement(
                pharmacy_lat=lat, pharmacy_lon=lon,
                pharmacy_address=cand.address, pref_code=pref_code,
                existing_osm=medical, search_radius_m=search_r,
            )
            log.extend(sup_log[:3])
            if new_facs:
                medical = medical + new_facs
                pt.n_medical += len(new_facs)

            # 5. åŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£
            medical = apply_clinic_congestion_factor(medical)

            # 6. æ–¹æ³•â‘ 
            m1_result = Method1Predictor().predict(lat, lon, medical, pharmacies)
            pt.m1_rx = m1_result.annual_rx

            # 7. æ–¹æ³•â‘¡
            m2_result = Method2Predictor().predict(
                lat, lon, pharmacies, density, radius,
                nearby_medical=medical,
            )
            pt.m2_rx = m2_result.annual_rx

            log.append(f"[çµæœ] å®Ÿç¸¾={actual_rx:,} M1={pt.m1_rx:,} M2={pt.m2_rx:,}")

        except Exception as e:
            log.append(f"âš  äºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {e}")

        pt.error_log = log
        return pt

    # â”€â”€ Step 3: ãƒãƒƒãƒå®Ÿè¡Œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def run_batch(
        self,
        calibration_set: List[Tuple["PharmacyCandidate", int]],
        progress_cb: Optional[Callable[[int, str], None]] = None,
        delay: float = 0.8,
    ) -> List["CalibrationPoint"]:
        """æ ¡æ­£ã‚»ãƒƒãƒˆå…¨ä»¶ã®äºˆæ¸¬ã‚’å®Ÿè¡Œã—ã¦ CalibrationPoint ãƒªã‚¹ãƒˆã‚’è¿”ã™"""
        points: List[CalibrationPoint] = []
        n = len(calibration_set)
        for i, (cand, actual_rx) in enumerate(calibration_set):
            if progress_cb:
                pct = int(45 + 50 * i / max(n, 1))
                progress_cb(pct, f"äºˆæ¸¬ä¸­ ({i+1}/{n}): {cand.name[:20]}â€¦")
            pt = self.predict_for_candidate(cand, actual_rx)
            points.append(pt)
            time.sleep(delay)

        if progress_cb:
            valid = sum(1 for p in points if p.m1_rx is not None)
            progress_cb(95, f"ãƒãƒƒãƒå®Œäº†: {valid}/{n}ä»¶ äºˆæ¸¬æˆåŠŸ")
        return points

    # â”€â”€ Step 4: çµ±è¨ˆè¨ˆç®— â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @staticmethod
    def calc_stats(points: List["CalibrationPoint"]) -> Optional["CalibrationStats"]:
        """
        CalibrationPoint ãƒªã‚¹ãƒˆã‹ã‚‰ CalibrationStats ã‚’è¨ˆç®—ã™ã‚‹ã€‚

        è£œæ­£ä¿‚æ•°ã®è¨ˆç®—æ–¹æ³•:
          Î±(band) = exp( mean( log(actual / predicted) ) ) for samples in band
          = geometric mean of (actual / predicted) ratios
          â†’ predicted Ã— Î± = ãƒã‚¤ã‚¢ã‚¹é™¤å»å¾Œã®æ¨è¨ˆå€¤

        æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ w* ã®æ¢ç´¢:
          w âˆˆ {0.0, 0.1, ..., 1.0} ã§ MAPE(w) ã‚’è¨ˆç®—ã—æœ€å°åŒ–
          MAPE(w) = mean(|wÃ—M1 + (1-w)Ã—M2 - actual| / actual)
        """
        # ä¸¡æ–¹ã®äºˆæ¸¬å€¤ãŒã‚ã‚‹æœ‰åŠ¹ã‚µãƒ³ãƒ—ãƒ«ã®ã¿ä½¿ç”¨
        valid = [p for p in points if p.m1_rx is not None and p.m2_rx is not None and p.actual_rx > 0]
        if len(valid) < 3:
            return None  # ã‚µãƒ³ãƒ—ãƒ«ä¸è¶³

        import math as _math

        # â”€â”€ MAPE (%) â”€â”€
        def mape(preds: List[float], actuals: List[float]) -> float:
            return 100.0 * sum(abs(p - a) / a for p, a in zip(preds, actuals)) / len(actuals)

        actuals = [float(p.actual_rx) for p in valid]
        m1s = [float(p.m1_rx) for p in valid]
        m2s = [float(p.m2_rx) for p in valid]

        mape_m1 = mape(m1s, actuals)
        mape_m2 = mape(m2s, actuals)

        # â”€â”€ ãƒã‚¤ã‚¢ã‚¹ (log scale: log(predicted/actual) ã®å¹³å‡) â”€â”€
        bias_m1 = sum(_math.log(max(m, 1) / a) for m, a in zip(m1s, actuals)) / len(valid)
        bias_m2 = sum(_math.log(max(m, 1) / a) for m, a in zip(m2s, actuals)) / len(valid)

        # â”€â”€ æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ w* â”€â”€
        best_w, best_mape = 0.5, float("inf")
        for w_int in range(0, 11):
            w = w_int / 10.0
            blended = [w * m1 + (1 - w) * m2 for m1, m2 in zip(m1s, m2s)]
            mp = mape(blended, actuals)
            if mp < best_mape:
                best_mape, best_w = mp, w

        # â”€â”€ å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•° â”€â”€
        def alpha_for_band(preds: List[float]) -> Tuple[float, int]:
            """geometric mean of (actual/predicted) = exp(mean(log(actual/pred)))"""
            ratios = [_math.log(a / max(p, 1)) for p, a in zip(preds, actuals)]
            return _math.exp(sum(ratios) / len(ratios)), len(ratios)

        bands = list({p.density_band for p in valid})
        alpha_m1: Dict[str, Tuple[float, int]] = {}
        alpha_m2: Dict[str, Tuple[float, int]] = {}
        for band in bands:
            band_pts = [p for p in valid if p.density_band == band]
            if len(band_pts) < 2:
                continue
            band_actuals = [float(p.actual_rx) for p in band_pts]
            band_m1 = [float(p.m1_rx) for p in band_pts]
            band_m2 = [float(p.m2_rx) for p in band_pts]

            def alpha_band(preds: List[float], acts: List[float]) -> Tuple[float, int]:
                ratios = [_math.log(a / max(p, 1)) for p, a in zip(preds, acts)]
                return _math.exp(sum(ratios) / len(ratios)), len(ratios)

            alpha_m1[band] = alpha_band(band_m1, band_actuals)
            alpha_m2[band] = alpha_band(band_m2, band_actuals)

        return CalibrationStats(
            n=len(valid),
            mape_m1=round(mape_m1, 1),
            mape_m2=round(mape_m2, 1),
            mape_optimal=round(best_mape, 1),
            optimal_m1_weight=best_w,
            bias_m1=round(bias_m1, 3),
            bias_m2=round(bias_m2, 3),
            alpha_m1=alpha_m1,
            alpha_m2=alpha_m2,
            calibrated_at=datetime.now().strftime("%Y-%m-%d %H:%M"),
        )

    # â”€â”€ Step 5: æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é©ç”¨ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    @staticmethod
    def apply_correction(
        m1_rx: int,
        m2_rx: int,
        density: int,
        stats: "CalibrationStats",
    ) -> Tuple[int, str]:
        """
        æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨ã—ã¦æœ€çµ‚æ¨è¨ˆå€¤ã‚’è¨ˆç®—ã™ã‚‹ã€‚

        è¨ˆç®—å¼:
          M1_cal = M1 Ã— Î±1(density_band)
          M2_cal = M2 Ã— Î±2(density_band)
          final  = w* Ã— M1_cal + (1-w*) Ã— M2_cal

        Returns: (calibrated_annual_rx, explanation_str)
        """
        band = _density_band(density)
        alpha1 = stats.alpha_m1.get(band, (1.0, 0))[0]
        alpha2 = stats.alpha_m2.get(band, (1.0, 0))[0]
        w = stats.optimal_m1_weight

        m1_cal = int(m1_rx * alpha1)
        m2_cal = int(m2_rx * alpha2)
        final = int(w * m1_cal + (1 - w) * m2_cal)

        n1 = stats.alpha_m1.get(band, (1.0, 0))[1]
        n2 = stats.alpha_m2.get(band, (1.0, 0))[1]
        note = (
            f"å¯†åº¦å¸¯={band} | "
            f"Î±1={alpha1:.2f}(n={n1}) Î±2={alpha2:.2f}(n={n2}) | "
            f"w*={w:.1f} (M1:{m1_cal:,} + M2:{m2_cal:,})"
        )
        return final, note

    @staticmethod
    def points_to_csv(points: List["CalibrationPoint"]) -> str:
        """æ ¡æ­£ãƒ‡ãƒ¼ã‚¿ã‚’CSVæ–‡å­—åˆ—ã¨ã—ã¦å‡ºåŠ›"""
        buf = io.StringIO()
        writer = csv.writer(buf)
        writer.writerow([
            "è–¬å±€å", "ä½æ‰€", "å®Ÿç¸¾Rx", "M1äºˆæ¸¬", "M2äºˆæ¸¬",
            "M1èª¤å·®ç‡", "M2èª¤å·®ç‡", "äººå£å¯†åº¦", "å¯†åº¦å¸¯",
            "åŒ»ç™‚æ©Ÿé–¢æ•°", "ç«¶åˆè–¬å±€æ•°", "é–€å‰",
        ])
        for p in points:
            writer.writerow([
                p.name, p.address, p.actual_rx,
                p.m1_rx or "", p.m2_rx or "",
                f"{p.error_m1*100:.1f}%" if p.error_m1 is not None else "",
                f"{p.error_m2*100:.1f}%" if p.error_m2 is not None else "",
                p.area_density, p.density_band,
                p.n_medical, p.n_pharmacies,
                "ã¯ã„" if p.is_gate else "ã„ã„ãˆ",
            ])
        return buf.getvalue()


# ---------------------------------------------------------------------------
# 5-pre. åŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ + ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ï¼ˆv4.2ï¼‰
# ---------------------------------------------------------------------------

def calc_smart_blend_weight(
    area_density: int,
    n_medical: int,
    n_mhlw_confirmed: int,
) -> Tuple[float, str]:
    """
    v4.2: ãƒ‡ãƒ¼ã‚¿å“è³ªã‚·ã‚°ãƒŠãƒ«ã«åŸºã¥ãå‹•çš„M1/M2ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ï¼ˆæ ¡æ­£ãªã—æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰

    â–  è¨­è¨ˆæ–¹é‡:
      M1ï¼ˆåŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰ãŒä¿¡é ¼ã§ãã‚‹ã‚·ã‚°ãƒŠãƒ«:
        ãƒ»è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ãŒå¤šã„ï¼ˆãƒ‡ãƒ¼ã‚¿é‡â†‘ï¼‰
        ãƒ»MHLWç¢ºèªæ¸ˆã¿æ–½è¨­ãŒå¤šã„ï¼ˆM1ç²¾åº¦â†‘ï¼‰
        ãƒ»ä½å¯†åº¦åœ°åŸŸï¼ˆäººå£ãƒ‡ãƒ¼ã‚¿ã‚ˆã‚Šæ–½è¨­ãƒ‡ãƒ¼ã‚¿ãŒå®‰å®šï¼‰
      M2ï¼ˆå•†åœäººå£ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰ãŒä¿¡é ¼ã§ãã‚‹ã‚·ã‚°ãƒŠãƒ«:
        ãƒ»é«˜å¯†åº¦éƒ½å¸‚éƒ¨ï¼ˆäººå£ãƒ‡ãƒ¼ã‚¿å®‰å®šï¼‰
        ãƒ»åŒ»ç™‚æ©Ÿé–¢ãŒå°‘ãªã„ï¼ˆM1ãƒ‡ãƒ¼ã‚¿ãŒä¹ã—ã„ï¼‰

    Returns: (w_m1, reason_str)
      w_m1: M1ã®é‡ã¿ [0.3 ã€œ 0.7]
      æœ€çµ‚æ¨å¥¨ = w_m1 Ã— M1 + (1 - w_m1) Ã— M2
    """
    w = 0.50  # ãƒ™ãƒ¼ã‚¹é‡ã¿ï¼ˆç­‰ã‚¦ã‚§ã‚¤ãƒˆï¼‰
    reasons = ["ãƒ™ãƒ¼ã‚¹50/50"]

    # äººå£å¯†åº¦ã‚·ã‚°ãƒŠãƒ«
    if area_density > 10_000:
        w -= 0.12
        reasons.append("è¶…é«˜å¯†åº¦â†’M2â†‘(âˆ’12%)")
    elif area_density > 5_000:
        w -= 0.07
        reasons.append("é«˜å¯†åº¦â†’M2â†‘(âˆ’7%)")
    elif area_density < 500:
        w += 0.08
        reasons.append("è¶…ä½å¯†åº¦â†’M1â†‘(+8%)")

    # åŒ»ç™‚æ©Ÿé–¢æ•°ã‚·ã‚°ãƒŠãƒ«
    if n_medical >= 10:
        w += 0.12
        reasons.append("åŒ»ç™‚æ©Ÿé–¢10ä»¶â†‘â†’M1â†‘(+12%)")
    elif n_medical >= 5:
        w += 0.07
        reasons.append("åŒ»ç™‚æ©Ÿé–¢5ä»¶â†‘â†’M1â†‘(+7%)")
    elif n_medical < 3:
        w -= 0.08
        reasons.append("åŒ»ç™‚æ©Ÿé–¢å°‘â†’M2â†‘(âˆ’8%)")

    # MHLWç¢ºèªæ¸ˆã¿æ–½è¨­ã‚·ã‚°ãƒŠãƒ«ï¼ˆå¤–æ¥æ‚£è€…æ•°ãŒå®Ÿç¸¾å€¤ã§ä¿¡é ¼æ€§é«˜ã„ï¼‰
    if n_mhlw_confirmed >= 3:
        w += 0.08
        reasons.append(f"MHLWç¢ºèª{n_mhlw_confirmed}ä»¶â†’M1ç²¾åº¦â†‘(+8%)")
    elif n_mhlw_confirmed >= 1:
        w += 0.04
        reasons.append(f"MHLWç¢ºèª{n_mhlw_confirmed}ä»¶â†’M1ç²¾åº¦â†‘(+4%)")

    w = max(0.30, min(0.70, w))
    reason = f"ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ M1:{w:.0%} / M2:{1-w:.0%} ï¼ˆ{', '.join(reasons)}ï¼‰"
    return w, reason


def apply_clinic_congestion_factor(
    facilities: List["NearbyFacility"],
    log: Optional[List[str]] = None,
) -> List["NearbyFacility"]:
    """
    åŒ»ç™‚æ©Ÿé–¢ãŒå¯†é›†ã—ã¦ã„ã‚‹ã‚¨ãƒªã‚¢ã§ã¯ã€ã‚¯ãƒªãƒ‹ãƒƒã‚¯1ä»¶ã‚ãŸã‚Šã®æ‚£è€…æ•°ãŒåˆ†æ•£ã™ã‚‹ã€‚
    MHLWã§å¤–æ¥æ‚£è€…æ•°ãŒç¢ºèªã•ã‚Œã¦ã„ãªã„ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤ï¼‰æ–½è¨­ã«è£œæ­£ä¿‚æ•°ã‚’é©ç”¨ã™ã‚‹ã€‚

    â–  æ ¹æ‹ :
      åŒ»ç™‚æ©Ÿé–¢ãŒå¤šã„ã‚¨ãƒªã‚¢ã¯ã€Œæ‚£è€…ã‚’å¥ªã„åˆã†ç«¶äº‰ç’°å¢ƒã€ã§ã‚ã‚Šã€1ä»¶ã‚ãŸã‚Šã®å¹³å‡æ‚£è€…æ•°ãŒ
      å…¨å›½å¹³å‡ã‚ˆã‚Šå°‘ãªã„ã€‚ä¾‹ãˆã°å›½ç«‹å¸‚ä¸­1ä¸ç›®ã®ã‚ˆã†ãªåŒ»ç™‚ãƒ¢ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ã§ã¯10ä»¶ä»¥ä¸Šã®
      ã‚¯ãƒªãƒ‹ãƒƒã‚¯ãŒé›†ä¸­ã™ã‚‹ãŸã‚ã€å€‹ã€…ã®æ‚£è€…æ•°ã¯å¤§ããä¸‹ãŒã‚‹ã€‚

    â–  v4.2: æŒ‡æ•°æ¸›è¡°ã«å¤‰æ›´ï¼ˆã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°ã®é–¾å€¤ã‚¸ãƒ£ãƒ³ãƒ—ã‚’å»ƒæ­¢ï¼‰
      factor = max(0.50, exp(âˆ’0.035 Ã— max(0, n âˆ’ 5))
      å¯¾ç…§è¡¨ï¼ˆæ—§ â†’ æ–°ï¼‰:
        n=5:  1.00 â†’ 1.00
        n=9:  0.85 â†’ 0.87  (+0.02)
        n=14: 0.70 â†’ 0.73  (+0.03)
        n=19: 0.60 â†’ 0.61  (+0.01)
        n=24: 0.50 â†’ 0.51  (â‰’åŒç­‰ã€ä¸‹é™0.50)
    """
    # MHLWå¤–æ¥æ‚£è€…æ•°æœªç¢ºèªã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤æ–½è¨­ã®ã¿ã‚«ã‚¦ãƒ³ãƒˆ
    # ãƒ»OSMå–å¾—æ–½è¨­ï¼ˆis_manual=False, source="osm"ï¼‰â†’ å¯¾è±¡
    # ãƒ»MHLWè£œå¡«æ–½è¨­ï¼ˆis_manual=True,  source="mhlw"ï¼‰â†’ å¯¾è±¡ï¼ˆå¤–æ¥æ•°æœªç¢ºèªã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰
    # ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰‹å‹•å…¥åŠ›æ–½è¨­ï¼ˆis_manual=True, source="osm"ï¼‰â†’ å¯¾è±¡å¤–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›å€¤ã‚’å°Šé‡ï¼‰
    unconfirmed = [
        f for f in facilities
        if f.mhlw_annual_outpatients is None
        and not (f.is_manual and f.source != "mhlw")
    ]
    n = len(unconfirmed)

    if n < 6:
        return facilities  # è£œæ­£ä¸è¦

    # v4.2: æŒ‡æ•°æ¸›è¡° factor = max(0.50, exp(âˆ’0.035 Ã— (n âˆ’ 5)))
    factor = max(0.50, math.exp(-0.035 * (n - 5)))

    for f in unconfirmed:
        f.daily_outpatients = max(5, int(f.daily_outpatients * factor))

    if log is not None:
        log.append(
            f"[å¯†é›†è£œæ­£ v4.2] MHLWå¤–æ¥æœªç¢ºèªæ–½è¨­{n}ä»¶ â†’ æŒ‡æ•°æ¸›è¡°ä¿‚æ•°Ã—{factor:.3f}ã‚’é©ç”¨"
            f"ï¼ˆå¤–æ¥æ‚£è€…æ•°ã‚’ç´„{1/factor:.1f}åˆ†ã®1ã«åœ§ç¸®ï¼‰"
        )
    return facilities


# ---------------------------------------------------------------------------
# 5. æ–¹æ³•â‘  è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
# ---------------------------------------------------------------------------

class Method1Predictor:
    OUTPATIENT_RX_RATE = NATIONAL_STATS["outpatient_rx_rate"]

    def predict(
        self,
        pharmacy_lat: float,
        pharmacy_lon: float,
        medical_facilities: List[NearbyFacility],
        competing_pharmacies: List[NearbyFacility],
        mode_label: str = "æ–¹æ³•â‘ : è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ",
    ) -> PredictionResult:
        breakdown, total_daily = [], 0.0
        methodology = [
            f"### {mode_label} ãƒ­ã‚¸ãƒƒã‚¯",
            "",
            "**ç®—å‡ºå¼**: å„æ–½è¨­ã®å¤–æ¥æ‚£è€…æ•° Ã— è¨ºç™‚ç§‘åˆ¥å‡¦æ–¹ç®‹ç™ºè¡Œç‡",
            "Ã— é™¢å¤–å‡¦æ–¹ç‡ï¼ˆ79.0%ï¼‰Ã— å½“è–¬å±€é›†å®¢ã‚·ã‚§ã‚¢ â†’ åˆè¨ˆ Ã— å¹´é–“ç¨¼åƒæ—¥æ•°(305æ—¥)",
            f"**v3.2ã‚·ã‚§ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæ®‹ä½™ã‚·ã‚§ã‚¢ãƒ¢ãƒ‡ãƒ«ï¼‰**: åŒ»ç™‚æ©Ÿé–¢50mä»¥å†…ã«ç«¶åˆè–¬å±€ãŒã‚ã‚Œã°",
            f"ã€Œæ—¢å­˜é–€å‰è–¬å±€ã€ã¨åˆ¤å®šã—å‡¦æ–¹ç®‹ã®{GATE_PHARMACY_CAPTURE_RATE:.0%}ãŒæ•æ‰ã•ã‚Œã‚‹ã¨ä»®å®šã€‚",
            f"æ®‹ã‚Š{1-GATE_PHARMACY_CAPTURE_RATE:.0%}ã‚’å½“è–¬å±€ã¨éé–€å‰ç«¶åˆã§HuffæŒ‰åˆ†ï¼ˆäºŒé‡å‰²å¼•ãªã—ï¼‰ã€‚",
            "æ—¢å­˜é–€å‰è–¬å±€ãªã—æ™‚ã¯è·é›¢å¸¯åˆ¥ãƒ™ãƒ¼ã‚¹ï¼ˆâ‰¤50m:75%/â‰¤150m:50%/â‰¤300m:30%/300mè¶…:15%ï¼‰Ã—HuffæŒ‰åˆ†ã€‚",
            "",
            f"**å¯¾è±¡åŒ»ç™‚æ–½è¨­**: {len(medical_facilities)}ä»¶",
            "",
        ]
        for fac in medical_facilities:
            if fac.daily_outpatients == 0:
                continue
            rx_rate, _ = SPECIALTY_RX_RATES.get(fac.specialty, SPECIALTY_RX_RATES["ä¸æ˜/ãã®ä»–"])
            daily_rx = fac.daily_outpatients * rx_rate * self.OUTPATIENT_RX_RATE
            if fac.has_inhouse_pharmacy:
                daily_rx *= 0.6
            # v3.2: has_gate_pharmacy ãƒ•ãƒ©ã‚°ã«ã‚ˆã‚‹å›ºå®šÃ—0.4 å»ƒæ­¢ã€‚
            # æ—¢å­˜é–€å‰è–¬å±€ã®æœ‰ç„¡ã¯ _calc_share() å†…ã§ç«¶åˆè–¬å±€ã®å®Ÿéš›ã®ç«‹åœ°ã‹ã‚‰å‹•çš„ã«åˆ¤å®šã€‚
            share, share_reason = self._calc_share(fac, pharmacy_lat, pharmacy_lon, competing_pharmacies)
            flow = daily_rx * share
            breakdown.append({
                "æ–½è¨­å": fac.name,
                "ã‚¿ã‚¤ãƒ—": "ç—…é™¢" if fac.facility_type == "hospital" else "ã‚¯ãƒªãƒ‹ãƒƒã‚¯",
                "è·é›¢": f"{fac.distance_m:.0f}m",
                "è¨ºç™‚ç§‘": fac.specialty,
                "å¤–æ¥æ‚£è€…/æ—¥": fac.daily_outpatients,
                "å‡¦æ–¹ç®‹ç™ºè¡Œç‡": f"{rx_rate:.0%}",
                "é™¢å¤–å‡¦æ–¹ç®‹/æ—¥": round(daily_rx),
                "å½“è–¬å±€ã‚·ã‚§ã‚¢": f"{share:.1%}",
                "ã‚·ã‚§ã‚¢æ ¹æ‹ ": share_reason,
                "å½“è–¬å±€æµå…¥/æ—¥": round(flow),
            })
            total_daily += flow
            methodology.append(
                f"**{fac.name}** ({fac.distance_m:.0f}m): "
                f"{fac.daily_outpatients}äºº/æ—¥ Ã— {rx_rate:.0%} Ã— 79.0% Ã— {share:.0%} = {flow:.1f}æš/æ—¥"
            )
        annual = int(total_daily * NATIONAL_STATS["working_days"])
        if not medical_facilities:
            methodology.append("âš  è¿‘éš£ã«åŒ»ç™‚æ–½è¨­ãªã— â†’ å…¨å›½ä¸­å¤®å€¤ã‚’ä½¿ç”¨")
            annual = NATIONAL_STATS["median_estimate"]
        methodology += [
            "", f"**åˆè¨ˆ**: {total_daily:.1f}æš/æ—¥ Ã— 305æ—¥ = **{annual:,}æš/å¹´**",
        ]
        return PredictionResult(
            method_name=mode_label,
            annual_rx=annual,
            min_val=int(annual * 0.6),
            max_val=int(annual * 1.8),
            confidence="medium" if medical_facilities else "low",
            daily_rx=int(total_daily),
            breakdown=breakdown,
            methodology=methodology,
            references=[
                {"name": "åšç”ŸåŠ´åƒçœã€Œå—ç™‚è¡Œå‹•èª¿æŸ»ã€2020å¹´",
                 "desc": "è¨ºç™‚ç§‘åˆ¥å‡¦æ–¹ç®‹ç™ºè¡Œç‡ã®æ ¹æ‹ ãƒ‡ãƒ¼ã‚¿",
                 "url": "https://www.mhlw.go.jp/toukei/list/35-34.html"},
                {"name": "åšç”ŸåŠ´åƒçœã€Œèª¿å‰¤åŒ»ç™‚è²»ã®å‹•å‘ã€2022å¹´åº¦",
                 "desc": f"é™¢å¤–å‡¦æ–¹ç‡ï¼ˆå…¨å›½å¹³å‡ {self.OUTPATIENT_RX_RATE:.1%}ï¼‰ã®æ ¹æ‹ ãƒ‡ãƒ¼ã‚¿",
                 "url": "https://www.mhlw.go.jp/topics/medias/med/"},
                {"name": "OpenStreetMap / Overpass API",
                 "desc": "è¿‘éš£æ–½è¨­ãƒ‡ãƒ¼ã‚¿ï¼ˆåç§°ãƒ»ä½ç½®ãƒ»ã‚¿ã‚°ï¼‰ã®ã‚½ãƒ¼ã‚¹",
                 "url": "https://overpass-api.de/"},
            ],
        )

    def _calc_share(self, fac, ph_lat, ph_lon, competitors) -> Tuple[float, str]:
        """
        åŒ»ç™‚æ©Ÿé–¢ã”ã¨ã®å½“è–¬å±€é›†å®¢ã‚·ã‚§ã‚¢ã‚’æ¨è¨ˆã™ã‚‹ï¼ˆv3.2: æ®‹ä½™ã‚·ã‚§ã‚¢ãƒ¢ãƒ‡ãƒ«ã«å¤‰æ›´ï¼‰

        â–  è¨­è¨ˆæ€æƒ³ï¼ˆv3.2 å¤§å¹…æ”¹ä¿®ï¼‰:
          æ—§v3.2ã§ã¯ã€Œãƒ™ãƒ¼ã‚¹ã‚·ã‚§ã‚¢å‰²å¼• Ã— HuffæŒ‰åˆ†ã€ã®äºŒé‡å‰²å¼•ã«ãªã£ã¦ãŠã‚Šã€
          æ—¢å­˜é–€å‰è–¬å±€ã‚ã‚Šãƒ»ç«¶åˆ1ä»¶ã®å ´åˆã«1ã€œ2%ã¨ã„ã†éå°æ¨è¨ˆãŒç™ºç”Ÿã—ã¦ã„ãŸã€‚

          â†’ ã€Œæ®‹ä½™ã‚·ã‚§ã‚¢ãƒ¢ãƒ‡ãƒ«ï¼ˆAvailable Share Modelï¼‰ã€ã«å¤‰æ›´:
              [A] åŒ»ç™‚æ©Ÿé–¢50mä»¥å†…ã«ç«¶åˆè–¬å±€ï¼ˆæ—¢å­˜é–€å‰è–¬å±€ï¼‰ãŒã‚ã‚‹ã‹æ¤œå‡º
              [B] ã‚ã‚Œã°: å‡¦æ–¹ç®‹ã® GATE_PHARMACY_CAPTURE_RATE(70%) ãŒé–€å‰è–¬å±€ã«æµã‚Œã‚‹
                  æ®‹ã‚Š30% ã‚’å½“è–¬å±€ã¨éé–€å‰ç«¶åˆã§HuffæŒ‰åˆ†
              [C] ãªã‘ã‚Œã°: è·é›¢å¸¯åˆ¥ãƒ™ãƒ¼ã‚¹ Ã— HuffæŒ‰åˆ†ï¼ˆæ—§æ¥é€šã‚Šï¼‰

        â–  æ•°å€¤æ ¹æ‹ ï¼ˆGATE_PHARMACY_CAPTURE_RATE = 70%ï¼‰:
          æ—¥æœ¬ã®é–€å‰è–¬å±€ã‚·ã‚§ã‚¢å®Ÿæ…‹ï¼ˆæ¥­ç•Œèª¿æŸ»ãƒ»åšåŠ´çœï¼‰: å¯¾è±¡æ–½è¨­ã®å‡¦æ–¹ç®‹ã®60ã€œ80%ã€‚
          å˜ç§‘ã‚¯ãƒªãƒ‹ãƒƒã‚¯ã®é–€å‰è–¬å±€ã¯70ã€œ85%ãŒä¸€èˆ¬çš„ã€‚
          ä¸­å¤®å€¤ã¨ã—ã¦70%ã‚’æ¡ç”¨ï¼ˆå®šæ•° GATE_PHARMACY_CAPTURE_RATE ã§èª¿æ•´å¯èƒ½ï¼‰ã€‚

        â–  æ•°å€¤ä¾‹ï¼ˆæ•´åˆæ€§ç¢ºèªï¼‰:
          ã‚¯ãƒªãƒ‹ãƒƒã‚¯100äºº/æ—¥ãƒ»60Rx/æ—¥ã€æ—¢å­˜é–€å‰è–¬å±€(40m)ã€å½“è–¬å±€(150m)ã€ç«¶åˆ1ä»¶(200m)
            é–€å‰è–¬å±€ãŒ70%æ•æ‰ â†’ æ®‹30%(18Rx/æ—¥)ã‚’éé–€å‰ã§æŒ‰åˆ†
            å½“è–¬å±€Huffæ¯”: (1/150) / (1/150 + 1/200) = 57%
            å½“è–¬å±€ã‚·ã‚§ã‚¢: 30% Ã— 57% â‰’ 17%  â†’ 18Rx/æ—¥ Ã— 305æ—¥ â‰’ 5,500æš/å¹´
          â† å½“è–¬å±€14,305æš/å¹´å…¨å›½å¹³å‡ã®ã†ã¡ä¸€æ–½è¨­åˆ†ã¨ã—ã¦å¦¥å½“ãªæ°´æº–
        """
        dist = OverpassSearcher._haversine(fac.lat, fac.lon, ph_lat, ph_lon)

        # â”€â”€ [A] æ—¢å­˜é–€å‰è–¬å±€ãƒã‚§ãƒƒã‚¯: åŒ»ç™‚æ©Ÿé–¢ã‹ã‚‰50mä»¥å†…ã«ç«¶åˆè–¬å±€ãŒã‚ã‚‹ã‹ â”€â”€
        gate_comps = [
            p for p in competitors
            if OverpassSearcher._haversine(fac.lat, fac.lon, p.lat, p.lon) <= 50
        ]

        if gate_comps:
            # â”€â”€ [B] æ—¢å­˜é–€å‰è–¬å±€ã‚ã‚Š: æ®‹ä½™ã‚·ã‚§ã‚¢ãƒ¢ãƒ‡ãƒ« â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # è¤‡æ•°ã®é–€å‰è–¬å±€ãŒã‚ã‚‹å ´åˆã¯æ•æ‰ç‡ã‚’åŠ ç®—ï¼ˆæœ€å¤§85%ï¼‰
            gate_capture = min(
                GATE_PHARMACY_CAPTURE_RATE + (len(gate_comps) - 1) * 0.05,
                0.85,
            )
            available = 1.0 - gate_capture   # æ®‹ä½™ã‚·ã‚§ã‚¢ï¼ˆå½“è–¬å±€+éé–€å‰ç«¶åˆã§åˆ†é…ï¼‰

            # éé–€å‰ç«¶åˆè–¬å±€ã®ã¿ã‚’å¯¾è±¡ã«HuffæŒ‰åˆ†ï¼ˆ300mä»¥å†…ï¼‰
            non_gate_ids = {id(p) for p in gate_comps}
            non_gate_comps = [
                p for p in competitors
                if id(p) not in non_gate_ids
                and OverpassSearcher._haversine(fac.lat, fac.lon, p.lat, p.lon) <= 300
            ]
            tw = 1.0 / max(dist, 10)
            cws = [
                1.0 / max(OverpassSearcher._haversine(fac.lat, fac.lon, p.lat, p.lon), 10)
                for p in non_gate_comps
            ]
            # Huffæ¯”: ç«¶åˆãŒã„ãªã‘ã‚Œã°æ®‹ä½™ã®100%ã‚’å–å¾—
            huff_ratio = tw / (tw + sum(cws)) if cws else 1.0
            adj = available * huff_ratio

            gate_names = "ãƒ»".join(g.name[:10] for g in gate_comps[:2])
            comp_note = f"ï¼ˆéé–€å‰ç«¶åˆ{len(non_gate_comps)}ä»¶ã§HuffæŒ‰åˆ†ï¼‰" if non_gate_comps else "ï¼ˆéé–€å‰ç«¶åˆãªã—ï¼‰"
            reason = (
                f"æ—¢å­˜é–€å‰è–¬å±€ã‚ã‚Šï¼ˆ{gate_names} ç­‰{len(gate_comps)}ä»¶: æ¨å®š{gate_capture:.0%}æ•æ‰ï¼‰"
                f" â†’ æ®‹{available:.0%}ã‚’{comp_note}"
            )
        else:
            # â”€â”€ [C] æ—¢å­˜é–€å‰è–¬å±€ãªã—: è·é›¢å¸¯åˆ¥ãƒ™ãƒ¼ã‚¹ Ã— HuffæŒ‰åˆ† â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if dist <= 50:
                base, reason = 0.75, "50mä»¥å†…ï¼ˆå®Ÿè³ªé–€å‰ï¼‰"
            elif dist <= 150:
                base, reason = 0.50, "150mä»¥å†…ï¼ˆè¿‘æ¥ç«‹åœ°ï¼‰"
            elif dist <= 300:
                base, reason = 0.30, "300mä»¥å†…ï¼ˆå¾’æ­©åœï¼‰"
            else:
                base, reason = 0.15, "300mè¶…ï¼ˆè‡ªè»¢è»Šåœï¼‰"

            near_comps = [
                p for p in competitors
                if OverpassSearcher._haversine(fac.lat, fac.lon, p.lat, p.lon) < 300
            ]
            if near_comps:
                tw = 1.0 / max(dist, 10)
                cws = [
                    1.0 / max(OverpassSearcher._haversine(fac.lat, fac.lon, p.lat, p.lon), 10)
                    for p in near_comps
                ]
                adj = base * (tw / (tw + sum(cws)))
                reason += f"ï¼ˆç«¶åˆ{len(near_comps)}ä»¶ã§æŒ‰åˆ†ï¼‰"
            else:
                adj = base
                reason += "ï¼ˆè¿‘éš£ç«¶åˆãªã—ï¼‰"

        return min(adj, 0.90), reason


# ---------------------------------------------------------------------------
# 6. æ–¹æ³•â‘¡ å•†åœäººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
# ---------------------------------------------------------------------------

class Method2Predictor:
    def predict(
        self,
        pharmacy_lat: float,
        pharmacy_lon: float,
        competing_pharmacies: List[NearbyFacility],
        area_density: int,
        radius_m: int,
        density_source: str = "",
        radius_reason: str = "",
        nearby_medical: Optional[List[NearbyFacility]] = None,  # v3.2: é–€å‰çš„ç«¶åˆåˆ¤å®šç”¨
    ) -> PredictionResult:
        area_km2 = math.pi * (radius_m / 1000) ** 2
        total_pop = int(area_km2 * area_density)

        # v4.2: äººå£å¯†åº¦å¸¯åˆ¥å¹´é½¢åˆ†å¸ƒãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ç”¨ï¼ˆéƒ½å¸‚éƒ¨ã¯è‹¥å¹´å¤šã‚ã€è¾²æ‘éƒ¨ã¯é«˜é½¢å¤šã‚ï¼‰
        density_band_label = _density_band(area_density)
        age_dist = DENSITY_AGE_DISTRIBUTION.get(density_band_label, AGE_DISTRIBUTION)
        age_breakdown, total_rx = [], 0
        for age_grp, ratio in age_dist.items():
            pop = int(total_pop * ratio)
            v_rate = VISIT_RATE_BY_AGE[age_grp]
            annual_rx = int(pop * v_rate * NATIONAL_STATS["prescription_per_visit"]
                           * NATIONAL_STATS["outpatient_rx_rate"])
            age_breakdown.append({
                "å¹´é½¢å±¤": age_grp,
                "æ¨è¨ˆäººå£": f"{pop:,}äºº",
                "å—è¨ºç‡": f"{v_rate}å›/å¹´",
                "å¹´é–“å—è¨ºå›æ•°": f"{pop * v_rate:,.0f}å›",
                "å¹´é–“å‡¦æ–¹ç®‹æ•°": f"{annual_rx:,}æš",
            })
            total_rx += annual_rx
        share, share_reason = self._market_share(
            pharmacy_lat, pharmacy_lon, competing_pharmacies, nearby_medical
        )
        inflow_coeff, inflow_reason = self._inflow_coefficient(area_density)
        effective_rx = int(total_rx * inflow_coeff)   # æµå…¥è£œæ­£å¾Œã®å®ŸåŠ¹å‡¦æ–¹ç®‹ãƒ—ãƒ¼ãƒ«
        annual_est = int(effective_rx * share)

        # åŠ é‡å¹³å‡å—è¨ºç‡ï¼ˆå¯†åº¦å¸¯è£œæ­£å¾Œï¼‰
        avg_visit_rate = sum(
            age_dist[ag] * VISIT_RATE_BY_AGE[ag] for ag in age_dist
        )
        # 65æ­³ä»¥ä¸Šã®å‰²åˆï¼ˆè¡¨ç¤ºç”¨ï¼‰
        elderly_ratio = age_dist.get("65-74æ­³", 0) + age_dist.get("75æ­³ä»¥ä¸Š", 0)

        methodology = [
            "### æ–¹æ³•â‘¡ï¼ˆå•†åœäººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰ãƒ­ã‚¸ãƒƒã‚¯",
            "",
            "**ç®—å‡ºå¼ï¼ˆv4.2ï¼‰**: å•†åœäººå£ Ã— å¯†åº¦å¸¯åˆ¥å¹´é½¢åˆ†å¸ƒ Ã— å¹´é½¢å±¤åˆ¥å—è¨ºç‡ Ã— å‡¦æ–¹ç®‹ç™ºè¡Œç‡(69%)",
            "Ã— é™¢å¤–å‡¦æ–¹ç‡(79.0%) Ã— **å‡¦æ–¹ç®‹æµå…¥ä¿‚æ•°** Ã— å½“è–¬å±€å¸‚å ´ã‚·ã‚§ã‚¢",
            f"**v4.2æ”¹å–„**: å¯†åº¦å¸¯`{density_band_label}`ã®å¹´é½¢åˆ†å¸ƒã‚’é©ç”¨ï¼ˆ65æ­³ä»¥ä¸Š: {elderly_ratio:.1%}ï¼‰",
            "æ—§: å…¨å›½å›ºå®šå€¤ï¼ˆ65æ­³ä»¥ä¸Š28.3%ï¼‰â†’ æ–°: éƒ½å¸‚éƒ¨20%ã€œè¾²æ‘éƒ¨38%",
            "",
            f"**å•†åœè¨­å®š**: åŠå¾„{radius_m}mï¼ˆé¢ç©: {area_km2:.2f}kmÂ²ï¼‰",
            f"**æ ¹æ‹ **: {radius_reason}" if radius_reason else "",
            f"**äººå£å¯†åº¦**: {area_density:,}äºº/kmÂ²ï¼ˆ{density_source}ï¼‰",
            f"**æ¨è¨ˆå•†åœäººå£**: {total_pop:,}äºº",
            f"**åŠ é‡å¹³å‡å—è¨ºç‡**: {avg_visit_rate:.2f}å›/äºº/å¹´ "
            f"ï¼ˆæ‚£è€…èª¿æŸ»2020å¹´ å¤–æ¥å—ç™‚ç‡Ã—365æ—¥ / OECDæ—¥æœ¬: 12.6å›/å¹´ã¨æ•´åˆï¼‰",
            "",
            f"**å•†åœå±…ä½äººå£ç”±æ¥ã®å¹´é–“å‡¦æ–¹ç®‹**: {total_rx:,}æš",
            f"**å‡¦æ–¹ç®‹æµå…¥ä¿‚æ•°**: Ã—{inflow_coeff:.2f}ï¼ˆ{inflow_reason}ï¼‰",
            f"**å®ŸåŠ¹å‡¦æ–¹ç®‹ãƒ—ãƒ¼ãƒ«ï¼ˆæµå…¥è£œæ­£å¾Œï¼‰**: {effective_rx:,}æš",
            f"**å½“è–¬å±€æ¨è¨ˆå¸‚å ´ã‚·ã‚§ã‚¢**: {share:.1%}ï¼ˆ{share_reason}ï¼‰",
            f"**æ¨è¨ˆå¹´é–“å‡¦æ–¹ç®‹æšæ•°**: **{annual_est:,}æš/å¹´**",
            "",
            "**å‡¦æ–¹ç®‹æµå…¥ä¿‚æ•°ã«ã¤ã„ã¦ï¼ˆv3.2è¿½åŠ ï¼‰**: å•†åœå±…ä½äººå£ã ã‘ã§ã¯æ‰ãˆã‚‰ã‚Œãªã„",
            "æµå…¥å‡¦æ–¹ç®‹ï¼ˆè¿‘éš£åŒ»ç™‚æ©Ÿé–¢é€šé™¢æ‚£è€…ãƒ»æ˜¼é–“äººå£ç­‰ï¼‰ã‚’å¯†åº¦å¸¯åˆ¥ã«è£œæ­£ã€‚",
            f"MHLWå…¨å›½ä¸­å¤®å€¤(8,000æš/å¹´)ãƒ»å¹³å‡(14,305æš/å¹´)ã¨ã®æ•´åˆæ€§æ¤œè¨¼æ¸ˆã¿ã€‚",
            "",
            "**å¸‚å ´ã‚·ã‚§ã‚¢ã®è¨ˆç®—æ–¹æ³•ï¼ˆv3.2æ”¹å–„ï¼‰**: è·é›¢å¸¯åˆ¥å®ŸåŠ¹ç«¶åˆæ•°ãƒ¢ãƒ‡ãƒ«ï¼ˆé–€å‰çš„ç«¶åˆã‚’å¼·åŒ–ï¼‰",
            "åŸºæœ¬é‡ã¿: ç«¶åˆâ‰¤200mÃ—1.5 + ç«¶åˆâ‰¤500mÃ—1.0 + ç«¶åˆ>500mÃ—0.5 = å®ŸåŠ¹ç«¶åˆæ•°N",
            "v3.2è¿½åŠ : åŒ»ç™‚æ©Ÿé–¢100mä»¥å†…ã®ç«¶åˆè–¬å±€ï¼ˆé–€å‰çš„ç«¶åˆï¼‰ã¯åŸºæœ¬é‡ã¿Ã—(5/3)ã§å¼·åŒ–è¨ˆç®—",
            "ã‚·ã‚§ã‚¢ = 1/(N+1)ã€€ä¸Šé™80%ï¼ˆç«¶åˆã‚¼ãƒ­é–€å‰ï¼‰ / ä¸‹é™8%",
        ]
        return PredictionResult(
            method_name="æ–¹æ³•â‘¡: å•†åœäººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ",
            annual_rx=annual_est,
            min_val=int(annual_est * 0.55),
            max_val=int(annual_est * 1.80),
            confidence="low",
            daily_rx=int(annual_est / NATIONAL_STATS["working_days"]),
            breakdown=age_breakdown,
            methodology=methodology,
            references=[
                {"name": "åšç”ŸåŠ´åƒçœã€Œæ‚£è€…èª¿æŸ»ã€2020å¹´",
                 "desc": "å¹´é½¢å±¤åˆ¥å¤–æ¥å—è¨ºç‡ï¼ˆå¤–æ¥å—ç™‚ç‡Ã—365æ—¥ã§å¹´é–“å—è¨ºå›æ•°ã‚’å°å‡ºï¼‰",
                 "url": "https://www.mhlw.go.jp/toukei/saikin/hw/kanja/20/index.html"},
                {"name": "OECD Health Statistics 2022 (Japan)",
                 "desc": "æ—¥æœ¬ã®å¤–æ¥å—è¨ºå›æ•°: ç´„12.6å›/äºº/å¹´ â€” æœ¬ãƒ„ãƒ¼ãƒ«ã®åŠ é‡å¹³å‡å€¤ã¨æ•´åˆ",
                 "url": "https://www.oecd.org/health/health-statistics.htm"},
                {"name": "ç·å‹™çœã€Œå›½å‹¢èª¿æŸ»ã€2020å¹´",
                 "desc": "å¹´é½¢åˆ¥äººå£åˆ†å¸ƒãƒ»åœ°åŒºåˆ¥äººå£å¯†åº¦",
                 "url": "https://www.stat.go.jp/data/kokusei/2020/"},
            ],
        )

    def _market_share(
        self,
        lat: float,
        lon: float,
        competitors: List[NearbyFacility],
        nearby_medical: Optional[List[NearbyFacility]] = None,
    ) -> Tuple[float, str]:
        """
        è·é›¢å¸¯åˆ¥ã€Œå®ŸåŠ¹ç«¶åˆæ•°ãƒ¢ãƒ‡ãƒ«ã€ã«ã‚ˆã‚‹å¸‚å ´ã‚·ã‚§ã‚¢æ¨è¨ˆ (v3.2æ”¹å–„)

        v2.3 ä¿®æ­£: è·é›¢å¸¯åˆ¥ã«ç«¶åˆã‚’ã€Œå®ŸåŠ¹ç«¶åˆæ•°ã€ã«æ›ç®—ã—ã¦ Huffå‹ã‚·ã‚§ã‚¢ã‚’è¨ˆç®—ã€‚
            â‰¤200m ï¼ˆè¿‘æ¥ï¼‰: é‡ã¿ 1.5
            â‰¤500m ï¼ˆä¸­è·é›¢ï¼‰: é‡ã¿ 1.0
            >500m ï¼ˆé è·é›¢ï¼‰: é‡ã¿ 0.5

        v3.2 è¿½åŠ : ã€Œé–€å‰çš„ç«¶åˆã€ï¼ˆåŒ»ç™‚æ©Ÿé–¢ã‹ã‚‰100mä»¥å†…ã«ä½ç½®ã™ã‚‹ç«¶åˆè–¬å±€ï¼‰ã¯
            å®ŸåŠ¹ç«¶åˆæ•°ã®é‡ã¿ã‚’ Ã—1.5â†’Ã—2.5 ã«å¼·åŒ–ã€‚
            é–€å‰è–¬å±€ã¯ãã®åŒ»ç™‚æ©Ÿé–¢ã®å‡¦æ–¹ç®‹ã‚’ç‹¬å çš„ã«é›†ã‚ã‚‹ãŸã‚ã€
            å®Ÿéš›ã®ç«¶åˆåŠ›ã¯è·é›¢ã ã‘ã®è©•ä¾¡ã‚ˆã‚Šå¤§ãã„ã€‚

            ã‚·ã‚§ã‚¢ = 1 / (å®ŸåŠ¹ç«¶åˆæ•° + 1)
            ä¸Šé™: 80% ï¼ˆç«¶åˆã‚¼ãƒ­é–€å‰ã€‚æ®‹20%ã¯å•†åœå¤–æµå‡ºãƒ»ä»–ã‚¨ãƒªã‚¢å—è¨ºã¨ã—ã¦æ§é™¤ï¼‰
            ä¸‹é™:  8% ï¼ˆæ¥µã‚ã¦ç«¶åˆãŒå¤šã„å ´åˆã§ã‚‚æœ€ä½é™ã‚’ç¢ºä¿ï¼‰
        """
        if not competitors:
            return 0.80, "å•†åœå†…ç«¶åˆãªã—ï¼ˆä¸Šé™80%: é–€å‰ç‹¬å ã€‚æ®‹20%ã¯å•†åœå¤–æµå‡ºãƒ»ä»–ã‚¨ãƒªã‚¢å—è¨ºã‚’è€ƒæ…®ï¼‰"

        # é–€å‰çš„ç«¶åˆã®ç‰¹å®š: åŒ»ç™‚æ©Ÿé–¢ã‹ã‚‰100mä»¥å†…ã«ã„ã‚‹ç«¶åˆè–¬å±€
        gate_comp_names: set = set()
        if nearby_medical:
            for med in nearby_medical:
                for p in competitors:
                    if OverpassSearcher._haversine(med.lat, med.lon, p.lat, p.lon) <= 100:
                        gate_comp_names.add(p.name)

        # å®ŸåŠ¹ç«¶åˆæ•°ã®è¨ˆç®—ï¼ˆé–€å‰çš„ç«¶åˆã¯é‡ã¿ã‚’å¼·åŒ–ï¼‰
        effective_n = 0.0
        near_count = medium_count = distant_count = 0
        gate_count = 0
        for p in competitors:
            d = p.distance_m
            is_gate_comp = p.name in gate_comp_names
            # åŸºæœ¬é‡ã¿ï¼ˆè·é›¢å¸¯åˆ¥ï¼‰
            if d <= 200:
                w = 1.5
                near_count += 1
            elif d <= 500:
                w = 1.0
                medium_count += 1
            else:
                w = 0.5
                distant_count += 1
            # é–€å‰çš„ç«¶åˆã¯é‡ã¿ã‚’ Ã—(5/3) â‰ˆ 1.67 å€ â†’ è¿‘æ¥1.5â†’2.5ã€ä¸­è·é›¢1.0â†’1.67
            if is_gate_comp:
                w *= (5.0 / 3.0)
                gate_count += 1
            effective_n += w

        # Huffå‹ã‚·ã‚§ã‚¢: è‡ªç¤¾1 / (è‡ªç¤¾1 + ç«¶åˆ effective_n)
        raw_share = 1.0 / (effective_n + 1.0)

        # ä¸Šé™80% / ä¸‹é™8% ã§ã‚¯ãƒªãƒƒãƒ—
        share = max(min(raw_share, 0.80), 0.08)

        gate_note = f" ã†ã¡é–€å‰çš„ç«¶åˆ{gate_count}ä»¶ï¼ˆé‡ã¿Ã—5/3ï¼‰" if gate_count else ""
        detail = (
            f"è¿‘æ¥â‰¤200m: {near_count}ä»¶Ã—1.5 + ä¸­è·é›¢â‰¤500m: {medium_count}ä»¶Ã—1.0 "
            f"+ é è·é›¢>500m: {distant_count}ä»¶Ã—0.5{gate_note} = å®ŸåŠ¹{effective_n:.1f}ä»¶"
        )
        reason = f"ç«¶åˆ{len(competitors)}ä»¶ ({detail}) â†’ ã‚·ã‚§ã‚¢{share:.1%}"
        return share, reason

    @staticmethod
    def _inflow_coefficient(density: int) -> Tuple[float, str]:
        """
        å‡¦æ–¹ç®‹æµå…¥ä¿‚æ•°ï¼ˆv3.2æ–°è¦ï¼‰: å•†åœå±…ä½äººå£ã‹ã‚‰ç®—å‡ºã—ãŸå‡¦æ–¹ç®‹ç·æ•°ã«å¯¾ã™ã‚‹è£œæ­£ä¿‚æ•°ã€‚

        â–  èƒŒæ™¯
          Method 2 ã¯ã€Œå•†åœå†…å±…ä½è€…ãŒç”Ÿã‚€å‡¦æ–¹ç®‹ã€ã‚’ç®—å‡ºã™ã‚‹ãŒã€
          å®Ÿéš›ã®è–¬å±€ãŒå—ã‘å–ã‚‹å‡¦æ–¹ç®‹ã«ã¯ãã‚Œä»¥å¤–ã®æµå…¥åˆ†ãŒå«ã¾ã‚Œã‚‹ã€‚

          ã€æµå…¥è¦å› ã€‘
            â‘  è¿‘éš£ã®åŒ»ç™‚æ©Ÿé–¢ã«å•†åœå¤–ã‹ã‚‰é€šé™¢ã™ã‚‹æ‚£è€…ãŒå¸°å®…é€”ä¸­ã«ç«‹ã¡å¯„ã‚‹
            â‘¡ æ˜¼é–“äººå£ï¼ˆé€šå‹¤è€…ãƒ»æ¥è¡—è€…ï¼‰ãŒè·å ´/å¤–å‡ºå…ˆã§å—ã‘å–ã£ãŸå‡¦æ–¹ç®‹ã‚’æŒå‚
            â‘¢ å—ç™‚åœãŒåºƒã„åœ°æ–¹éƒ½å¸‚ã§æ‚£è€…ãŒé æ–¹ã‹ã‚‰æ¥é™¢
          ã€æµå‡ºè¦å› ã€‘
            â‘£ å•†åœå†…å±…ä½è€…ã®ä¸€éƒ¨ãŒè·å ´è¿‘ãã®è–¬å±€ã‚’åˆ©ç”¨

          ãƒãƒƒãƒˆåŠ¹æœï¼ˆæµå…¥ - æµå‡ºï¼‰ã¯éƒ½å¸‚éƒ¨ã»ã©å¤§ãã„ï¼ˆå¤§ç—…é™¢ãƒ»ã‚ªãƒ•ã‚£ã‚¹é›†ç©åœ°ï¼‰ã€‚

        â–  æ ¡æ­£æ ¹æ‹ 
          åšç”ŸåŠ´åƒçœã€Œèª¿å‰¤åŒ»ç™‚è²»ã®å‹•å‘ã€2022å¹´åº¦ï¼ˆå…¨å›½å¹³å‡14,305æš/å¹´ãƒ»ä¸­å¤®å€¤8,000æš/å¹´ï¼‰
          ã¨ä»£è¡¨çš„ã‚·ãƒŠãƒªã‚ªã®æ¨è¨ˆå€¤ãŒè¿‘ä¼¼ã™ã‚‹ã‚ˆã†å¯†åº¦å¸¯åˆ¥ã«è¨­å®šã€‚

          ç«¶åˆ3ä»¶ï¼ˆå®ŸåŠ¹N=4.0ã€ã‚·ã‚§ã‚¢20%ï¼‰ã§ã®æ ¡æ­£ä¾‹:
            é«˜å¯†åº¦éƒ½å¸‚(16,000/kmÂ²): 30,470 Ã— 1.60 Ã— 20% â‰’  9,750æš/å¹´  â† éƒ½å¸‚ä¸­å¤®å€¤åœ
            éƒ½å¸‚éƒŠå¤–(8,000/kmÂ²):   27,081 Ã— 1.40 Ã— 20% â‰’  7,582æš/å¹´  â‰ˆ å…¨å›½ä¸­å¤®å€¤
            ä¸­å¯†åº¦éƒŠå¤–(4,000/kmÂ²): 21,165 Ã— 1.25 Ã— 20% â‰’  5,291æš/å¹´  â† ç«¶åˆ3ä»¶ã§ã¯ä½ã‚
            â€» ç«¶åˆ2ä»¶(N=2.5, ã‚·ã‚§ã‚¢28.6%)ãªã‚‰: 21,165Ã—1.25Ã—28.6%â‰’7,565æš/å¹´ â‰ˆ ä¸­å¤®å€¤
        """
        if density >= 10_000:
            return 1.60, "å¤§éƒ½å¸‚ä¸­å¿ƒéƒ¨ï¼ˆæ˜¼é–“äººå£ãƒ»å¤§ç—…é™¢é›†ç©ã«ã‚ˆã‚‹æµå…¥ãŒå¤§ï¼‰"
        elif density >= 5_000:
            return 1.40, "éƒ½å¸‚éƒŠå¤–ï¼ˆä½å®…ãƒ»å•†æ¥­ãƒ»åŒ»ç™‚ã®æ··åœ¨ã«ã‚ˆã‚‹æµå…¥ï¼‰"
        elif density >= 2_000:
            return 1.25, "ä¸­å¯†åº¦ä½å®…åœ°ï¼ˆè¿‘éš£ã‹ã‚‰ã®å—ç™‚åœæµå…¥ï¼‰"
        elif density >= 500:
            return 1.12, "åœ°æ–¹éƒ½å¸‚ï¼ˆå—ç™‚åœãŒåºƒãæµå…¥ã¯ä¸­ç¨‹åº¦ï¼‰"
        else:
            return 1.05, "è¾²æ‘éƒ¨ï¼ˆå—ç™‚åœã¯åŸºæœ¬çš„ã«åœ°åŸŸå†…å®Œçµï¼‰"


# ---------------------------------------------------------------------------
# 7. ãƒãƒƒãƒ—ç”Ÿæˆ
# ---------------------------------------------------------------------------

def build_competitor_map(
    pharmacy_name: str,
    pharmacy_lat: float,
    pharmacy_lon: float,
    medical_facilities: List[NearbyFacility],
    competing_pharmacies: List[NearbyFacility],
    radius_m: int = 500,
    geocoder_source: str = "",
) -> folium.Map:
    """æ—¢å­˜è–¬å±€åˆ†æãƒ¢ãƒ¼ãƒ‰ç”¨ãƒãƒƒãƒ—"""
    gmap_url = f"https://www.google.com/maps/search/?api=1&query={pharmacy_lat},{pharmacy_lon}"
    m = folium.Map(location=[pharmacy_lat, pharmacy_lon], zoom_start=16)
    folium.Circle(
        location=[pharmacy_lat, pharmacy_lon], radius=radius_m,
        color="#FF4444", fill=True, fill_opacity=0.05, weight=2,
        popup=f"å•†åœåŠå¾„ {radius_m}m",
    ).add_to(m)
    folium.Marker(
        location=[pharmacy_lat, pharmacy_lon],
        popup=folium.Popup(
            f"<b>ğŸ’Š {pharmacy_name}</b><br>ã€åˆ†æå¯¾è±¡è–¬å±€ã€‘<br>"
            f"<small>åº§æ¨™ã‚½ãƒ¼ã‚¹: {geocoder_source}</small><br>"
            f'<a href="{gmap_url}" target="_blank">Googleãƒãƒƒãƒ—ã§ç¢ºèª</a>',
            max_width=250
        ),
        tooltip=f"ğŸ’Š {pharmacy_name}",
        icon=folium.Icon(color="red", icon="plus-sign", prefix="glyphicon"),
    ).add_to(m)
    for fac in medical_facilities:
        # v2.6: sourceåˆ¥ã«è‰²åˆ†ã‘
        if getattr(fac, "source", "osm") == "mhlw":
            color, icon_n = "purple", "certificate"
            label = "ğŸŸ£ [MHLWè£œå¡«]"
        elif fac.is_manual:
            color, icon_n = "orange", "asterisk"
            label = "ğŸŸ  [æ‰‹å‹•è¿½åŠ ]"
        elif fac.facility_type == "hospital":
            color, icon_n = "blue", "h-sign"
            label = "ğŸ¥ ç—…é™¢"
        else:
            color, icon_n = "cadetblue", "user-md"
            label = "ğŸ¨ ã‚¯ãƒªãƒ‹ãƒƒã‚¯"
        inhouse = "ï¼ˆé™¢å†…è–¬å±€ã‚ã‚Šï¼‰" if fac.has_inhouse_pharmacy else ""
        src = getattr(fac, "source", "osm")
        source_note = {
            "mhlw":   "<br><b style='color:#8e44ad'>â€» MHLWè‡ªå‹•è£œå¡«ï¼ˆOSMæœªåéŒ²ï¼‰</b>",
            "manual": "<br><b style='color:#e67e00'>â€» æ‰‹å‹•è¿½åŠ æ–½è¨­ï¼ˆOSMæœªåéŒ²ï¼‰</b>",
        }.get(src, "")
        popup_html = (
            f"<b>{label} {fac.name}</b>{inhouse}{source_note}<br>"
            f"è¨ºç™‚ç§‘: {fac.specialty}<br>"
            f"è·é›¢: {fac.distance_m:.0f}m | å¤–æ¥(æ¨è¨ˆ): {fac.daily_outpatients}äºº/æ—¥"
        )
        if fac.mhlw_annual_outpatients:
            popup_html += f"<br>MHLWå¹´é–“å¤–æ¥: {fac.mhlw_annual_outpatients:,}äºº"
        folium.Marker(
            location=[fac.lat, fac.lon],
            popup=folium.Popup(popup_html, max_width=260),
            tooltip=f"{label} {fac.name} ({fac.distance_m:.0f}m)",
            icon=folium.Icon(color=color, icon=icon_n, prefix="glyphicon"),
        ).add_to(m)
        folium.PolyLine(
            [[fac.lat, fac.lon], [pharmacy_lat, pharmacy_lon]],
            color=color, weight=1.5, opacity=0.5,
        ).add_to(m)
    for ph in competing_pharmacies:
        is_chain = any(c in ph.name for c in MAJOR_CHAINS)
        rx_text = (f"<b style='color:#c00'>å‡¦æ–¹ç®‹: {ph.mhlw_annual_outpatients:,}æš/å¹´</b>"
                   if ph.mhlw_annual_outpatients else "MHLW: ãƒ‡ãƒ¼ã‚¿ãªã—")
        popup_html = (
            f"<b>ğŸ’Š {ph.name}</b>{'ï¼ˆå¤§æ‰‹ãƒã‚§ãƒ¼ãƒ³ï¼‰' if is_chain else ''}<br>"
            f"è·é›¢: {ph.distance_m:.0f}m<br>{rx_text}"
        )
        folium.Marker(
            location=[ph.lat, ph.lon],
            popup=folium.Popup(popup_html, max_width=220),
            tooltip=f"ğŸ’Š {ph.name} ({ph.distance_m:.0f}m)",
            icon=folium.Icon(color="green", icon="shopping-cart", prefix="glyphicon"),
        ).add_to(m)
    return m


def build_new_pharmacy_map(
    config: NewPharmacyConfig,
    pharmacy_lat: float,
    pharmacy_lon: float,
    medical_facilities: List[NearbyFacility],
    competing_pharmacies: List[NearbyFacility],
    radius_m: int = 500,
    geocoder_source: str = "",
) -> folium.Map:
    """æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰ç”¨ãƒãƒƒãƒ—ï¼ˆè¿‘éš£è–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ä»˜ãï¼‰"""
    gmap_url = (f"https://www.google.com/maps/search/?api=1&query="
                + urllib.parse.quote(config.address))
    m = folium.Map(location=[pharmacy_lat, pharmacy_lon], zoom_start=16)
    folium.Circle(
        location=[pharmacy_lat, pharmacy_lon], radius=radius_m,
        color="#FF8C00", fill=True, fill_opacity=0.06, weight=2.5,
        popup=f"å•†åœåŠå¾„ {radius_m}mï¼ˆ{config.scenario}ã‚·ãƒŠãƒªã‚ªï¼‰",
    ).add_to(m)
    # é–‹å±€äºˆå®šåœ°
    folium.Marker(
        location=[pharmacy_lat, pharmacy_lon],
        popup=folium.Popup(
            f"<b>ğŸ— {config.pharmacy_name}</b><br>ã€é–‹å±€äºˆå®šåœ°ã€‘<br>"
            f"ä½æ‰€: {config.address}<br>"
            f"<small>åº§æ¨™ã‚½ãƒ¼ã‚¹: {geocoder_source}</small><br>"
            f'<a href="{gmap_url}" target="_blank">Googleãƒãƒƒãƒ—ã§ç¢ºèª</a>',
            max_width=260
        ),
        tooltip=f"ğŸ— {config.pharmacy_name}ï¼ˆé–‹å±€äºˆå®šï¼‰",
        icon=folium.Icon(color="red", icon="star", prefix="glyphicon"),
    ).add_to(m)
    # èª˜è‡´äºˆå®šã‚¯ãƒªãƒ‹ãƒƒã‚¯ï¼ˆé–€å‰è¾¼ã¿ã‚·ãƒŠãƒªã‚ª: combined / gate_only / allï¼‰
    if config.scenario in ("combined", "gate_only", "all"):
        clinic_lat = pharmacy_lat + 0.000225  # ~25måŒ—
        folium.Marker(
            location=[clinic_lat, pharmacy_lon],
            popup=folium.Popup(
                f"<b>ğŸ¥ [èª˜è‡´äºˆå®š] {config.gate_specialty}ã‚¯ãƒªãƒ‹ãƒƒã‚¯</b><br>"
                f"å¤–æ¥: {config.gate_daily_outpatients}äºº/æ—¥ï¼ˆæƒ³å®šï¼‰<br>"
                f"é™¢å†…è–¬å±€: {'ã‚ã‚Š' if config.gate_has_inhouse else 'ãªã—'}",
                max_width=220
            ),
            tooltip=f"[èª˜è‡´äºˆå®š] {config.gate_specialty}ã‚¯ãƒªãƒ‹ãƒƒã‚¯",
            icon=folium.Icon(color="orange", icon="plus-sign", prefix="glyphicon"),
        ).add_to(m)
    # è¿‘éš£åŒ»ç™‚æ–½è¨­
    for fac in medical_facilities:
        color = "blue" if fac.facility_type == "hospital" else "cadetblue"
        icon_n = "h-sign" if fac.facility_type == "hospital" else "user-md"
        label = "ğŸ¥ ç—…é™¢" if fac.facility_type == "hospital" else "ğŸ¨ ã‚¯ãƒªãƒ‹ãƒƒã‚¯"
        popup_html = (
            f"<b>{label} {fac.name}</b><br>"
            f"è¨ºç™‚ç§‘: {fac.specialty}<br>"
            f"è·é›¢: {fac.distance_m:.0f}m | å¤–æ¥(æ¨è¨ˆ): {fac.daily_outpatients}äºº/æ—¥"
        )
        folium.Marker(
            location=[fac.lat, fac.lon],
            popup=folium.Popup(popup_html, max_width=250),
            tooltip=f"{label} {fac.name} ({fac.distance_m:.0f}m)",
            icon=folium.Icon(color=color, icon=icon_n, prefix="glyphicon"),
        ).add_to(m)
        folium.PolyLine(
            [[fac.lat, fac.lon], [pharmacy_lat, pharmacy_lon]],
            color=color, weight=1.5, opacity=0.4,
        ).add_to(m)
    # ç«¶åˆè–¬å±€ï¼ˆå‡¦æ–¹ç®‹æšæ•°ä»˜ãï¼‰
    for ph in competing_pharmacies:
        is_chain = any(c in ph.name for c in MAJOR_CHAINS)
        has_rx = ph.mhlw_annual_outpatients is not None
        rx_text = (
            f"<b style='color:#c00'>å‡¦æ–¹ç®‹: {ph.mhlw_annual_outpatients:,}æš/å¹´</b><br>"
            f"æ—¥æ¬¡æ›ç®—: {ph.mhlw_annual_outpatients // 305}æš/æ—¥"
            if has_rx else "MHLWå‡¦æ–¹ç®‹: æœªå–å¾—"
        )
        marker_color = "darkgreen" if has_rx else "green"
        popup_html = (
            f"<b>ğŸ’Š {ph.name}</b>{'ï¼ˆå¤§æ‰‹ï¼‰' if is_chain else ''}<br>"
            f"è·é›¢: {ph.distance_m:.0f}m<br>{rx_text}"
        )
        folium.Marker(
            location=[ph.lat, ph.lon],
            popup=folium.Popup(popup_html, max_width=240),
            tooltip=f"ğŸ’Š {ph.name} ({ph.distance_m:.0f}m)"
                    + (f" {ph.mhlw_annual_outpatients:,}æš/å¹´" if has_rx else ""),
            icon=folium.Icon(color=marker_color, icon="shopping-cart", prefix="glyphicon"),
        ).add_to(m)
    return m


# ---------------------------------------------------------------------------
# 8. ä¹–é›¢è©•ä¾¡
# ---------------------------------------------------------------------------

def calc_deviation(actual: int, predicted: int) -> Tuple[float, str, str]:
    if actual <= 0:
        return 0.0, "N/A", "neutral"
    pct = (predicted - actual) / actual * 100
    label = f"+{pct:.1f}%" if pct >= 0 else f"{pct:.1f}%"
    color = "normal" if abs(pct) < 20 else ("inverse" if abs(pct) < 50 else "off")
    return pct, label, color


# ---------------------------------------------------------------------------
# 8-b. v2.4: æ‰‹å‹•æ–½è¨­è¿½åŠ ãƒ˜ãƒ«ãƒ‘ãƒ¼
# ---------------------------------------------------------------------------

def calc_implied_missing_facility(actual_rx: int, predicted_rx: int) -> Optional[Dict]:
    """
    æ–¹æ³•â‘ äºˆæ¸¬ã¨ MHLW å®Ÿç¸¾ã®ä¹–é›¢ã‹ã‚‰ã€Œæœªæ¤œå‡ºåŒ»ç™‚æ–½è¨­ã€ã®è¦æ¨¡ã‚’é€†ç®—ã™ã‚‹ã€‚

    ä¹–é›¢ãŒå®Ÿç¸¾ã®20%æœªæº€ã®å ´åˆã¯ã€Œè¨±å®¹ç¯„å›²å†…ã€ã¨ã—ã¦ None ã‚’è¿”ã™ã€‚
    é€†ç®—ã¯ä¸€èˆ¬å†…ç§‘ã®å‡¦æ–¹ç®‹ç™ºè¡Œç‡(0.76)Ã—é™¢å¤–å‡¦æ–¹ç‡(0.790)ã§è¡Œã†ã€‚
    """
    if actual_rx <= 0 or predicted_rx >= actual_rx * 0.8:
        return None
    gap_annual = actual_rx - predicted_rx
    gap_daily  = gap_annual / NATIONAL_STATS["working_days"]
    # ä¸€èˆ¬å†…ç§‘ã§é€†ç®—ï¼ˆæœ€ã‚‚ä¸€èˆ¬çš„ãªæƒ³å®šï¼‰
    rx_rate = SPECIALTY_RX_RATES["ä¸€èˆ¬å†…ç§‘"][0]   # 0.76
    or_rate = NATIONAL_STATS["outpatient_rx_rate"]  # 0.790
    # gap_daily = implied_op Ã— rx_rate Ã— or_rate
    implied_op = int(gap_daily / (rx_rate * or_rate))
    gap_pct    = (actual_rx - predicted_rx) / actual_rx * 100
    return {
        "gap_annual":        gap_annual,
        "gap_daily":         round(gap_daily, 1),
        "implied_outpatients": implied_op,
        "gap_pct":           gap_pct,
    }


def fetch_mhlw_medical_supplement(
    pharmacy_lat: float,
    pharmacy_lon: float,
    pharmacy_address: str,
    pref_code: str,
    existing_osm: List["NearbyFacility"],
    search_radius_m: int,
    progress_bar=None,
    max_candidates: int = 150,
    dedup_threshold_m: float = 80.0,
) -> Tuple[List["NearbyFacility"], List[str]]:
    """
    MHLWã‚¨ãƒªã‚¢æ¤œç´¢ â†’ ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° â†’ OSMé‡è¤‡æ’é™¤ â†’ æ–°è¦NearbyFacilityãƒªã‚¹ãƒˆã‚’è¿”ã™ (v2.6)

    å‡¦ç†ãƒ•ãƒ­ãƒ¼:
      1. MHLWScraper.search_medical_by_area() ã§ã‚¨ãƒªã‚¢å†…ã®åŒ»ç™‚æ©Ÿé–¢ã‚’ä¸€æ‹¬å–å¾—
      2. å„æ–½è¨­ã®ä½æ‰€ã‚’GSIã‚¸ã‚ªã‚³ãƒ¼ãƒ€ãƒ¼ã§åº§æ¨™å¤‰æ›
      3. è–¬å±€ã‹ã‚‰ã®è·é›¢ãŒ search_radius_m ä»¥å†…ã®ã‚‚ã®ã®ã¿ä¿æŒ
      4. OSMæ–½è¨­ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆdedup_threshold_m ä»¥å†… = åŒä¸€æ–½è¨­ã¨ã¿ãªã—ã‚¹ã‚­ãƒƒãƒ—ï¼‰
      5. æ–°è¦æ–½è¨­ã‚’ NearbyFacility (source="mhlw") ã¨ã—ã¦è¿”ã™

    Args:
        progress_bar: st.progress() ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆä»»æ„ï¼‰
        max_candidates: æœ€å¤§å‡¦ç†å€™è£œæ•°ï¼ˆå¤šã™ãã‚‹ã¨æ™‚é–“ãŒã‹ã‹ã‚‹ï¼‰
        dedup_threshold_m: é‡è¤‡ã¨ã¿ãªã™è·é›¢ã—ãã„å€¤[m]

    Returns:
        (new_facilities, log_messages)
    """
    log: List[str] = []
    gc = GeocoderService()
    scraper = MHLWScraper()
    scraper.initialize_session()

    # â”€â”€ Step 1: MHLWã‚¨ãƒªã‚¢æ¤œç´¢ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if progress_bar:
        progress_bar.progress(5, text="MHLWåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ã‚¨ãƒªã‚¢æ¤œç´¢ä¸­â€¦")
    cands, search_msg = scraper.search_medical_by_area(pharmacy_address, pref_code, max_pages=5)
    log.append(f"[MHLWè£œå¡«] {search_msg}")
    if not cands:
        log.append("[MHLWè£œå¡«] å€™è£œãªã—ã€‚è£œå¡«ã‚’çµ‚äº†ã—ã¾ã™ã€‚")
        return [], log
    cands = cands[:max_candidates]
    log.append(f"[MHLWè£œå¡«] å‡¦ç†å¯¾è±¡: {len(cands)}ä»¶")

    # â”€â”€ Step 2: ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° + åŠå¾„ãƒ•ã‚£ãƒ«ã‚¿ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    geocoded: List[Tuple["PharmacyCandidate", float, float, float]] = []
    for i, cand in enumerate(cands):
        if progress_bar:
            pct = 10 + int(i * 70 / len(cands))
            progress_bar.progress(
                pct,
                text=f"ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° [{i+1}/{len(cands)}]: {cand.name[:22]}â€¦",
            )
        if not cand.address:
            continue
        lat, lon, _, _ = gc.geocode(cand.address)
        if lat is None or lon is None:
            continue
        dist = haversine_distance(pharmacy_lat, pharmacy_lon, lat, lon)
        if dist <= search_radius_m:
            geocoded.append((cand, lat, lon, dist))
        time.sleep(0.12)   # GSI APIã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã¸ã®é…æ…®

    log.append(
        f"[MHLWè£œå¡«] ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Œäº†: åŠå¾„{search_radius_m}må†… {len(geocoded)}ä»¶"
    )

    # â”€â”€ Step 3: OSMé‡è¤‡æ’é™¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if progress_bar:
        progress_bar.progress(85, text="OSMãƒ‡ãƒ¼ã‚¿ã¨é‡è¤‡ãƒã‚§ãƒƒã‚¯ä¸­â€¦")

    new_facilities: List["NearbyFacility"] = []
    dup_count = 0
    for cand, lat, lon, dist in geocoded:
        is_dup = any(
            haversine_distance(lat, lon, osm.lat, osm.lon) <= dedup_threshold_m
            for osm in existing_osm
        )
        if is_dup:
            dup_count += 1
            log.append(f"  [é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—] {cand.name} ({dist:.0f}m) â† OSMæ–½è¨­ã¨{dedup_threshold_m:.0f}mä»¥å†…")
            continue

        # æ–½è¨­ã‚¿ã‚¤ãƒ—ãƒ»è¨ºç™‚ç§‘ãƒ»å¤–æ¥æ‚£è€…æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¨å®š
        is_hospital = any(kw in cand.name for kw in ["ç—…é™¢", "åŒ»ç™‚ã‚»ãƒ³ã‚¿ãƒ¼", "åŒ»ç™‚æ©Ÿæ§‹", "åŒ»é™¢"])
        fac_type    = "hospital" if is_hospital else "clinic"
        specialty   = detect_specialty_from_name(cand.name)
        # v4.2: è¨ºç™‚ç§‘åˆ¥å¤–æ¥æ‚£è€…æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ç”¨ï¼ˆMHLWè£œå¡«æ–½è¨­ã«ã‚‚é©ç”¨ï¼‰
        # MHLWã§ãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹ãŒå¤–æ¥æ‚£è€…æ•°ã®è©³ç´°ãŒå–ã‚Œãªã„æ–½è¨­ã¯ã€OSMåéŒ²æ–½è¨­ã¨åŒæ§˜ã«
        # è¨ºç™‚ç§‘åˆ¥åŸºç¤å€¤Ã—0.85 ã§æ¨å®šã€‚ç—…é™¢ã¯å›ºå®š120äºº/æ—¥ã€‚
        if fac_type == "hospital":
            default_op = 120
        else:
            sp_key = specialty if specialty in SPECIALTY_OUTPATIENT_TABLE else "ä¸æ˜/ãã®ä»–"
            sp_d = SPECIALTY_OUTPATIENT_TABLE[sp_key]
            default_op = max(5, int(sp_d["base"] * 0.85))

        new_facilities.append(NearbyFacility(
            name=cand.name,
            facility_type=fac_type,
            lat=lat,
            lon=lon,
            distance_m=int(dist),
            specialty=specialty,
            daily_outpatients=default_op,
            has_inhouse_pharmacy=(fac_type == "hospital"),
            is_manual=True,
            source="mhlw",
        ))

    log.append(
        f"[MHLWè£œå¡«] OSMé‡è¤‡: {dup_count}ä»¶ / æ–°è¦è¿½åŠ : {len(new_facilities)}ä»¶"
    )
    for fac in new_facilities:
        log.append(
            f"  ï¼‹ {fac.name}ï¼ˆè¨ºç™‚ç§‘: {fac.specialty}ã€"
            f"{fac.distance_m}mã€æ¨è¨ˆ{fac.daily_outpatients}äºº/æ—¥ï¼‰"
        )

    if progress_bar:
        progress_bar.progress(100, text="MHLWè£œå¡«å®Œäº†ï¼")

    return new_facilities, log


def make_manual_facility(
    pharmacy_lat: float,
    pharmacy_lon: float,
    name: str,
    specialty: str,
    daily_outpatients: int,
    distance_m: float,
    has_inhouse: bool = False,
) -> NearbyFacility:
    """
    æ‰‹å‹•å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ NearbyFacility ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ã€‚

    lat/lon ã¯ã€Œè–¬å±€ã‹ã‚‰ distance_m åŒ—æ–¹å‘ã€ã¨ã„ã†è¿‘ä¼¼å€¤ã‚’è¨­å®šã™ã‚‹ã€‚
    ï¼ˆ_calc_share ã§ã® haversine è¨ˆç®—ã«ä½¿ã‚ã‚Œã‚‹ãŸã‚ã€å®Ÿéš›ã®ä½ç½®ã¨å¤šå°‘ç•°ãªã£ã¦ã‚‚
    distance_m ã‚’ç›´æ¥å…¥åŠ›ã—ãŸå€¤ã‹ã‚‰ç®—å‡ºã•ã‚ŒãŸã‚‚ã®ã¨æ¦‚ã­åŒã˜çµæœã«ãªã‚‹ï¼‰
    """
    delta_lat = distance_m / 111_000  # 1Â° â‰ˆ 111 km
    return NearbyFacility(
        name=name,
        facility_type="clinic",
        lat=pharmacy_lat + delta_lat,
        lon=pharmacy_lon,
        distance_m=distance_m,
        specialty=specialty,
        daily_outpatients=daily_outpatients,
        has_inhouse_pharmacy=has_inhouse,
        is_manual=True,
    )


def recalculate_with_manual_facilities(analysis: "FullAnalysis") -> None:
    """
    æ‰‹å‹•è¿½åŠ æ–½è¨­ + MHLWè‡ªå‹•è£œå¡«æ–½è¨­ã‚’å«ã‚ã¦æ–¹æ³•â‘ â‘¡ã‚’å†è¨ˆç®—ã—ã€session_state ã‚’æ›´æ–°ã™ã‚‹ã€‚
    MHLWãƒ»OSM ã®å†æ¤œç´¢ã¯è¡Œã‚ãªã„ï¼ˆæ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã‚’å†åˆ©ç”¨ï¼‰ã€‚

    ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹å„ªå…ˆé †ä½:
      1. analysis.nearby_medical â€” åˆå›OSMæ¤œç´¢çµæœï¼ˆä¸å¤‰ï¼‰
      2. session_state["mhlw_supplement"] â€” MHLWè‡ªå‹•è£œå¡«æ–½è¨­ (v2.6)
      3. session_state["manual_facility_params"] â€” ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰‹å‹•è¿½åŠ æ–½è¨­ (v2.4ã€œ)
    """
    # â‘  OSMæ–½è¨­ï¼ˆå…ƒãƒ‡ãƒ¼ã‚¿ï¼‰
    osm_facs = list(analysis.nearby_medical)

    # â‘¡ MHLWè‡ªå‹•è£œå¡«æ–½è¨­ (v2.6)
    mhlw_facs: List[NearbyFacility] = st.session_state.get("mhlw_supplement", [])

    # â‘¢ æ‰‹å‹•è¿½åŠ æ–½è¨­
    params_list: List[Dict] = st.session_state.get("manual_facility_params", [])
    manual_facs: List[NearbyFacility] = [
        make_manual_facility(
            analysis.pharmacy_lat, analysis.pharmacy_lon,
            p["name"], p["specialty"], p["daily_outpatients"],
            p["distance_m"], p["has_inhouse"],
        )
        for p in params_list
    ]

    merged_medical = osm_facs + mhlw_facs + manual_facs

    # ãƒ©ãƒ™ãƒ«ç”Ÿæˆ
    label_parts = [f"OSM {len(osm_facs)}ä»¶"]
    if mhlw_facs:
        label_parts.append(f"MHLWè£œå¡« {len(mhlw_facs)}ä»¶")
    if manual_facs:
        label_parts.append(f"æ‰‹å‹•è¿½åŠ  {len(manual_facs)}ä»¶")
    label = "æ–¹æ³•â‘ : è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ï¼ˆ" + "ï¼‹".join(label_parts) + "ï¼‰"

    m1 = Method1Predictor().predict(
        analysis.pharmacy_lat, analysis.pharmacy_lon,
        merged_medical, analysis.nearby_pharmacies,
        mode_label=label,
    ) if analysis.pharmacy_lat else None

    m2 = Method2Predictor().predict(
        analysis.pharmacy_lat, analysis.pharmacy_lon,
        analysis.nearby_pharmacies,
        analysis.area_density, analysis.commercial_radius,
        density_source=analysis.area_density_source,
        radius_reason=analysis.commercial_radius_reason,
        nearby_medical=merged_medical,  # v3.2: é–€å‰çš„ç«¶åˆåˆ¤å®šç”¨
    )

    updated = dataclasses.replace(analysis, method1=m1, method2=m2)
    st.session_state["analysis"] = updated
    st.rerun()


# ---------------------------------------------------------------------------
# 9. UI ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°
# ---------------------------------------------------------------------------

def render_data_sources_panel() -> None:
    """çµ±è¨ˆæ•°å€¤ã®æ ¹æ‹ ãƒ»ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’è¡¨ç¤ºï¼ˆv2.2æ–°è¦ï¼‰"""
    with st.expander("ğŸ“š çµ±è¨ˆæ•°å€¤ã®æ ¹æ‹ ãƒ»ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ä¸€è¦§ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§å±•é–‹ï¼‰", expanded=False):
        st.markdown("æœ¬ãƒ„ãƒ¼ãƒ«ã§ä½¿ç”¨ã—ã¦ã„ã‚‹çµ±è¨ˆæ•°å€¤ã®å‡ºå…¸ã¨æ ¹æ‹ ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚")
        for stat_name, ref in STAT_REFERENCES.items():
            st.markdown(f"#### {stat_name}")
            col1, col2 = st.columns([1, 2])
            with col1:
                st.metric("å€¤", ref["value"][:40] if len(ref["value"]) > 40 else ref["value"])
            with col2:
                st.markdown(f"**å‡ºå…¸**: {ref['source']}")
                st.markdown(f"**è£œè¶³**: {ref['note']}")
                if ref.get("url"):
                    st.markdown(f"ğŸ”— [{ref['url']}]({ref['url']})")
            st.markdown("---")


def render_auto_params_panel(
    lat: Optional[float],
    lon: Optional[float],
    geocode_display: str,
    geocoder_source: str,
    address: str,
    area_density: int,
    area_density_source: str,
    commercial_radius: int,
    commercial_radius_reason: str,
    is_gate: bool,
    gate_reason: str,
) -> None:
    """åº§æ¨™ãƒ»äººå£å¯†åº¦ãƒ»å•†åœåŠå¾„ã®è‡ªå‹•è¨ˆç®—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¡¨ç¤º"""
    st.markdown("### ğŸ“ è‡ªå‹•è¨ˆç®—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿")
    if lat and lon:
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric(
                f"ğŸŒ å–å¾—åº§æ¨™ ({geocoder_source[:6]})",
                f"{lat:.5f}",
                delta=f"çµŒåº¦: {lon:.5f}", delta_color="off",
                help=f"ã‚¸ã‚ªã‚³ãƒ¼ãƒ€ãƒ¼: {geocoder_source}",
            )
            gmap_url = f"https://www.google.com/maps/search/?api=1&query={lat},{lon}"
            st.markdown(f'<a href="{gmap_url}" target="_blank">ğŸ“ Googleãƒãƒƒãƒ—ã§ç¢ºèª</a>',
                        unsafe_allow_html=True)
        with col2:
            st.metric("ğŸ˜ äººå£å¯†åº¦", f"{area_density:,}äºº/kmÂ²", help=area_density_source)
            st.caption(f"ğŸ“‹ {area_density_source[:40]}")
        with col3:
            gate_icon = "ğŸšª" if is_gate else "ğŸ“"
            st.metric(f"{gate_icon} å•†åœåŠå¾„", f"{commercial_radius}m")
            st.caption(f"ğŸ“ {commercial_radius_reason[:45]}")
        with col4:
            area_km2 = math.pi * (commercial_radius / 1000) ** 2
            catchment_pop = int(area_km2 * area_density)
            st.metric("ğŸ‘¥ æ¨è¨ˆå•†åœäººå£", f"{catchment_pop:,}äºº")
            if is_gate:
                st.caption(f"ğŸšª é–€å‰: {gate_reason[:30]}")
    else:
        st.warning("âš  åº§æ¨™å–å¾—å¤±æ•— â†’ ç©ºé–“åˆ†æã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
        st.info(
            "ğŸ’¡ **ãƒ’ãƒ³ãƒˆ**: å»ºç‰©åãƒ»å·å®¤ã‚’é™¤ã„ãŸã€Œéƒ½é“åºœçœŒ+å¸‚åŒºç”ºæ‘+ä¸ç›®ç•ªåœ°ã€ã®å½¢å¼ã§å†æ¤œç´¢ã™ã‚‹ã¨æ”¹å–„ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚"
        )
        st.metric("ğŸ˜ æ¨è¨ˆäººå£å¯†åº¦ï¼ˆä½æ‰€ã‹ã‚‰ï¼‰", f"{area_density:,}äºº/kmÂ²")
        st.caption(area_density_source)


def render_comparison_banner(analysis: FullAnalysis) -> None:
    st.markdown("## ğŸ“Š äºˆæ¸¬å€¤ vs åšåŠ´çœå®Ÿç¸¾å€¤ æ¯”è¼ƒ")
    actual = analysis.mhlw_annual_rx
    m1, m2 = analysis.method1, analysis.method2
    cal_stats: Optional[CalibrationStats] = st.session_state.get("calibration_stats")

    # v4.1: æ ¡æ­£æ¸ˆã¿äºˆæ¸¬ã‚’è¨ˆç®—
    cal_rx: Optional[int] = None
    cal_note: str = ""
    if cal_stats and m1 and m2:
        cal_rx, cal_note = CalibrationEngine.apply_correction(
            m1.annual_rx, m2.annual_rx, analysis.area_density, cal_stats
        )

    n_cols = 5 if cal_rx is not None else 4
    cols = st.columns(n_cols)

    with cols[0]:
        if actual:
            st.metric("ğŸ¥ MHLWå®Ÿç¸¾å€¤", f"{actual:,} æš/å¹´")
            st.caption("ğŸŸ¢ ä¿¡é ¼åº¦: é«˜ï¼ˆå®Ÿç¸¾å€¤ï¼‰")
        else:
            st.metric("ğŸ¥ MHLWå®Ÿç¸¾å€¤", "è¨˜è¼‰ãªã—")
            st.caption("âš  å½“è©²è–¬å±€ã¯æœªå ±å‘Š")
    with cols[1]:
        if m1:
            st.metric("â‘  åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ", f"{m1.annual_rx:,} æš/å¹´",
                      delta=calc_deviation(actual, m1.annual_rx)[1] if actual else None)
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m1.min_val:,}ã€œ{m1.max_val:,}")
            st.caption("ğŸ“Œ ç²¾åº¦Â±30ã€œ40%")
    with cols[2]:
        if m2:
            st.metric("â‘¡ äººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ", f"{m2.annual_rx:,} æš/å¹´",
                      delta=calc_deviation(actual, m2.annual_rx)[1] if actual else None)
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m2.min_val:,}ã€œ{m2.max_val:,}")
            st.caption("ğŸ“Œ ç²¾åº¦Â±40ã€œ50%")
    with cols[3]:
        if cal_rx is not None:
            st.metric(
                "ğŸ¯ æ ¡æ­£æ¸ˆã¿äºˆæ¸¬ (v4.x)",
                f"{cal_rx:,} æš/å¹´",
                delta=calc_deviation(actual, cal_rx)[1] if actual else None,
            )
            st.caption(f"MAPE={cal_stats.mape_optimal:.1f}% / n={cal_stats.n}")
            with st.expander("æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è©³ç´°"):
                st.caption(cal_note)
        elif m1 and m2:
            # v4.2: å˜ç´”å¹³å‡ â†’ ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ã«å¤‰æ›´
            n_med = len(analysis.nearby_medical) if analysis.nearby_medical else 0
            n_conf = sum(
                1 for f in (analysis.nearby_medical or [])
                if f.mhlw_annual_outpatients is not None
            )
            sw, sw_reason = calc_smart_blend_weight(
                analysis.area_density, n_med, n_conf
            )
            smart_rx = int(sw * m1.annual_rx + (1 - sw) * m2.annual_rx)
            pct, label, _ = calc_deviation(actual, smart_rx)
            st.metric("ğŸ’¡ ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ (v4.2)", f"{smart_rx:,} æš/å¹´",
                      delta=label if actual else None,
                      delta_color="normal" if abs(pct) < 30 else "inverse")
            with st.expander("ãƒ–ãƒ¬ãƒ³ãƒ‰æ ¹æ‹ "):
                st.caption(sw_reason)
            st.caption("ï¼ˆæ ¡æ­£å®Ÿæ–½ã§ğŸ¯æ ¡æ­£æ¸ˆã¿äºˆæ¸¬ã«åˆ‡æ›¿ï¼‰")
    if n_cols == 5:
        with cols[4]:
            if m1 and m2:
                # æ ¡æ­£ã‚ã‚Šæ™‚ã®5åˆ—ç›®: ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ã‚‚è¡¨ç¤º
                n_med = len(analysis.nearby_medical) if analysis.nearby_medical else 0
                n_conf = sum(
                    1 for f in (analysis.nearby_medical or [])
                    if f.mhlw_annual_outpatients is not None
                )
                sw, sw_reason = calc_smart_blend_weight(
                    analysis.area_density, n_med, n_conf
                )
                smart_rx = int(sw * m1.annual_rx + (1 - sw) * m2.annual_rx)
                pct, label, _ = calc_deviation(actual, smart_rx)
                st.metric("ğŸ’¡ ã‚¹ãƒãƒ¼ãƒˆãƒ–ãƒ¬ãƒ³ãƒ‰ (v4.2)", f"{smart_rx:,} æš/å¹´",
                          delta=label if actual else None,
                          delta_color="normal" if abs(pct) < 30 else "inverse")


def render_gap_and_manual_input(analysis: "FullAnalysis") -> None:
    """
    v2.6: ä¹–é›¢è­¦å‘Š + MHLWã‚¨ãƒªã‚¢è‡ªå‹•è£œå¡« + è¿‘éš£æ–½è¨­æ‰‹å‹•è¿½åŠ  + å†è¨ˆç®—ã‚»ã‚¯ã‚·ãƒ§ãƒ³

    ä¹–é›¢ãŒå¤§ãã„å ´åˆã®è£œå®Œæ–¹æ³•:
      1. MHLWè‡ªå‹•è£œå¡« (v2.6æ–°æ©Ÿèƒ½) â† è¦‹è½ã¨ã—ãŒå°‘ãªã„
      2. æ‰‹å‹•è¿½åŠ  (v2.4ã€œ) â† ç‰¹å®šæ–½è¨­ã‚’åå‰ã§æ¤œç´¢ãƒ»è¿½åŠ 
    """
    actual = analysis.mhlw_annual_rx
    m1 = analysis.method1

    implied = calc_implied_missing_facility(actual or 0, m1.annual_rx if m1 else 0)

    # â”€â”€â”€ ä¹–é›¢è­¦å‘Š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if implied:
        st.warning(
            f"âš  **æ–¹æ³•â‘ ã®äºˆæ¸¬ãŒå®Ÿç¸¾å€¤ã‚’å¤§å¹…ã«ä¸‹å›ã£ã¦ã„ã¾ã™ï¼ˆä¹–é›¢: "
            f"{implied['gap_annual']:,}æš/å¹´ / {implied['gap_pct']:.0f}%ï¼‰**\n\n"
            f"ä¹–é›¢ã‹ã‚‰é€†ç®—ã™ã‚‹ã¨ã€**å¤–æ¥ ç´„{implied['implied_outpatients']}äºº/æ—¥** ã®"
            f"ã‚¯ãƒªãƒ‹ãƒƒã‚¯ï¼ˆä¸€èˆ¬å†…ç§‘æƒ³å®šï¼‰ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚\n\n"
            f"MHLWè‡ªå‹•è£œå¡«ã¯åˆ†æå®Ÿè¡Œæ™‚ã«è‡ªå‹•ã§è¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚"
            f"ä¸‹è¨˜ã®è£œå¡«çµæœã‚’ã”ç¢ºèªã„ãŸã ãã€æ–½è¨­ã®æ‰‹å‹•è¿½åŠ ã‚‚å¯èƒ½ã§ã™ã€‚"
        )

    # â”€â”€â”€ v3.1: MHLWè£œå¡«çµæœè¡¨ç¤ºï¼ˆè‡ªå‹•å®Ÿè¡Œæ¸ˆã¿ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    mhlw_facs: List[NearbyFacility] = st.session_state.get("mhlw_supplement", [])

    with st.expander(
        f"ğŸŸ£ MHLWè‡ªå‹•è£œå¡«çµæœ"
        + (f"ï¼ˆâœ… {len(mhlw_facs)}ä»¶ã‚’è£œå¡«æ¸ˆã¿ãƒ»æ–¹æ³•â‘ ã«åæ˜ ï¼‰" if mhlw_facs else "ï¼ˆè£œå¡«æ–½è¨­ãªã—ï¼‰"),
        expanded=bool(mhlw_facs),
    ):
        if mhlw_facs:
            st.success(
                f"âœ… åˆ†æå®Ÿè¡Œæ™‚ã«åšåŠ´çœDBã‹ã‚‰ **{len(mhlw_facs)}ä»¶** ã®OSMæœªåéŒ²åŒ»ç™‚æ©Ÿé–¢ã‚’è‡ªå‹•è£œå¡«ã—ã€"
                f"æ–¹æ³•â‘ ã®æ¨è¨ˆã«åæ˜ æ¸ˆã¿ã§ã™ã€‚"
            )
            for i, fac in enumerate(mhlw_facs):
                c1, c2 = st.columns([5, 1])
                c1.markdown(
                    f"ğŸŸ£ **{fac.name}** / {fac.specialty} / "
                    f"æ¨è¨ˆ{fac.daily_outpatients}äºº/æ—¥ / {fac.distance_m:.0f}m"
                )
                if c2.button("å‰Šé™¤", key=f"del_mhlw_{i}", use_container_width=True):
                    st.session_state["mhlw_supplement"].pop(i)
                    recalculate_with_manual_facilities(analysis)
            st.markdown("---")
        else:
            st.info(
                "MHLWè£œå¡«ã«ã‚ˆã‚‹æ–°è¦æ–½è¨­ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
                "ï¼ˆOSMã¨ã®é‡è¤‡æ’é™¤å¾Œã€æ–°è¦æ–½è¨­ãªã—ï¼‰"
            )

        # å†å®Ÿè¡Œãƒœã‚¿ãƒ³ï¼ˆå¿…è¦ãªå ´åˆã®ã¿ï¼‰
        if analysis.pharmacy_lat:
            search_r = analysis.commercial_radius + 200
            pref_code = ""
            for pref_name, pc in PREFECTURE_CODES.items():
                if pref_name in analysis.pharmacy_address:
                    pref_code = pc
                    break
            st.caption(
                f"è£œå¡«æ¡ä»¶: ã‚¨ãƒªã‚¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ **{extract_area_keyword(analysis.pharmacy_address)}** / "
                f"åŠå¾„ {search_r}m"
            )
            if st.button(
                "ğŸ”„ MHLWè£œå¡«ã‚’å†å®Ÿè¡Œ", key="mhlw_rerun_btn",
                use_container_width=True,
                help="è£œå¡«æ¡ä»¶ã‚’å¤‰ãˆã¦å†å–å¾—ã—ãŸã„å ´åˆã«ã‚¯ãƒªãƒƒã‚¯"
            ):
                progress = st.progress(0, text="MHLWåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’å†æ¤œç´¢ä¸­â€¦")
                new_facs, sup_log = fetch_mhlw_medical_supplement(
                    pharmacy_lat=analysis.pharmacy_lat,
                    pharmacy_lon=analysis.pharmacy_lon,
                    pharmacy_address=analysis.pharmacy_address,
                    pref_code=pref_code,
                    existing_osm=list(analysis.nearby_medical),
                    search_radius_m=search_r,
                    progress_bar=progress,
                )
                st.session_state["mhlw_supplement_log"] = sup_log
                progress.empty()
                st.session_state["mhlw_supplement"] = new_facs
                recalculate_with_manual_facilities(analysis)

        if st.session_state.get("mhlw_supplement_log"):
            with st.expander("ğŸ“‹ è£œå¡«ãƒ­ã‚°ã‚’è¡¨ç¤º"):
                st.code("\n".join(st.session_state["mhlw_supplement_log"]))

    # â”€â”€â”€ æ‰‹å‹•è¿½åŠ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    params_list: List[Dict] = st.session_state.get("manual_facility_params", [])

    with st.expander(
        f"ğŸ¥ è¿‘éš£æ–½è¨­ã‚’æ‰‹å‹•è¿½åŠ ã—ã¦å†è¨ˆç®—ï¼ˆç¾åœ¨ {len(params_list)} ä»¶è¿½åŠ æ¸ˆã¿ï¼‰"
        + (" â† ä¹–é›¢ã®è£œæ­£ã¯ã“ã¡ã‚‰" if implied else ""),
        expanded=bool(implied),
    ):
        # â”€â”€ è¿½åŠ æ¸ˆã¿æ–½è¨­ä¸€è¦§ â”€â”€
        if params_list:
            st.markdown("**â–¶ æ‰‹å‹•è¿½åŠ æ¸ˆã¿æ–½è¨­**")
            for i, p in enumerate(params_list):
                c1, c2 = st.columns([5, 1])
                c1.markdown(
                    f"- **{p['name']}** / {p['specialty']} / {p['daily_outpatients']}äºº/æ—¥ / "
                    f"{p['distance_m']:.0f}m"
                    + ("ï¼ˆé™¢å†…è–¬å±€ã‚ã‚Šï¼‰" if p["has_inhouse"] else "")
                )
                if c2.button("å‰Šé™¤", key=f"del_fac_{i}", use_container_width=True):
                    del st.session_state["manual_facility_params"][i]
                    st.rerun()
            st.markdown("---")

        # â”€â”€ MHLWã‚¯ãƒªãƒ‹ãƒƒã‚¯æ¤œç´¢ â”€â”€
        st.markdown("##### ğŸ” MHLWåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æ¤œç´¢ã—ã¦è¿½åŠ ")
        col_kw, col_pref = st.columns([3, 1])
        with col_kw:
            clinic_kw = st.text_input(
                "ã‚¯ãƒªãƒ‹ãƒƒã‚¯åï¼ˆä¸€éƒ¨ã§ã‚‚å¯ï¼‰",
                placeholder="ä¾‹: æ­¦è”µå°æ‰ å†…ç§‘ / â—‹â—‹ã‚¯ãƒªãƒ‹ãƒƒã‚¯ / â–³â–³åŒ»é™¢",
                key="clinic_search_kw_v4",
            )
        with col_pref:
            clinic_pref = st.selectbox(
                "éƒ½é“åºœçœŒï¼ˆä»»æ„ï¼‰", ["ï¼ˆæŒ‡å®šãªã—ï¼‰"] + PREFECTURES,
                key="clinic_search_pref_v4",
            )

        if st.button("ğŸ” MHLWã§æ¤œç´¢", key="search_clinic_btn_v4", use_container_width=True):
            if clinic_kw.strip():
                with st.spinner("MHLWåŒ»ç™‚æ©Ÿé–¢ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æ¤œç´¢ä¸­â€¦"):
                    scraper = MHLWScraper()
                    scraper.initialize_session()
                    cands = scraper.search_clinic_by_keyword(
                        clinic_kw.strip(),
                        PREFECTURE_CODES.get(clinic_pref, ""),
                    )
                st.session_state["clinic_candidates_v4"] = cands
                if not cands:
                    st.info("è©²å½“æ–½è¨­ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚åˆ¥ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚")
            else:
                st.warning("ã‚¯ãƒªãƒ‹ãƒƒã‚¯åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚")

        clinic_cands: List[PharmacyCandidate] = st.session_state.get("clinic_candidates_v4", [])
        if clinic_cands:
            options = [f"{c.name}ã€€{c.address[:35]}" for c in clinic_cands]
            sel_label = st.selectbox("æ¤œç´¢çµæœã‹ã‚‰é¸æŠ", options, key="clinic_sel_v4")
            sel_cand = clinic_cands[options.index(sel_label)]

            col_a, col_b, col_c, col_d = st.columns(4)
            mhlw_dist    = col_a.number_input("è·é›¢(m)", 1, 2000, 30, step=5, key="mhlw_dist_v4")
            mhlw_sp      = col_b.selectbox("è¨ºç™‚ç§‘", list(SPECIALTY_RX_RATES.keys()),
                                           key="mhlw_sp_v4")
            mhlw_op      = col_c.number_input("å¤–æ¥æ‚£è€…æ•°/æ—¥", 1, 500, 20, key="mhlw_op_v4",
                                              help="MHLWå–å¾—ãƒœã‚¿ãƒ³ã§è‡ªå‹•å–å¾—ã‚’è©¦ã¿ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ20äºº/æ—¥: åšåŠ´çœã€ŒåŒ»ç™‚æ–½è¨­èª¿æŸ»ã€ã®ç„¡åºŠè¨ºç™‚æ‰€å¹³å‡22äºº/æ—¥ã«æº–ã˜ãŸå€¤ï¼‰")
            mhlw_inhouse = col_d.checkbox("é™¢å†…è–¬å±€ã‚ã‚Š", key="mhlw_inhouse_v4")

            col_fetch, col_add = st.columns(2)
            if col_fetch.button("ğŸ“¥ å¤–æ¥æ‚£è€…æ•°ã‚’MHLWã‹ã‚‰å–å¾—", key="fetch_op_btn_v4"):
                with st.spinner("MHLW ã‹ã‚‰å¤–æ¥æ‚£è€…æ•°ã‚’å–å¾—ä¸­â€¦"):
                    scraper2 = MHLWScraper()
                    scraper2.initialize_session()
                    op, msg = scraper2.get_clinic_daily_outpatients(sel_cand)
                if op:
                    st.success(f"å–å¾—æˆåŠŸ: {op}äºº/æ—¥ï¼ˆ{msg}ï¼‰")
                    st.session_state["mhlw_fetched_op_v4"] = op
                else:
                    st.info(f"è‡ªå‹•å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸï¼ˆ{msg}ï¼‰ã€‚æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚")

            fetched_op = st.session_state.get("mhlw_fetched_op_v4")
            if fetched_op:
                st.caption(f"ğŸ’¡ å–å¾—å€¤: {fetched_op}äºº/æ—¥ï¼ˆä¸Šã®å…¥åŠ›æ¬„ã«åæ˜ ã™ã‚‹ã«ã¯æ‰‹å‹•ã§ä¸Šæ›¸ãã‚’ï¼‰")

            if col_add.button("âœ… ã“ã®æ–½è¨­ã‚’è¿½åŠ ", key="add_from_mhlw_v4", type="primary"):
                if "manual_facility_params" not in st.session_state:
                    st.session_state["manual_facility_params"] = []
                st.session_state["manual_facility_params"].append({
                    "name": sel_cand.name,
                    "specialty": mhlw_sp,
                    "daily_outpatients": mhlw_op,
                    "distance_m": float(mhlw_dist),
                    "has_inhouse": mhlw_inhouse,
                })
                st.session_state["clinic_candidates_v4"] = []
                st.session_state.pop("mhlw_fetched_op_v4", None)
                st.rerun()

        st.markdown("---")

        # â”€â”€ ç›´æ¥å…¥åŠ› â”€â”€
        st.markdown("##### âœ ã¾ãŸã¯æ–½è¨­æƒ…å ±ã‚’ç›´æ¥å…¥åŠ›")
        col1, col2, col3, col4 = st.columns(4)
        direct_name    = col1.text_input("æ–½è¨­åï¼ˆä»»æ„ï¼‰",
                                         placeholder="ä¾‹: â—‹â—‹ã‚¯ãƒªãƒ‹ãƒƒã‚¯",
                                         key="direct_name_v4")
        direct_sp      = col2.selectbox("è¨ºç™‚ç§‘", list(SPECIALTY_RX_RATES.keys()),
                                        key="direct_sp_v4")
        direct_op      = col3.number_input("å¤–æ¥æ‚£è€…æ•°/æ—¥", 1, 500, 50,
                                           key="direct_op_v4")
        direct_dist    = col4.number_input("è·é›¢(m)", 1, 2000, 30, step=5,
                                           key="direct_dist_v4")
        direct_inhouse = st.checkbox("é™¢å†…è–¬å±€ã‚ã‚Šï¼ˆâ†’é™¢å¤–å‡¦æ–¹ç‡ãŒä½ä¸‹ï¼‰",
                                     key="direct_inhouse_v4")

        if st.button("â• æ–½è¨­ã‚’ç›´æ¥è¿½åŠ ", key="add_direct_v4"):
            if "manual_facility_params" not in st.session_state:
                st.session_state["manual_facility_params"] = []
            n = len(st.session_state["manual_facility_params"])
            st.session_state["manual_facility_params"].append({
                "name": direct_name.strip() or f"æ‰‹å‹•è¿½åŠ æ–½è¨­ #{n+1}",
                "specialty": direct_sp,
                "daily_outpatients": direct_op,
                "distance_m": float(direct_dist),
                "has_inhouse": direct_inhouse,
            })
            st.rerun()

        # â”€â”€ å†è¨ˆç®—ãƒœã‚¿ãƒ³ â”€â”€
        updated_params = st.session_state.get("manual_facility_params", [])
        if updated_params:
            st.markdown("---")
            n_manual = len(updated_params)
            st.info(
                f"âœ… {n_manual}ä»¶ã®æ‰‹å‹•è¿½åŠ æ–½è¨­ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚"
                "ã€Œå†è¨ˆç®—ã€ãƒœã‚¿ãƒ³ã§äºˆæ¸¬ã«åæ˜ ã—ã¾ã™ã€‚"
            )
            if st.button(
                f"ğŸ”„ æ‰‹å‹•è¿½åŠ æ–½è¨­ï¼ˆ{n_manual}ä»¶ï¼‰ã‚’å«ã‚ã¦äºˆæ¸¬ã‚’å†è¨ˆç®—",
                type="primary", use_container_width=True, key="recalc_btn_v4",
            ):
                recalculate_with_manual_facilities(analysis)
        else:
            st.caption("æ–½è¨­ã‚’è¿½åŠ ã™ã‚‹ã¨ã€Œå†è¨ˆç®—ã€ãƒœã‚¿ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚")


def render_new_pharmacy_comparison(result: NewPharmacyResult) -> None:
    """æ–°è¦é–‹å±€ãƒ¢ãƒ¼ãƒ‰ã®äºˆæ¸¬æ¯”è¼ƒãƒãƒŠãƒ¼ï¼ˆv2.5/v2.6: 3ã‚·ãƒŠãƒªã‚ªå¯¾å¿œï¼‰"""
    sc = result.config.scenario
    m1g = result.method1_gate   # æ–¹æ³•â‘ ï¼ˆé–€å‰è¾¼ã¿ï¼‰
    m1a = result.method1_area   # æ–¹æ³•â‘ ï¼ˆæ—¢å­˜è¿‘éš£ã®ã¿ï¼‰
    m2  = result.method2        # æ–¹æ³•â‘¡ï¼ˆå•†åœäººå£ï¼‰

    st.markdown("## ğŸ“Š é–‹å±€ã‚·ãƒŠãƒªã‚ªåˆ¥ å‡¦æ–¹ç®‹æšæ•°äºˆæ¸¬")
    st.info(
        "ğŸ“Œ **æ¨è¨ˆãƒ¬ãƒ³ã‚¸ã®è¦‹æ–¹**ï¼šãƒ¬ãƒ³ã‚¸ã¯çµ±è¨ˆçš„ãªä¸ç¢ºå®Ÿæ€§ã‚’ç¤ºã—ã¾ã™ã€‚"
        "æ–¹æ³•â‘ ã¯è¿‘éš£æ–½è¨­æƒ…å ±ã®ç²¾åº¦æ¬¡ç¬¬ã§Â±30ã€œ40%ã®èª¤å·®ã€"
        "æ–¹æ³•â‘¡ã¯å•†åœäººå£ãƒ»å¸‚å ´ã‚·ã‚§ã‚¢æ¨è¨ˆã®å½±éŸ¿ã§Â±40ã€œ50%ã®èª¤å·®ãŒæƒ³å®šã•ã‚Œã¾ã™ã€‚"
        "2æ‰‹æ³•ã®ä¸­é–“å€¤ã‚’å‚è€ƒå€¤ã¨ã—ã¦ç”¨ã„ã€Â±30%ä»¥å†…ã«åã¾ã‚‹å ´åˆã¯ä¿¡é ¼åº¦ãŒé«˜ã„ã¨åˆ¤æ–­ã—ã¦ãã ã•ã„ã€‚"
    )

    # ------------------------------------------------------------------
    # ã‚·ãƒŠãƒªã‚ªB: é¢ã§ã®é›†å®¢ â†’ æ–¹æ³•â‘ ï¼ˆæ—¢å­˜è¿‘éš£ï¼‰+ æ–¹æ³•â‘¡ï¼ˆå•†åœï¼‰
    # ------------------------------------------------------------------
    # v4.1: æ ¡æ­£æ¸ˆã¿äºˆæ¸¬ã®å–å¾—ï¼ˆã‚·ãƒŠãƒªã‚ªBç”¨ï¼‰
    cal_stats_new: Optional[CalibrationStats] = st.session_state.get("calibration_stats")

    if sc == "area_dual":
        st.markdown("#### ğŸŒ ã‚·ãƒŠãƒªã‚ªB: é¢ã§ã®é›†å®¢ï¼ˆæ–¹æ³•â‘ æ—¢å­˜ï¼‹æ–¹æ³•â‘¡ï¼‰")
        n_cols_b = 4 if (cal_stats_new and m1a and m2) else 3
        cols = st.columns(n_cols_b)
        with cols[0]:
            if m1a:
                st.metric("â‘  è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ", f"{m1a.annual_rx:,} æš/å¹´")
                st.caption(f"ãƒ¬ãƒ³ã‚¸: {m1a.min_val:,}ã€œ{m1a.max_val:,} | {m1a.daily_rx}æš/æ—¥")
                st.caption("æ—¢å­˜OSMæ–½è¨­ã‹ã‚‰ã®æµå…¥æ¨è¨ˆ")
            else:
                st.info("æ–¹æ³•â‘ ï¼šè¿‘éš£æ–½è¨­ãªã—ï¼ˆæ¨è¨ˆä¸å¯ï¼‰")
        with cols[1]:
            if m2:
                st.metric("â‘¡ å•†åœäººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ", f"{m2.annual_rx:,} æš/å¹´")
                st.caption(f"ãƒ¬ãƒ³ã‚¸: {m2.min_val:,}ã€œ{m2.max_val:,} | {m2.daily_rx}æš/æ—¥")
                st.caption(f"å•†åœåŠå¾„: {result.commercial_radius}m / å¯†åº¦: {result.area_density:,}äºº/kmÂ²")
            else:
                st.info("æ–¹æ³•â‘¡ï¼šæ¨è¨ˆä¸å¯")
        with cols[2]:
            if m1a and m2:
                avg = (m1a.annual_rx + m2.annual_rx) // 2
                diff = abs(m1a.annual_rx - m2.annual_rx)
                pct = diff / max(avg, 1) * 100
                st.metric("ğŸ“ˆ 2æ‰‹æ³•ã®ä¸­é–“æ¨è¨ˆ", f"{avg:,} æš/å¹´")
                st.caption(f"æ‰‹æ³•é–“å·®: {diff:,}æš/å¹´ ({pct:.0f}%)")
                if pct < 30:
                    st.caption("âœ… 2æ‰‹æ³•ã®ä¸€è‡´åº¦: é«˜ï¼ˆæ¨è¨ˆç²¾åº¦è‰¯å¥½ï¼‰")
                elif pct < 70:
                    st.caption("âš  2æ‰‹æ³•ã®ä¸€è‡´åº¦: ä¸­ï¼ˆèª¤å·®ç¯„å›²ã«æ³¨æ„ï¼‰")
                else:
                    st.caption("â— 2æ‰‹æ³•ã®ä¹–é›¢ãŒå¤§ãã„ï¼ˆç«‹åœ°æ¡ä»¶ã‚’è¦ç¢ºèªï¼‰")
        if n_cols_b == 4:
            with cols[3]:
                cal_rx_b, cal_note_b = CalibrationEngine.apply_correction(
                    m1a.annual_rx, m2.annual_rx, result.area_density, cal_stats_new
                )
                st.metric("ğŸ¯ æ ¡æ­£æ¸ˆã¿æ¨è¨ˆ (v4.1)", f"{cal_rx_b:,} æš/å¹´")
                st.caption(f"MAPE={cal_stats_new.mape_optimal:.1f}% / n={cal_stats_new.n}")
                with st.expander("è©³ç´°"):
                    st.caption(cal_note_b)

    # ------------------------------------------------------------------
    # ã‚·ãƒŠãƒªã‚ªC: é¢ï¼‹é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ â†’ æ–¹æ³•â‘ ï¼ˆé–€å‰è¾¼ã¿ï¼‰+ æ–¹æ³•â‘¡ï¼ˆå•†åœï¼‰
    # ------------------------------------------------------------------
    elif sc == "combined":
        st.markdown(
            "#### ğŸ¥ ã‚·ãƒŠãƒªã‚ªC: é¢ï¼‹é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ï¼ˆæ–¹æ³•â‘ é–€å‰è¾¼ã¿ï¼‹æ–¹æ³•â‘¡ï¼‰\n\n"
            f"> èª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯: **{result.config.gate_specialty}** "
            f"ï¼ˆ{result.config.gate_daily_outpatients}äºº/æ—¥ï¼‰"
        )
        cols = st.columns(4)
        with cols[0]:
            if m1a:
                st.metric("â‘  é¢ã®ã¿ï¼ˆæ—¢å­˜è¿‘éš£ï¼‰", f"{m1a.annual_rx:,} æš/å¹´")
                st.caption(f"{m1a.min_val:,}ã€œ{m1a.max_val:,} | {m1a.daily_rx}æš/æ—¥")
            else:
                st.info("æ–¹æ³•â‘ (é¢ã®ã¿): æ¨è¨ˆä¸å¯")
        with cols[1]:
            if m1g:
                st.metric("â‘  é–€å‰è¾¼ã¿ï¼ˆé¢ï¼‹èª˜è‡´ï¼‰", f"{m1g.annual_rx:,} æš/å¹´")
                st.caption(f"{m1g.min_val:,}ã€œ{m1g.max_val:,} | {m1g.daily_rx}æš/æ—¥")
            else:
                st.info("æ–¹æ³•â‘ (é–€å‰è¾¼ã¿): æ¨è¨ˆä¸å¯")
        with cols[2]:
            if m2:
                st.metric("â‘¡ å•†åœäººå£å‹•æ…‹", f"{m2.annual_rx:,} æš/å¹´")
                st.caption(f"{m2.min_val:,}ã€œ{m2.max_val:,} | {m2.daily_rx}æš/æ—¥")
                st.caption(f"å•†åœåŠå¾„: {result.commercial_radius}m")
            else:
                st.info("æ–¹æ³•â‘¡: æ¨è¨ˆä¸å¯")
        with cols[3]:
            # é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã®ä»˜åŠ ä¾¡å€¤
            if m1g and m1a:
                gate_add = m1g.annual_rx - m1a.annual_rx
                st.metric(
                    "ğŸšª é–€å‰èª˜è‡´ã®ä»˜åŠ ä¾¡å€¤",
                    f"+{gate_add:,} æš/å¹´" if gate_add >= 0 else f"{gate_add:,} æš/å¹´",
                    delta=f"{gate_add:,}æš/å¹´",
                )
                st.caption(f"= é–€å‰è¾¼ã¿({m1g.annual_rx:,}) âˆ’ é¢ã®ã¿({m1a.annual_rx:,})")
            elif m1g and m2:
                avg = (m1g.annual_rx + m2.annual_rx) // 2
                st.metric("ğŸ“ˆ ç·åˆä¸­é–“æ¨è¨ˆ", f"{avg:,} æš/å¹´")
                st.caption("æ–¹æ³•â‘ é–€å‰è¾¼ã¿ï¼‹æ–¹æ³•â‘¡ã®å¹³å‡")

    # ------------------------------------------------------------------
    # ã‚·ãƒŠãƒªã‚ªA: é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã®ã¿ â†’ æ–¹æ³•â‘ ï¼ˆé–€å‰è¾¼ã¿ï¼‰ã®ã¿
    # ------------------------------------------------------------------
    elif sc == "gate_only":
        st.markdown(
            "#### ğŸšª ã‚·ãƒŠãƒªã‚ªA: é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ï¼ˆæ–¹æ³•â‘ ã®ã¿ï¼‰\n\n"
            f"> èª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯: **{result.config.gate_specialty}** "
            f"ï¼ˆ{result.config.gate_daily_outpatients}äºº/æ—¥ï¼‰"
        )
        cols = st.columns(2)
        with cols[0]:
            if m1g:
                st.metric("â‘  è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆé–€å‰è¾¼ã¿ï¼‰", f"{m1g.annual_rx:,} æš/å¹´")
                st.caption(f"ãƒ¬ãƒ³ã‚¸: {m1g.min_val:,}ã€œ{m1g.max_val:,}æš/å¹´ | {m1g.daily_rx}æš/æ—¥")
                st.caption(f"èª˜è‡´ç§‘: {result.config.gate_specialty} ({result.config.gate_daily_outpatients}äºº/æ—¥)")
            else:
                st.info("æ–¹æ³•â‘ : æ¨è¨ˆä¸å¯")
        with cols[1]:
            st.info(
                "ğŸ’¡ **ãƒ’ãƒ³ãƒˆ**: ã‚·ãƒŠãƒªã‚ªCã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã¨ã€æ–¹æ³•â‘¡ï¼ˆå•†åœäººå£ï¼‰ã¨ä½µç”¨ã§ãã€\n"
                "é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã®**ä»˜åŠ ä¾¡å€¤**ï¼ˆå¢—æšæ•°ï¼‰ã‚‚è‡ªå‹•ç®—å‡ºã—ã¾ã™ã€‚"
            )

    # ------------------------------------------------------------------
    # å…¨æ¯”è¼ƒ: Bãƒ»Cãƒ»Aã‚’æ¨ªä¸¦ã³è¡¨ç¤º
    # ------------------------------------------------------------------
    elif sc == "all":
        st.markdown("#### ğŸ”„ å…¨ã‚·ãƒŠãƒªã‚ªä¸€è¦§æ¯”è¼ƒ")
        cols = st.columns(4)
        with cols[0]:
            st.markdown("**ã‚·ãƒŠãƒªã‚ªB: é¢ã®ã¿**")
            if m1a:
                st.metric("â‘  æ—¢å­˜è¿‘éš£", f"{m1a.annual_rx:,}")
                st.caption(f"{m1a.daily_rx}æš/æ—¥")
            if m2:
                st.metric("â‘¡ å•†åœäººå£", f"{m2.annual_rx:,}")
                st.caption(f"{m2.daily_rx}æš/æ—¥")
        with cols[1]:
            st.markdown("**ã‚·ãƒŠãƒªã‚ªC: é¢ï¼‹é–€å‰**")
            if m1g:
                st.metric("â‘  é–€å‰è¾¼ã¿", f"{m1g.annual_rx:,}")
                st.caption(f"{m1g.daily_rx}æš/æ—¥")
            if m2:
                st.metric("â‘¡ å•†åœäººå£", f"{m2.annual_rx:,}")
                st.caption("ï¼ˆBã¨å…±é€šï¼‰")
        with cols[2]:
            st.markdown("**ã‚·ãƒŠãƒªã‚ªA: é–€å‰ã®ã¿**")
            if m1g:
                st.metric("â‘  é–€å‰è¾¼ã¿", f"{m1g.annual_rx:,}")
                st.caption(f"{m1g.daily_rx}æš/æ—¥")
            else:
                st.info("éå®Ÿè¡Œ")
        with cols[3]:
            st.markdown("**é–€å‰èª˜è‡´ã®ä»˜åŠ ä¾¡å€¤**")
            if m1g and m1a:
                gate_add = m1g.annual_rx - m1a.annual_rx
                st.metric(
                    "ğŸšª å¢—æšæ•°ï¼ˆæ–¹æ³•â‘ ï¼‰",
                    f"+{gate_add:,} æš/å¹´" if gate_add >= 0 else f"{gate_add:,} æš/å¹´",
                )
                st.caption(f"é–€å‰è¾¼ã¿({m1g.annual_rx:,}) âˆ’ é¢ã®ã¿({m1a.annual_rx:,})")
            else:
                st.info("æ¯”è¼ƒä¸å¯ï¼ˆé¢ã®ã¿ or é–€å‰ã®ã¿é¸æŠï¼‰")


def _render_new_pharmacy_prediction_tabs(result: NewPharmacyResult) -> None:
    """æ–°è¦é–‹å±€ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ã®äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ã‚¿ãƒ–ï¼ˆv2.5/v2.6: 3ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¯¾å¿œï¼‰"""
    import pandas as pd
    sc = result.config.scenario
    m1g = result.method1_gate
    m1a = result.method1_area
    m2  = result.method2

    tab_labels = []
    if m1a:
        tab_labels.append("â‘  è¿‘éš£æ–½è¨­ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆé¢ã®ã¿ï¼‰")
    if m1g:
        tab_labels.append("â‘  è¿‘éš£æ–½è¨­ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆé–€å‰è¾¼ã¿ï¼‰")
    if m2:
        tab_labels.append("â‘¡ å•†åœäººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ")
    tab_labels.append("ğŸ“š ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹")

    tabs = st.tabs(tab_labels)
    idx = 0

    if m1a:
        with tabs[idx]:
            st.metric("å¹´é–“æ¨è¨ˆå‡¦æ–¹ç®‹æšæ•°ï¼ˆæ–¹æ³•â‘ : æ—¢å­˜è¿‘éš£ã®ã¿ï¼‰", f"{m1a.annual_rx:,} æš/å¹´")
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m1a.min_val:,}ã€œ{m1a.max_val:,}æš/å¹´ | {m1a.daily_rx}æš/æ—¥")
            st.caption("OSMã§æ¤œç´¢ã•ã‚ŒãŸæ—¢å­˜ã®è¿‘éš£åŒ»ç™‚æ–½è¨­ã‹ã‚‰ã®æµå…¥ã®ã¿ã§æ¨è¨ˆ")
            if m1a.breakdown:
                st.markdown("#### æ–½è¨­åˆ¥ å‡¦æ–¹ç®‹æµå…¥å†…è¨³")
                st.dataframe(pd.DataFrame(m1a.breakdown), use_container_width=True, hide_index=True)
            st.markdown("#### æ¨è¨ˆãƒ­ã‚¸ãƒƒã‚¯")
            for line in m1a.methodology:
                st.markdown(line)
        idx += 1

    if m1g:
        with tabs[idx]:
            st.metric("å¹´é–“æ¨è¨ˆå‡¦æ–¹ç®‹æšæ•°ï¼ˆæ–¹æ³•â‘ : èª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯è¾¼ã¿ï¼‰", f"{m1g.annual_rx:,} æš/å¹´")
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m1g.min_val:,}ã€œ{m1g.max_val:,}æš/å¹´ | {m1g.daily_rx}æš/æ—¥")
            gate_add_note = ""
            if m1a:
                gate_add = m1g.annual_rx - m1a.annual_rx
                gate_add_note = f"é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã®ä»˜åŠ ä¾¡å€¤: **+{gate_add:,}æš/å¹´**ï¼ˆ= {m1g.annual_rx:,} âˆ’ {m1a.annual_rx:,}ï¼‰"
                st.info(f"ğŸšª {gate_add_note}")
            else:
                st.caption(f"èª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯: {result.config.gate_specialty} ({result.config.gate_daily_outpatients}äºº/æ—¥)")
            if m1g.breakdown:
                st.markdown("#### æ–½è¨­åˆ¥ å‡¦æ–¹ç®‹æµå…¥å†…è¨³ï¼ˆèª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯å«ã‚€ï¼‰")
                st.dataframe(pd.DataFrame(m1g.breakdown), use_container_width=True, hide_index=True)
            st.markdown("#### æ¨è¨ˆãƒ­ã‚¸ãƒƒã‚¯")
            for line in m1g.methodology:
                st.markdown(line)
        idx += 1

    if m2:
        with tabs[idx]:
            st.metric("å¹´é–“æ¨è¨ˆå‡¦æ–¹ç®‹æšæ•°ï¼ˆæ–¹æ³•â‘¡ï¼‰", f"{m2.annual_rx:,} æš/å¹´")
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m2.min_val:,}ã€œ{m2.max_val:,}æš/å¹´ | {m2.daily_rx}æš/æ—¥")
            if m2.breakdown:
                st.markdown("#### å¹´é½¢å±¤åˆ¥ å‡¦æ–¹ç®‹æ•°å†…è¨³")
                st.dataframe(pd.DataFrame(m2.breakdown), use_container_width=True, hide_index=True)
            st.markdown("#### æ¨è¨ˆãƒ­ã‚¸ãƒƒã‚¯")
            for line in m2.methodology:
                if line:
                    st.markdown(line)
        idx += 1

    with tabs[idx]:
        render_data_sources_panel()


def render_prediction_tabs(m1: Optional[PredictionResult], m2: Optional[PredictionResult]) -> None:
    """äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ã‚¿ãƒ–ã‚’è¡¨ç¤ºï¼ˆæ—¢å­˜ãƒ»æ–°è¦ãƒ¢ãƒ¼ãƒ‰å…±é€šï¼‰"""
    import pandas as pd
    tab_labels = []
    if m1: tab_labels.append("â‘  åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ")
    if m2: tab_labels.append("â‘¡ äººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ")
    tab_labels.append("ğŸ“š ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹")
    tabs = st.tabs(tab_labels)
    tab_idx = 0
    if m1:
        with tabs[tab_idx]:
            st.metric("å¹´é–“æ¨è¨ˆå‡¦æ–¹ç®‹æšæ•°", f"{m1.annual_rx:,} æš/å¹´")
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m1.min_val:,}ã€œ{m1.max_val:,}æš/å¹´ | {m1.daily_rx}æš/æ—¥")
            if m1.breakdown:
                st.markdown("#### æ–½è¨­åˆ¥ å‡¦æ–¹ç®‹æµå…¥å†…è¨³")
                st.dataframe(pd.DataFrame(m1.breakdown), use_container_width=True, hide_index=True)
            st.markdown("#### æ¨è¨ˆãƒ­ã‚¸ãƒƒã‚¯")
            for line in m1.methodology:
                st.markdown(line)
        tab_idx += 1
    if m2:
        with tabs[tab_idx]:
            st.metric("å¹´é–“æ¨è¨ˆå‡¦æ–¹ç®‹æšæ•°", f"{m2.annual_rx:,} æš/å¹´")
            st.caption(f"ãƒ¬ãƒ³ã‚¸: {m2.min_val:,}ã€œ{m2.max_val:,}æš/å¹´ | {m2.daily_rx}æš/æ—¥")
            if m2.breakdown:
                st.markdown("#### å¹´é½¢å±¤åˆ¥ å‡¦æ–¹ç®‹æ•°å†…è¨³")
                st.dataframe(pd.DataFrame(m2.breakdown), use_container_width=True, hide_index=True)
            st.markdown("#### æ¨è¨ˆãƒ­ã‚¸ãƒƒã‚¯")
            for line in m2.methodology:
                if line:
                    st.markdown(line)
        tab_idx += 1
    with tabs[tab_idx]:
        render_data_sources_panel()


def render_competitor_table(medical, pharmacies, show_rx: bool = False) -> None:
    import pandas as pd
    st.markdown("### ğŸ—º è¿‘éš£ã®åŒ»ç™‚æ–½è¨­ãƒ»ç«¶åˆè–¬å±€")
    c1, c2 = st.columns(2)
    with c1:
        st.markdown(f"**åŒ»ç™‚æ–½è¨­ï¼ˆ{len(medical)}ä»¶ï¼‰**")
        if medical:
            rows = [{"æ–½è¨­å": f.name,
                     "ç¨®åˆ¥": "ç—…é™¢" if f.facility_type == "hospital" else "ã‚¯ãƒªãƒ‹ãƒƒã‚¯",
                     "è·é›¢": f"{f.distance_m:.0f}m",
                     "è¨ºç™‚ç§‘": f.specialty,
                     "å¤–æ¥/æ—¥(æ¨è¨ˆ)": f"{f.daily_outpatients}äºº",
                     "é™¢å†…è–¬å±€": "ã‚ã‚Š" if f.has_inhouse_pharmacy else "ãªã—"}
                    for f in medical]
            st.dataframe(pd.DataFrame(rows), use_container_width=True, hide_index=True)
        else:
            st.info("æ¤œç´¢ç¯„å›²å†…ã«åŒ»ç™‚æ–½è¨­ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
    with c2:
        st.markdown(f"**ç«¶åˆè–¬å±€ï¼ˆ{len(pharmacies)}ä»¶ï¼‰**")
        if pharmacies:
            rows = [{"è–¬å±€å": p.name,
                     "è·é›¢": f"{p.distance_m:.0f}m",
                     "ãƒã‚§ãƒ¼ãƒ³": "ã¯ã„" if any(c in p.name for c in MAJOR_CHAINS) else "ç‹¬ç«‹",
                     "å‡¦æ–¹ç®‹/å¹´(MHLW)": f"{p.mhlw_annual_outpatients:,}æš" if p.mhlw_annual_outpatients else "æœªå–å¾—"}
                    for p in pharmacies]
            st.dataframe(pd.DataFrame(rows), use_container_width=True, hide_index=True)
        else:
            st.info("æ¤œç´¢ç¯„å›²å†…ã«ç«¶åˆè–¬å±€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")


# ---------------------------------------------------------------------------
# 10. ãƒ¡ã‚¤ãƒ³ UI
# ---------------------------------------------------------------------------
# v4.1: ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ã‚¿ãƒ– UI
# ---------------------------------------------------------------------------

def _render_calibration_tab() -> None:
    """ğŸ”¬ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ã‚¿ãƒ–ï¼ˆv4.1æ–°æ©Ÿèƒ½ï¼‰"""
    st.markdown(
        "### ğŸ”¬ ãƒ‡ãƒ¼ã‚¿ãƒ‰ãƒªãƒ–ãƒ³ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£\n\n"
        "MHLWã«å‡¦æ–¹ç®‹æšæ•°ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹è–¬å±€ã‚’è‡ªå‹•åé›†ã—ã€"
        "**ä½æ‰€ã®ã¿ã®æƒ…å ±**ã§æ–¹æ³•â‘ ãƒ»â‘¡ã®äºˆæ¸¬ã‚’å®Ÿæ–½ã€‚\n"
        "å®Ÿç¸¾å€¤ã¨ã®æ¯”è¼ƒã‹ã‚‰**æœ€ã‚‚ç²¾åº¦ã®é«˜ã„è£œæ­£ä¿‚æ•°ã¨æ··åˆæ¯”ç‡**ã‚’è‡ªå‹•å°å‡ºã—ã¾ã™ã€‚\n\n"
        "| ã‚¹ãƒ†ãƒƒãƒ— | å†…å®¹ |\n"
        "|---|---|\n"
        "| 1. æ ¡æ­£ã‚»ãƒƒãƒˆåé›† | MHLWã§éƒ½é“åºœçœŒã‚’æŒ‡å®š â†’ å‡¦æ–¹ç®‹å®Ÿç¸¾ã®ã‚ã‚‹è–¬å±€ã‚’Nä»¶å–å¾— |\n"
        "| 2. ãƒãƒƒãƒäºˆæ¸¬ | å„è–¬å±€ã‚’ä½æ‰€ã®ã¿ã§äºˆæ¸¬ï¼ˆOSM+MHLWè£œå¡«+æ–¹æ³•â‘ â‘¡ï¼‰ |\n"
        "| 3. çµ±è¨ˆè¨ˆç®— | MAPE / ãƒã‚¤ã‚¢ã‚¹ / å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•° Î± / æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰é‡ã¿ w* |\n"
        "| 4. é©ç”¨ | æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’äºˆæ¸¬çµæœã«è‡ªå‹•é©ç”¨ï¼ˆæ—¢å­˜ãƒ»æ–°è¦ãƒ¢ãƒ¼ãƒ‰ä¸¡æ–¹ï¼‰ |"
    )
    st.markdown("---")

    # â”€â”€ è¨­å®šãƒ‘ãƒãƒ« â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    st.markdown("#### âš™ï¸ æ ¡æ­£è¨­å®š")
    col_pref, col_n, col_min = st.columns(3)
    with col_pref:
        cal_pref = st.selectbox(
            "å¯¾è±¡éƒ½é“åºœçœŒ",
            PREFECTURES,
            index=12,  # æ±äº¬éƒ½
            key="cal_pref",
            help="å‡¦æ–¹ç®‹æšæ•°ã‚’åé›†ã™ã‚‹éƒ½é“åºœçœŒã€‚éƒ½å¸‚éƒ¨ï¼ˆæ±äº¬ãƒ»å¤§é˜ªç­‰ï¼‰ã¯é«˜å¯†åº¦ã‚µãƒ³ãƒ—ãƒ«ãŒå–ã‚Šã‚„ã™ã„",
        )
    with col_n:
        cal_n = st.slider(
            "åé›†ã™ã‚‹è–¬å±€æ•°",
            min_value=5, max_value=50, value=20, step=5,
            key="cal_n",
            help="å¤šã„ã»ã©ç²¾åº¦ãŒä¸ŠãŒã‚‹ãŒæ™‚é–“ãŒã‹ã‹ã‚‹ï¼ˆ1ä»¶ã‚ãŸã‚Šç´„5ã€œ8ç§’ï¼‰",
        )
    with col_min:
        cal_min_rx = st.number_input(
            "æœ€ä½å‡¦æ–¹ç®‹æšæ•°ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ï¼‰",
            min_value=0, max_value=50_000, value=2_000, step=1_000,
            key="cal_min_rx",
            help="ã“ã®æšæ•°æœªæº€ã®è–¬å±€ã¯æ ¡æ­£ã‚µãƒ³ãƒ—ãƒ«ã‹ã‚‰é™¤å¤–ï¼ˆå¤–ã‚Œå€¤å¯¾ç­–ï¼‰",
        )

    cal_keyword = st.text_input(
        "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆä»»æ„ï¼‰",
        value="è–¬å±€",
        key="cal_keyword",
        help="MHLWã§æ¤œç´¢ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€‚åœ°åã‚’å…¥ã‚Œã‚‹ã¨ç‰¹å®šã‚¨ãƒªã‚¢ã«çµã‚Œã¾ã™ï¼ˆä¾‹: æ–°å®¿ è–¬å±€ï¼‰",
    )

    est_time = int(cal_n * 7 / 60)
    st.info(
        f"â± æ¨å®šå®Ÿè¡Œæ™‚é–“: ç´„ {est_time} åˆ†ï¼ˆ{cal_n}ä»¶ Ã— ç´„7ç§’/ä»¶ï¼‰"
        " â€• å®Ÿè¡Œä¸­ã¯ä»–ã®ã‚¿ãƒ–ã®æ“ä½œã‚’ãŠæ§ãˆãã ã•ã„"
    )

    col_run, col_clear = st.columns([3, 1])
    with col_run:
        run_btn = st.button(
            "ğŸš€ æ ¡æ­£ã‚’å®Ÿè¡Œã™ã‚‹",
            type="primary",
            use_container_width=True,
            key="cal_run",
        )
    with col_clear:
        if st.button("ğŸ—‘ æ ¡æ­£ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ", use_container_width=True, key="cal_clear"):
            st.session_state["calibration_points"] = []
            st.session_state["calibration_stats"] = None
            st.success("æ ¡æ­£ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ")
            st.rerun()

    # â”€â”€ æ ¡æ­£å®Ÿè¡Œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if run_btn:
        pref_code = PREFECTURE_CODES.get(cal_pref, "")
        engine = CalibrationEngine()
        progress = st.progress(0, text="æ ¡æ­£ã‚’é–‹å§‹â€¦")
        log_placeholder = st.empty()

        def progress_cb(pct: int, msg: str) -> None:
            progress.progress(pct, text=msg)
            log_placeholder.caption(msg)

        # Step 1: æ ¡æ­£ã‚»ãƒƒãƒˆåé›†
        cal_set = engine.search_calibration_set(
            pref_code=pref_code,
            keyword=cal_keyword,
            max_pharmacies=cal_n,
            min_rx=cal_min_rx,
            progress_cb=progress_cb,
        )
        if not cal_set:
            progress.empty()
            log_placeholder.empty()
            st.error("âŒ æ ¡æ­£ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’åé›†ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚„éƒ½é“åºœçœŒã‚’å¤‰ãˆã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚")
        else:
            st.info(f"ğŸ“¦ æ ¡æ­£ã‚»ãƒƒãƒˆ: {len(cal_set)}ä»¶ã®è–¬å±€ã‚’åé›†ã—ã¾ã—ãŸ")

            # Step 2: ãƒãƒƒãƒäºˆæ¸¬
            points = engine.run_batch(cal_set, progress_cb=progress_cb)
            st.session_state["calibration_points"] = points

            # Step 3: çµ±è¨ˆè¨ˆç®—
            stats = CalibrationEngine.calc_stats(points)
            st.session_state["calibration_stats"] = stats

            progress.progress(100, text="æ ¡æ­£å®Œäº†ï¼")
            progress.empty()
            log_placeholder.empty()
            if stats:
                st.success(f"âœ… æ ¡æ­£å®Œäº† â€” æœ€é©MAPE={stats.mape_optimal:.1f}% / æœ‰åŠ¹ã‚µãƒ³ãƒ—ãƒ«={stats.n}ä»¶")
            else:
                st.warning("âš  æœ‰åŠ¹ã‚µãƒ³ãƒ—ãƒ«ãŒå°‘ãªãã€çµ±è¨ˆè¨ˆç®—ã‚’å®Ÿè¡Œã§ãã¾ã›ã‚“ã§ã—ãŸï¼ˆ3ä»¶ä»¥ä¸Šå¿…è¦ï¼‰")
            st.rerun()

    # â”€â”€ çµæœè¡¨ç¤º â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    points: List[CalibrationPoint] = st.session_state.get("calibration_points", [])
    stats: Optional[CalibrationStats] = st.session_state.get("calibration_stats")

    if not points:
        st.markdown("---")
        st.markdown("#### ğŸ“‹ æ ¡æ­£çµæœã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“")
        st.markdown(
            "ä¸Šè¨˜ã®è¨­å®šã§ã€ŒğŸš€ æ ¡æ­£ã‚’å®Ÿè¡Œã™ã‚‹ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€"
            "MHLWã‹ã‚‰å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’åé›†ã—ã¦äºˆæ¸¬ç²¾åº¦ã‚’è‡ªå‹•æœ€é©åŒ–ã—ã¾ã™ã€‚"
        )
        return

    st.markdown("---")
    st.markdown(f"#### ğŸ“Š æ ¡æ­£çµæœï¼ˆ{len(points)}ä»¶åé›†æ¸ˆã¿ï¼‰")

    # çµ±è¨ˆã‚µãƒãƒªãƒ¼
    if stats:
        st.markdown("##### ğŸ¯ ç²¾åº¦æŒ‡æ¨™")
        c1, c2, c3, c4 = st.columns(4)
        c1.metric("æ–¹æ³•â‘  MAPE", f"{stats.mape_m1:.1f}%",
                  help="Mean Absolute Percentage Errorï¼ˆå¹³å‡çµ¶å¯¾èª¤å·®ç‡ï¼‰")
        c2.metric("æ–¹æ³•â‘¡ MAPE", f"{stats.mape_m2:.1f}%")
        c3.metric("æœ€é©ãƒ–ãƒ¬ãƒ³ãƒ‰ MAPE", f"{stats.mape_optimal:.1f}%",
                  delta=f"-{stats.mape_m1 - stats.mape_optimal:.1f}pt vs M1",
                  delta_color="inverse")
        c4.metric("æœ€é©M1é‡ã¿ w*", f"{stats.optimal_m1_weight:.0%}",
                  help=f"æœ€çµ‚äºˆæ¸¬ = {stats.optimal_m1_weight:.0%}Ã—M1 + {1-stats.optimal_m1_weight:.0%}Ã—M2")

        st.markdown("##### ğŸ“ ãƒã‚¤ã‚¢ã‚¹ï¼ˆæ¨è¨ˆå€¤/å®Ÿç¸¾å€¤ ã®å¹¾ä½•å¹³å‡ï¼‰")
        b1, b2 = st.columns(2)
        bias_m1_pct = (math.exp(stats.bias_m1) - 1) * 100
        bias_m2_pct = (math.exp(stats.bias_m2) - 1) * 100
        b1.metric(
            "æ–¹æ³•â‘  ãƒã‚¤ã‚¢ã‚¹",
            f"{bias_m1_pct:+.1f}%",
            help="æ­£ = éå¤§æ¨è¨ˆ, è²  = éå°‘æ¨è¨ˆ",
            delta_color="off",
        )
        b2.metric("æ–¹æ³•â‘¡ ãƒã‚¤ã‚¢ã‚¹", f"{bias_m2_pct:+.1f}%", delta_color="off")

        # å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•°
        if stats.alpha_m1 or stats.alpha_m2:
            st.markdown("##### ğŸ—‚ å¯†åº¦å¸¯åˆ¥è£œæ­£ä¿‚æ•° Î±ï¼ˆactual / predicted ã®å¹¾ä½•å¹³å‡ï¼‰")
            all_bands = sorted(set(list(stats.alpha_m1.keys()) + list(stats.alpha_m2.keys())))
            alpha_rows = []
            for band in all_bands:
                a1, n1 = stats.alpha_m1.get(band, (1.0, 0))
                a2, n2 = stats.alpha_m2.get(band, (1.0, 0))
                alpha_rows.append({
                    "å¯†åº¦å¸¯": band,
                    "M1 è£œæ­£ä¿‚æ•° Î±1": f"{a1:.3f} (n={n1})",
                    "M2 è£œæ­£ä¿‚æ•° Î±2": f"{a2:.3f} (n={n2})",
                    "Î±1ã®æ„å‘³": f"M1äºˆæ¸¬å€¤ã‚’{a1:.1f}å€ã—ã¦å®Ÿç¸¾ã«è¿‘ã¥ã‘ã‚‹",
                })
            import pandas as pd
            st.dataframe(pd.DataFrame(alpha_rows), use_container_width=True, hide_index=True)
            st.caption(
                "Î±>1.0: äºˆæ¸¬ãŒå®Ÿç¸¾ã‚ˆã‚Šä½ã„ï¼ˆéå°‘æ¨è¨ˆï¼‰â†’ äºˆæ¸¬å€¤ã‚’å¼•ãä¸Šã’ã‚‹æ–¹å‘ã«è£œæ­£\n"
                "Î±<1.0: äºˆæ¸¬ãŒå®Ÿç¸¾ã‚ˆã‚Šé«˜ã„ï¼ˆéå¤§æ¨è¨ˆï¼‰â†’ äºˆæ¸¬å€¤ã‚’å¼•ãä¸‹ã’ã‚‹æ–¹å‘ã«è£œæ­£"
            )

        # é©ç”¨ãƒœã‚¿ãƒ³
        st.markdown("---")
        col_apply, col_info = st.columns([1, 2])
        with col_apply:
            if st.button(
                "âœ… ã“ã®æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’äºˆæ¸¬ã«é©ç”¨",
                type="primary",
                use_container_width=True,
                key="cal_apply",
            ):
                st.session_state["calibration_stats"] = stats
                st.success("æ ¡æ­£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é©ç”¨ã—ã¾ã—ãŸã€‚æ—¢å­˜è–¬å±€åˆ†æãƒ»æ–°è¦é–‹å±€äºˆæ¸¬ã‚¿ãƒ–ã§ç¢ºèªã§ãã¾ã™ã€‚")
                st.rerun()
        with col_info:
            st.markdown(
                "**é©ç”¨å¾Œã®åŠ¹æœ**:  \n"
                "æ—¢å­˜è–¬å±€åˆ†æã®ã€ŒğŸ“Š äºˆæ¸¬å€¤ vs åšåŠ´çœå®Ÿç¸¾å€¤ã€ã«"
                "**ğŸ¯ æ ¡æ­£æ¸ˆã¿äºˆæ¸¬**åˆ—ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚"
            )

    else:
        st.warning("âš  æœ‰åŠ¹ãªã‚µãƒ³ãƒ—ãƒ«ãŒ3ä»¶æœªæº€ã®ãŸã‚çµ±è¨ˆè¨ˆç®—ãŒã§ãã¾ã›ã‚“ã€‚åé›†ä»¶æ•°ã‚’å¢—ã‚„ã—ã¦ãã ã•ã„ã€‚")

    # æ ¡æ­£ã‚µãƒ³ãƒ—ãƒ«ä¸€è¦§ãƒ†ãƒ¼ãƒ–ãƒ«
    st.markdown("---")
    st.markdown("##### ğŸ“‹ æ ¡æ­£ã‚µãƒ³ãƒ—ãƒ«ä¸€è¦§")
    rows = []
    for p in points:
        rows.append({
            "è–¬å±€å": p.name[:25],
            "ä½æ‰€": p.address[:30],
            "å®Ÿç¸¾Rx": f"{p.actual_rx:,}",
            "M1äºˆæ¸¬": f"{p.m1_rx:,}" if p.m1_rx else "-",
            "M2äºˆæ¸¬": f"{p.m2_rx:,}" if p.m2_rx else "-",
            "M1èª¤å·®": f"{p.error_m1*100:+.0f}%" if p.error_m1 is not None else "-",
            "M2èª¤å·®": f"{p.error_m2*100:+.0f}%" if p.error_m2 is not None else "-",
            "å¯†åº¦å¸¯": p.density_band,
            "åŒ»ç™‚æ©Ÿé–¢æ•°": p.n_medical,
            "ç«¶åˆè–¬å±€æ•°": p.n_pharmacies,
        })
    if rows:
        import pandas as pd
        st.dataframe(pd.DataFrame(rows), use_container_width=True, hide_index=True)

        # CSVå‡ºåŠ›
        csv_data = CalibrationEngine.points_to_csv(points)
        st.download_button(
            "ğŸ“¥ æ ¡æ­£ãƒ‡ãƒ¼ã‚¿ã‚’CSVã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
            data=csv_data,
            file_name=f"calibration_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
            mime="text/csv",
        )

    # å€‹åˆ¥ãƒ­ã‚°ç¢ºèª
    with st.expander("ğŸ” å€‹åˆ¥äºˆæ¸¬ãƒ­ã‚°ï¼ˆã‚¨ãƒ©ãƒ¼èª¿æŸ»ç”¨ï¼‰"):
        for p in points:
            if p.error_log:
                st.markdown(f"**{p.name}** ({p.address[:30]})")
                st.code("\n".join(p.error_log))
                st.markdown("---")


# ---------------------------------------------------------------------------

def main() -> None:
    st.set_page_config(
        page_title="è–¬å±€ å‡¦æ–¹ç®‹æšæ•° å¤šé¢çš„äºˆæ¸¬ v4.2",
        page_icon="ğŸ’Š",
        layout="wide",
        initial_sidebar_state="collapsed",
    )
    st.title("ğŸ’Š è–¬å±€ å¹´é–“å‡¦æ–¹ç®‹æšæ•° å¤šé¢çš„äºˆæ¸¬ãƒ„ãƒ¼ãƒ« v4.2")

    cal_stats: Optional[CalibrationStats] = st.session_state.get("calibration_stats")
    if cal_stats:
        st.success(
            f"âœ… **æ ¡æ­£æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«é©ç”¨ä¸­** "
            f"ï¼ˆ{cal_stats.calibrated_at} æ ¡æ­£ / n={cal_stats.n} / "
            f"æœ€é©MAPE={cal_stats.mape_optimal:.1f}% / "
            f"M1é‡ã¿={cal_stats.optimal_m1_weight:.0%}ï¼‰"
        )
    else:
        st.info(
            "ğŸ“Œ **v4.1**: ğŸ”¬ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ã‚¿ãƒ–ã§MHLWå®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’åé›†ã—ã€"
            "äºˆæ¸¬ç²¾åº¦ã‚’è‡ªå‹•æœ€é©åŒ–ã§ãã¾ã™ã€‚"
        )

    for k, v in [
        ("candidates", []), ("analysis", None), ("new_result", None),
        ("manual_facility_params", []),
        ("clinic_candidates_v4", []),
        ("mhlw_supplement", []),
        ("mhlw_supplement_log", []),
        ("calibration_points", []),       # v4.1: æ ¡æ­£ã‚µãƒ³ãƒ—ãƒ«ãƒªã‚¹ãƒˆ
        ("calibration_stats", None),      # v4.1: æ ¡æ­£çµ±è¨ˆ
    ]:
        if k not in st.session_state:
            st.session_state[k] = v

    tab_existing, tab_new, tab_cal = st.tabs([
        "ğŸª æ—¢å­˜è–¬å±€ã‚’åˆ†æ",
        "ğŸ— æ–°è¦é–‹å±€ã‚’äºˆæ¸¬",
        "ğŸ”¬ ãƒ¢ãƒ‡ãƒ«æ ¡æ­£",
    ])

    # ================================================================
    # TAB A: æ—¢å­˜è–¬å±€åˆ†æãƒ¢ãƒ¼ãƒ‰
    # ================================================================
    with tab_existing:
        _render_existing_mode()

    # ================================================================
    # TAB B: æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰
    # ================================================================
    with tab_new:
        _render_new_pharmacy_mode()

    # ================================================================
    # TAB C: ãƒ¢ãƒ‡ãƒ«æ ¡æ­£ï¼ˆv4.1 æ–°æ©Ÿèƒ½ï¼‰
    # ================================================================
    with tab_cal:
        _render_calibration_tab()


def _render_existing_mode() -> None:
    st.markdown("### STEP 1 â€” è–¬å±€åã§æ¤œç´¢ï¼ˆåšç”ŸåŠ´åƒçœãƒãƒ¼ã‚¿ãƒ«ï¼‰")
    col_kw, col_pref = st.columns([3, 1])
    with col_kw:
        keyword = st.text_input(
            "è–¬å±€åï¼ˆä¸€éƒ¨ã§ã‚‚å¯ï¼‰",
            placeholder="ä¾‹: ã‚¢ã‚¤ã‚»ã‚¤è–¬å±€ æ­¦è”µå°æ‰ / æ—¥æœ¬èª¿å‰¤ æ–°å®¿",
            key="ex_keyword",
        )
    with col_pref:
        pref = st.selectbox("éƒ½é“åºœçœŒï¼ˆä»»æ„ï¼‰", ["ï¼ˆæŒ‡å®šãªã—ï¼‰"] + PREFECTURES, key="ex_pref")

    if st.button("ğŸ” å€™è£œã‚’æ¤œç´¢", type="primary", key="ex_search"):
        st.session_state["analysis"] = None
        pref_code = PREFECTURE_CODES.get(pref, "")
        with st.spinner("MHLWãƒãƒ¼ã‚¿ãƒ«ã‚’æ¤œç´¢ä¸­â€¦"):
            scraper = MHLWScraper()
            cands, total, status = scraper.search_pharmacy_candidates(keyword.strip(), pref_code)
        st.session_state["candidates"] = cands
        if cands:
            st.success(f"âœ… {status}ï¼ˆå…¨{total}ä»¶ï¼‰")
        else:
            st.warning("å€™è£œãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")

    candidates: List[PharmacyCandidate] = st.session_state.get("candidates", [])
    analysis: Optional[FullAnalysis] = st.session_state.get("analysis")

    if candidates and analysis is None:
        st.markdown("---")
        st.markdown("### STEP 2 â€” è–¬å±€ã‚’é¸æŠã—ã¦åˆ†æå®Ÿè¡Œ")
        options = [f"{c.name}ã€€{'ï¼ˆ' + c.address[:35] + 'ï¼‰' if c.address else ''}" for c in candidates]
        sel_label = st.selectbox("å€™è£œä¸€è¦§", options, key="ex_candidate")
        sel_idx = options.index(sel_label)
        sel = candidates[sel_idx]
        st.caption(f"ğŸ“ ä½æ‰€: {sel.address or 'ä¸æ˜'}")

        if sel.address:
            dens, dens_src = get_population_density(sel.address)
            r_init, r_reason = calc_commercial_radius(dens, False, "")
            est_pop = int(math.pi * (r_init / 1000) ** 2 * dens)
            with st.expander("ğŸ“ è‡ªå‹•è¨ˆç®—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼", expanded=True):
                p1, p2, p3 = st.columns(3)
                p1.metric("ğŸ˜ æ¨è¨ˆäººå£å¯†åº¦", f"{dens:,}äºº/kmÂ²", help=dens_src)
                p2.metric("ğŸ“ åˆæœŸå•†åœåŠå¾„", f"{r_init}m", help=r_reason)
                p3.metric("ğŸ‘¥ æ¨è¨ˆå•†åœäººå£", f"{est_pop:,}äºº")
                st.caption(f"ğŸ—‚ å‡ºå…¸: {dens_src} | å•†åœæ ¹æ‹ : {r_reason}")

        if st.button("ğŸš€ å¤šé¢çš„åˆ†æã‚’å®Ÿè¡Œ", type="primary", use_container_width=True, key="ex_run"):
            run_analysis(sel)

    if analysis:
        st.markdown("---")
        st.markdown(f"## çµæœ: `{analysis.pharmacy_name}`")
        st.caption(f"ä½æ‰€: {analysis.pharmacy_address}")
        render_auto_params_panel(
            analysis.pharmacy_lat, analysis.pharmacy_lon,
            analysis.geocode_display, analysis.geocoder_source,
            analysis.pharmacy_address,
            analysis.area_density, analysis.area_density_source,
            analysis.commercial_radius, analysis.commercial_radius_reason,
            analysis.is_gate_pharmacy, analysis.gate_pharmacy_reason,
        )
        st.markdown("---")
        render_comparison_banner(analysis)
        # v2.4: ä¹–é›¢è­¦å‘Š + æ‰‹å‹•æ–½è¨­è¿½åŠ  + å†è¨ˆç®—ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        render_gap_and_manual_input(analysis)
        st.markdown("---")
        tab_map, tab_preds, tab_mhlw, tab_log = st.tabs([
            "ğŸ—º ç«¶åˆãƒãƒƒãƒ—", "ğŸ“Š äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯", "ğŸ¥ åšåŠ´çœãƒ‡ãƒ¼ã‚¿", "ğŸ” æ¤œç´¢ãƒ­ã‚°"
        ])
        with tab_map:
            if analysis.pharmacy_lat and analysis.pharmacy_lon:
                st.markdown(
                    "**å‡¡ä¾‹**: ğŸ”´ åˆ†æå¯¾è±¡è–¬å±€ã€€ğŸ”µ ç—…é™¢ã€€ğŸ”· ã‚¯ãƒªãƒ‹ãƒƒã‚¯ï¼ˆOSMï¼‰"
                    "ã€€ğŸŸ£ MHLWè‡ªå‹•è£œå¡«ã€€ğŸŸ  æ‰‹å‹•è¿½åŠ æ–½è¨­ã€€ğŸŸ¢ ç«¶åˆè–¬å±€"
                    f"ã€€ï¼ˆå•†åœå††: åŠå¾„{analysis.commercial_radius}mï¼‰"
                )
                # v2.6: OSM + MHLWè£œå¡« + æ‰‹å‹•è¿½åŠ ã‚’ã™ã¹ã¦ãƒãƒƒãƒ—ã«å«ã‚ã‚‹
                _mhlw_facs   = st.session_state.get("mhlw_supplement", [])
                _manual_params = st.session_state.get("manual_facility_params", [])
                _manual_for_map = [
                    make_manual_facility(
                        analysis.pharmacy_lat, analysis.pharmacy_lon,
                        p["name"], p["specialty"], p["daily_outpatients"],
                        p["distance_m"], p["has_inhouse"],
                    )
                    for p in _manual_params
                ]
                _all_medical = analysis.nearby_medical + _mhlw_facs + _manual_for_map
                m = build_competitor_map(
                    analysis.pharmacy_name,
                    analysis.pharmacy_lat, analysis.pharmacy_lon,
                    _all_medical,
                    analysis.nearby_pharmacies,
                    analysis.commercial_radius, analysis.geocoder_source,
                )
                st_folium(m, width=None, height=520, use_container_width=True)
            else:
                st.warning("åº§æ¨™å–å¾—å¤±æ•—ã®ãŸã‚ãƒãƒƒãƒ—ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“")
            # v2.6: è£œå¡«å¾Œã®å…¨æ–½è¨­ã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¡¨ç¤º
            _mhlw_facs_t   = st.session_state.get("mhlw_supplement", [])
            _manual_params_t = st.session_state.get("manual_facility_params", [])
            _manual_for_table = [
                make_manual_facility(
                    analysis.pharmacy_lat or 0.0, analysis.pharmacy_lon or 0.0,
                    p["name"], p["specialty"], p["daily_outpatients"],
                    p["distance_m"], p["has_inhouse"],
                )
                for p in _manual_params_t
            ] if analysis.pharmacy_lat else []
            render_competitor_table(
                analysis.nearby_medical + _mhlw_facs_t + _manual_for_table,
                analysis.nearby_pharmacies,
            )
        with tab_preds:
            render_prediction_tabs(analysis.method1, analysis.method2)
        with tab_mhlw:
            if analysis.mhlw_annual_rx:
                st.success(f"âœ… åšåŠ´çœå®Ÿç¸¾å€¤: **{analysis.mhlw_annual_rx:,}æš/å¹´**")
            else:
                st.warning("åšåŠ´çœãƒãƒ¼ã‚¿ãƒ«ã«å‡¦æ–¹ç®‹æšæ•°ã®è¨˜è¼‰ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            if analysis.mhlw_source_url:
                st.markdown(f"ğŸ”— [MHLWãƒãƒ¼ã‚¿ãƒ«ã§ç¢ºèª]({analysis.mhlw_source_url})")
        with tab_log:
            st.code("\n".join(analysis.search_log))

    if not candidates and analysis is None:
        st.markdown("---")
        c1, c2, c3 = st.columns(3)
        c1.markdown("**â‘  åšåŠ´çœå®Ÿãƒ‡ãƒ¼ã‚¿å–å¾—**\n\nè–¬å±€æ©Ÿèƒ½æƒ…å ±æä¾›åˆ¶åº¦ã‹ã‚‰ã€Œç·å–æ‰±å‡¦æ–¹ç®‹æ•°ã€ã‚’ç›´æ¥å–å¾—")
        c2.markdown("**â‘¡ è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**\n\nOSMã§è¿‘éš£ã‚¯ãƒªãƒ‹ãƒƒã‚¯ãƒ»ç—…é™¢ã‚’æ¤œç´¢ã—è¨ºç™‚ç§‘åˆ¥å‡¦æ–¹ç®‹ç™ºè¡Œç‡ã‹ã‚‰äºˆæ¸¬")
        c3.markdown("**â‘¢ å•†åœäººå£å‹•æ…‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**\n\nä½æ‰€ã‹ã‚‰äººå£å¯†åº¦ãƒ»å•†åœåŠå¾„ã‚’è‡ªå‹•è¨ˆç®—ã—å¹´é½¢åˆ¥å—è¨ºç‡Ã—å¸‚å ´ã‚·ã‚§ã‚¢ã§äºˆæ¸¬")


def _render_new_pharmacy_mode() -> None:
    """æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰ UI"""
    st.markdown(
        "### ğŸ— æ–°è¦é–‹å±€äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰\n\n"
        "ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒãƒ¼ã‚±ãƒƒãƒˆå†…èª¿å‰¤è–¬å±€ãªã©ã®**æ–°è¦é–‹å±€**ã‚’æƒ³å®šã—ã€"
        "é–‹å±€äºˆå®šä½æ‰€ã‚’å…¥åŠ›ã™ã‚‹ã ã‘ã§é›†å®¢å¯èƒ½ãªå‡¦æ–¹ç®‹æšæ•°ã‚’äºˆæ¸¬ã—ã¾ã™ã€‚\n\n"
        "| ã‚·ãƒŠãƒªã‚ª | å†…å®¹ | ä½¿ç”¨æ‰‹æ³• |\n"
        "|---|---|---|\n"
        "| ğŸŒ **Bï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰** | é¢ã§ã®é›†å®¢ï¼ˆã‚¹ãƒ¼ãƒ‘ãƒ¼æ•·åœ°å†…ãªã©ï¼‰ | æ–¹æ³•â‘ æ—¢å­˜è¿‘éš£ï¼‹æ–¹æ³•â‘¡ |\n"
        "| ğŸ¥ **Cï¼ˆæ¨å¥¨ï¼‰** | é¢ï¼‹é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ | æ–¹æ³•â‘ é–€å‰è¾¼ã¿ï¼‹æ–¹æ³•â‘¡ï¼‹ä»˜åŠ ä¾¡å€¤ç®—å‡º |\n"
        "| ğŸšª **A** | é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã®ã¿ | æ–¹æ³•â‘ ã®ã¿ |\n"
        "| ğŸ”„ **å…¨æ¯”è¼ƒ** | å…¨ã‚·ãƒŠãƒªã‚ªã‚’æ¨ªä¸¦ã³æ¯”è¼ƒ | ä¸Šè¨˜ã™ã¹ã¦ |"
    )
    st.markdown("---")
    st.markdown("#### STEP 1 â€” é–‹å±€äºˆå®šåœ°ã®ä½æ‰€ã‚’å…¥åŠ›")
    col_name, col_addr = st.columns([1, 2])
    with col_name:
        pharmacy_name = st.text_input(
            "è–¬å±€åï¼ˆä»»æ„ï¼‰",
            value="é–‹å±€äºˆå®šè–¬å±€",
            placeholder="ä¾‹: â—‹â—‹èª¿å‰¤è–¬å±€",
            key="new_ph_name",
        )
    with col_addr:
        address = st.text_input(
            "é–‹å±€äºˆå®šåœ°ã®ä½æ‰€",
            placeholder="ä¾‹: æ±äº¬éƒ½æ¿æ©‹åŒºæˆå¢—1ä¸ç›®12-3 / ç¥å¥ˆå·çœŒå·å´å¸‚ä¸­åŸåŒºæ–°ä¸¸å­æ±3ä¸ç›®",
            key="new_address",
        )
    if address:
        dens, dens_src = get_population_density(address)
        r_init, r_reason = calc_commercial_radius(dens, False, "")
        est_pop = int(math.pi * (r_init / 1000) ** 2 * dens)
        st.info(
            f"ğŸ“ **ä½æ‰€ã‹ã‚‰è‡ªå‹•è¨ˆç®—**: äººå£å¯†åº¦ {dens:,}äºº/kmÂ²ï¼ˆ{dens_src}ï¼‰"
            f" â†’ å•†åœåŠå¾„ {r_init}m â†’ æ¨è¨ˆå•†åœäººå£ {est_pop:,}äºº"
        )

    st.markdown("---")
    st.markdown("#### STEP 2 â€” é–‹å±€ã‚·ãƒŠãƒªã‚ªã‚’é¸æŠ")
    scenario = st.radio(
        "äºˆæ¸¬ã‚·ãƒŠãƒªã‚ª",
        options=["area_dual", "combined", "gate_only", "all"],
        format_func=lambda x: {
            "area_dual": "ğŸŒ ã‚·ãƒŠãƒªã‚ªB: é¢ã§ã®é›†å®¢ï¼ˆæ–¹æ³•â‘ æ—¢å­˜è¿‘éš£ï¼‹æ–¹æ³•â‘¡ï¼‰  â† ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ",
            "combined":  "ğŸ¥ ã‚·ãƒŠãƒªã‚ªC: é¢ï¼‹é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ï¼ˆæ–¹æ³•â‘ é–€å‰è¾¼ã¿ï¼‹æ–¹æ³•â‘¡ï¼‰  â† NEW",
            "gate_only": "ğŸšª ã‚·ãƒŠãƒªã‚ªA: é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã®ã¿ï¼ˆæ–¹æ³•â‘ ã®ã¿ï¼‰",
            "all":       "ğŸ”„ å…¨ã‚·ãƒŠãƒªã‚ªæ¯”è¼ƒï¼ˆBãƒ»Cãƒ»Aã‚’æ¨ªä¸¦ã³è¡¨ç¤ºï¼‰",
        }[x],
        key="new_scenario",
    )

    gate_specialty, gate_daily, gate_inhouse = "ä¸€èˆ¬å†…ç§‘", 50, False
    if scenario in ("combined", "gate_only", "all"):
        st.markdown("**ğŸšª é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯è¨­å®š**")
        col_sp, col_daily, col_inhouse = st.columns(3)
        with col_sp:
            gate_specialty = st.selectbox(
                "èª˜è‡´ã™ã‚‹è¨ºç™‚ç§‘",
                list(SPECIALTY_RX_RATES.keys()),
                index=0,
                key="new_specialty",
                help="è¨ºç™‚ç§‘ã«ã‚ˆã£ã¦å‡¦æ–¹ç®‹ç™ºè¡Œç‡ãŒç•°ãªã‚Šã¾ã™",
            )
            rx_rate = SPECIALTY_RX_RATES[gate_specialty][0]
            st.caption(f"å‡¦æ–¹ç®‹ç™ºè¡Œç‡: {rx_rate:.0%}")
        with col_daily:
            gate_daily = st.slider(
                "æƒ³å®š1æ—¥å¤–æ¥æ‚£è€…æ•°",
                min_value=10, max_value=300, value=50, step=5,
                key="new_daily_op",
                help="ä¸€èˆ¬çš„ãªå€‹äººã‚¯ãƒªãƒ‹ãƒƒã‚¯: 30ã€œ60äºº/æ—¥, è¦æ¨¡ã®å¤§ãã„ã‚¯ãƒªãƒ‹ãƒƒã‚¯: 80ã€œ150äºº/æ—¥",
            )
            daily_rx_est = int(gate_daily * rx_rate * NATIONAL_STATS["outpatient_rx_rate"])
            st.caption(f"æ¨è¨ˆå‡¦æ–¹ç®‹/æ—¥: {daily_rx_est}æš")
        with col_inhouse:
            gate_inhouse = st.checkbox(
                "é™¢å†…è–¬å±€ã‚ã‚Šï¼ˆé™¢å¤–å‡¦æ–¹ç‡ä½ä¸‹ï¼‰",
                value=False,
                key="new_inhouse",
                help="é™¢å†…è–¬å±€ãŒã‚ã‚‹ã¨é™¢å¤–å‡¦æ–¹ç‡ãŒ60%ç¨‹åº¦ã«ä½ä¸‹ã—ã¾ã™",
            )

    st.markdown("---")
    st.markdown("#### STEP 3 â€” åˆ†æã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆè‡ªå‹•å®Ÿè¡Œï¼‰")
    st.info(
        "ğŸŸ£ **MHLWè‡ªå‹•è£œå¡«**: åˆ†æå®Ÿè¡Œæ™‚ã«åšåŠ´çœDBã‹ã‚‰æœªåéŒ²åŒ»ç™‚æ©Ÿé–¢ã‚’è‡ªå‹•è£œå¡«ã—ã¾ã™ï¼ˆç´„30ç§’ã€œ2åˆ†ï¼‰ã€‚"
        "OSMã§è¦‹ã¤ã‹ã‚‰ãªã„ã‚¯ãƒªãƒ‹ãƒƒã‚¯ãŒè‡ªå‹•çš„ã«æ–¹æ³•â‘ ã®æ¨è¨ˆã«åæ˜ ã•ã‚Œã¾ã™ã€‚\n\n"
        "ğŸ“‹ **ç«¶åˆè–¬å±€å‡¦æ–¹ç®‹å–å¾— (v3.2)**: è¿‘éš£ç«¶åˆè–¬å±€ï¼ˆä¸Šä½10ä»¶ï¼‰ã®å®Ÿéš›ã®å‡¦æ–¹ç®‹æšæ•°ã‚’MHLWã‹ã‚‰"
        "è‡ªå‹•å–å¾—ã—ã¦ãƒãƒƒãƒ—ãƒ»ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¡¨ç¤ºã—ã¾ã™ï¼ˆå–å¾—ã«1ã€œ3åˆ†ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼‰ã€‚"
    )

    can_run = bool(address.strip())
    if not can_run:
        st.info("ä½æ‰€ã‚’å…¥åŠ›ã™ã‚‹ã¨åˆ†æã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚")

    if st.button(
        "ğŸš€ æ–°è¦é–‹å±€äºˆæ¸¬ã‚’å®Ÿè¡Œ", type="primary",
        use_container_width=True, key="new_run",
        disabled=not can_run,
    ):
        config = NewPharmacyConfig(
            address=address.strip(),
            pharmacy_name=pharmacy_name or "é–‹å±€äºˆå®šè–¬å±€",
            scenario=scenario,            # "area_dual"|"combined"|"gate_only"|"all"
            gate_specialty=gate_specialty,
            gate_daily_outpatients=gate_daily,
            gate_has_inhouse=gate_inhouse,
            fetch_nearby_rx=True,         # v3.2: å¸¸æ™‚è‡ªå‹•å®Ÿè¡Œ
            fetch_mhlw_supplement=True,   # v3.1: å¸¸æ™‚è‡ªå‹•å®Ÿè¡Œ
        )
        run_new_pharmacy_analysis(config)

    # çµæœè¡¨ç¤º
    new_result: Optional[NewPharmacyResult] = st.session_state.get("new_result")
    if new_result:
        st.markdown("---")
        st.markdown(f"## çµæœ: `{new_result.config.pharmacy_name}`")
        st.caption(f"é–‹å±€äºˆå®šä½æ‰€: {new_result.config.address}")

        render_auto_params_panel(
            new_result.lat, new_result.lon,
            new_result.geocode_display, new_result.geocoder_source,
            new_result.config.address,
            new_result.area_density, new_result.area_density_source,
            new_result.commercial_radius, new_result.commercial_radius_reason,
            new_result.is_gate, new_result.gate_reason,
        )
        st.markdown("---")
        render_new_pharmacy_comparison(new_result)
        st.markdown("---")

        tab_map, tab_preds, tab_log = st.tabs(["ğŸ—º ç«¶åˆç’°å¢ƒãƒãƒƒãƒ—", "ğŸ“Š äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯è©³ç´°", "ğŸ” åˆ†æãƒ­ã‚°"])
        with tab_map:
            if new_result.lat and new_result.lon:
                has_rx_data = any(p.mhlw_annual_outpatients for p in new_result.nearby_pharmacies)
                sc_label = new_result.config.scenario
                show_virtual = sc_label in ("combined", "gate_only", "all")
                st.markdown(
                    "**å‡¡ä¾‹**: ğŸ”´â­ é–‹å±€äºˆå®šåœ°ã€€"
                    + ("ğŸŸ  èª˜è‡´äºˆå®šã‚¯ãƒªãƒ‹ãƒƒã‚¯ï¼ˆé–€å‰ã‚·ãƒŠãƒªã‚ªï¼‰ã€€" if show_virtual else "")
                    + "ğŸ”µ ç—…é™¢ã€€ğŸ”· ã‚¯ãƒªãƒ‹ãƒƒã‚¯ã€€ğŸŸ¢ ç«¶åˆè–¬å±€"
                )
                if has_rx_data:
                    st.success("âœ… ç«¶åˆè–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ï¼ˆMHLWï¼‰ã‚’ãƒãƒƒãƒ—ã«åæ˜ ã—ã¦ã„ã¾ã™")
                else:
                    st.info("ğŸ’¡ è¿‘éš£è–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ã¯æœªå–å¾—ã§ã™ï¼ˆSTEP 3ã§ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹ã¨å–å¾—ã§ãã¾ã™ï¼‰")
                m = build_new_pharmacy_map(
                    new_result.config,
                    new_result.lat, new_result.lon,
                    new_result.nearby_medical, new_result.nearby_pharmacies,
                    new_result.commercial_radius, new_result.geocoder_source,
                )
                st_folium(m, width=None, height=520, use_container_width=True)
            else:
                st.warning("åº§æ¨™å–å¾—å¤±æ•—ã®ãŸã‚ãƒãƒƒãƒ—ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“")
            render_competitor_table(new_result.nearby_medical, new_result.nearby_pharmacies, show_rx=True)
        with tab_preds:
            _render_new_pharmacy_prediction_tabs(new_result)
        with tab_log:
            st.code("\n".join(new_result.search_log))


# ---------------------------------------------------------------------------
# 11. åˆ†æå®Ÿè¡Œé–¢æ•°
# ---------------------------------------------------------------------------

def run_analysis(candidate: PharmacyCandidate, try_mhlw_medical: bool = False) -> None:
    """æ—¢å­˜è–¬å±€ ãƒ•ãƒ«åˆ†æï¼ˆv3.1: MHLWè£œå¡«ã‚’è‡ªå‹•å®Ÿè¡Œï¼‰"""
    log: List[str] = []
    progress = st.progress(0, text="åˆ†æé–‹å§‹â€¦")
    # ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’åˆæœŸåŒ–ï¼ˆå‰å›åˆ†ã‚’ã‚¯ãƒªã‚¢ï¼‰
    st.session_state["mhlw_supplement"] = []
    st.session_state["mhlw_supplement_log"] = []

    # A: MHLW
    progress.progress(10, text="[1/6] MHLW: è–¬å±€è©³ç´°ã‚’å–å¾—ä¸­â€¦")
    scraper = MHLWScraper()
    scraper.initialize_session()
    detail, dmsg = scraper.get_pharmacy_detail(candidate)
    log.append(f"[MHLWè©³ç´°] {dmsg}")
    mhlw_rx = None
    pharmacy_address = candidate.address
    mhlw_url = candidate.href
    if detail:
        mhlw_rx = detail.get("prescriptions_annual")
        if detail.get("address"):
            pharmacy_address = detail["address"]
        mhlw_url = detail.get("source_url", candidate.href)
        log.append(f"  å‡¦æ–¹ç®‹æ•°: {mhlw_rx:,}æš/å¹´" if mhlw_rx else "  å‡¦æ–¹ç®‹æ•°: è¨˜è¼‰ãªã—")

    # B: å¯†åº¦
    progress.progress(20, text="[2/6] ä½æ‰€ã‹ã‚‰äººå£å¯†åº¦ã‚’è¨ˆç®—ä¸­â€¦")
    area_density, density_source = get_population_density(pharmacy_address)
    initial_r, _ = calc_commercial_radius(area_density, False, "")
    search_r = max(int(initial_r * 1.5), 600)
    log.append(f"[å¯†åº¦] {area_density:,}äºº/kmÂ²ï¼ˆ{density_source}ï¼‰")

    # C: ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆGSIå„ªå…ˆï¼‰
    progress.progress(30, text="[3/6] åº§æ¨™ã‚’å–å¾—ä¸­ï¼ˆå›½åœŸåœ°ç†é™¢ï¼‰â€¦")
    gc = GeocoderService()
    lat, lon, geo_msg, geo_src = gc.geocode(pharmacy_address)
    log.append(f"[Geocoding({geo_src})] {geo_msg}")

    # D: Overpassï¼ˆOSMï¼‰
    nearby_medical, nearby_pharmacies = [], []
    if lat and lon:
        progress.progress(40, text=f"[4/7] è¿‘éš£æ–½è¨­ã‚’æ¤œç´¢ä¸­ï¼ˆåŠå¾„{search_r}mï¼‰â€¦")
        time.sleep(0.5)
        ov = OverpassSearcher()
        nearby_medical, nearby_pharmacies, ov_msg = ov.search_nearby(lat, lon, search_r)
        log.append(f"[OSM] åŠå¾„{search_r}m â†’ {ov_msg}")

        # D.4: ç«¶åˆè–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ã‚’è‡ªå‹•å–å¾—ï¼ˆv3.2: å¸¸æ™‚å®Ÿè¡Œã€ä¸Šä½10ä»¶ï¼‰
        if nearby_pharmacies:
            progress.progress(47, text=f"[4.3/7] ç«¶åˆè–¬å±€ï¼ˆ{len(nearby_pharmacies[:10])}ä»¶ï¼‰ã®å‡¦æ–¹ç®‹æšæ•°ã‚’MHLWã‹ã‚‰å–å¾—ä¸­â€¦")
            rx_scraper = MHLWScraper()
            rx_scraper.initialize_session()
            rx_data = rx_scraper.get_rx_for_nearby_pharmacies(
                [p.name for p in nearby_pharmacies], limit=10
            )
            fetched_rx = 0
            for ph in nearby_pharmacies:
                if ph.name in rx_data and rx_data[ph.name]:
                    ph.mhlw_annual_outpatients = rx_data[ph.name]
                    log.append(f"  [ç«¶åˆè–¬å±€MHLW] {ph.name}: {rx_data[ph.name]:,}æš/å¹´")
                    fetched_rx += 1
            log.append(f"[ç«¶åˆè–¬å±€MHLW] {fetched_rx}/{len(nearby_pharmacies[:10])}ä»¶ã§å‡¦æ–¹ç®‹æšæ•°å–å¾—")

        # D.5: MHLWè‡ªå‹•è£œå¡«ï¼ˆv3.1: å¸¸ã«å®Ÿè¡Œï¼‰
        progress.progress(52, text="[4.5/7] MHLWã‹ã‚‰æœªåéŒ²åŒ»ç™‚æ©Ÿé–¢ã‚’è‡ªå‹•è£œå¡«ä¸­â€¦")
        pref_code_auto = ""
        for pref_name, pc in PREFECTURE_CODES.items():
            if pref_name in pharmacy_address:
                pref_code_auto = pc
                break
        mhlw_new_facs, mhlw_sup_log = fetch_mhlw_medical_supplement(
            pharmacy_lat=lat,
            pharmacy_lon=lon,
            pharmacy_address=pharmacy_address,
            pref_code=pref_code_auto,
            existing_osm=nearby_medical,
            search_radius_m=search_r,
        )
        log.extend(mhlw_sup_log)
        if mhlw_new_facs:
            st.session_state["mhlw_supplement"] = mhlw_new_facs
            st.session_state["mhlw_supplement_log"] = mhlw_sup_log
            log.append(f"[MHLWè£œå¡«] {len(mhlw_new_facs)}ä»¶ã‚’è‡ªå‹•è£œå¡«ï¼ˆOSMæœªåéŒ²ï¼‰")
        else:
            log.append("[MHLWè£œå¡«] æ–°è¦æ–½è¨­ãªã—ï¼ˆOSMã¨é‡è¤‡ or è©²å½“ãªã—ï¼‰")

        # D.6: MHLWå¤–æ¥æ‚£è€…æ•°ãƒ‡ãƒ¼ã‚¿ç…§ä¼šï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³: try_mhlw_medical=True æ™‚ï¼‰
        if try_mhlw_medical and nearby_medical:
            progress.progress(60, text="[4.6/7] åŒ»ç™‚æ–½è¨­ã®MHLWãƒ‡ãƒ¼ã‚¿ç…§ä¼šä¸­â€¦")
            for fac in nearby_medical[:5]:
                aop = scraper.get_medical_outpatient_data(fac.name)
                if aop:
                    fac.mhlw_annual_outpatients = aop
                    fac.daily_outpatients = aop // NATIONAL_STATS["working_days"]
                time.sleep(0.5)

    # E: é–€å‰åˆ¤å®šãƒ»å•†åœåŠå¾„ç¢ºå®š
    progress.progress(65, text="[5/6] é–€å‰åˆ¤å®šãƒ»å•†åœåŠå¾„ç¢ºå®šâ€¦")
    is_gate, gate_reason = detect_gate_pharmacy(candidate.name, nearby_medical)
    commercial_r, r_reason = calc_commercial_radius(area_density, is_gate, gate_reason)
    log.append(f"[é–€å‰] {is_gate} ({gate_reason}) â†’ åŠå¾„{commercial_r}m")

    # F: äºˆæ¸¬ï¼ˆv3.1: OSM + MHLWè£œå¡« + æ‰‹å‹•è¿½åŠ ã‚’å…¨ã¦å«ã‚ã¦åˆå›è¨ˆç®—ï¼‰
    progress.progress(75, text="[6/7] æ–¹æ³•â‘ â‘¡ã‚’è¨ˆç®—ä¸­â€¦")

    # MHLWè£œå¡«æ–½è¨­ï¼ˆD.5ã§å–å¾—æ¸ˆã¿ï¼‰
    mhlw_facs_for_pred: List[NearbyFacility] = st.session_state.get("mhlw_supplement", [])

    # æ‰‹å‹•è¿½åŠ æ¸ˆã¿ã®æ–½è¨­
    pre_added_params: List[Dict] = st.session_state.get("manual_facility_params", [])
    manual_facs: List[NearbyFacility] = [
        make_manual_facility(
            lat or 0.0, lon or 0.0,
            p["name"], p["specialty"], p["daily_outpatients"],
            p["distance_m"], p["has_inhouse"],
        )
        for p in pre_added_params
    ] if (lat and lon) else []
    if manual_facs:
        log.append(f"[æ‰‹å‹•è¿½åŠ ] {len(manual_facs)}ä»¶ã‚’æ–¹æ³•â‘ ã«è¿½åŠ ")

    # OSM + MHLWè£œå¡« + æ‰‹å‹•è¿½åŠ  ã‚’çµ±åˆ
    merged_medical = nearby_medical + mhlw_facs_for_pred + manual_facs
    if mhlw_facs_for_pred:
        log.append(f"[çµ±åˆ] OSM {len(nearby_medical)}ä»¶ + MHLWè£œå¡« {len(mhlw_facs_for_pred)}ä»¶"
                   + (f" + æ‰‹å‹• {len(manual_facs)}ä»¶" if manual_facs else "")
                   + f" = åˆè¨ˆ {len(merged_medical)}ä»¶")

    # åŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¤–æ¥æ‚£è€…æ•°ã‚’æŒã¤æ–½è¨­ãŒå¤šã„å ´åˆã€æ‚£è€…åˆ†æ•£ã‚’åæ˜ 
    merged_medical = apply_clinic_congestion_factor(merged_medical, log)

    extra_label = []
    if mhlw_facs_for_pred: extra_label.append(f"MHLWè£œå¡«{len(mhlw_facs_for_pred)}ä»¶å«ã‚€")
    if manual_facs:        extra_label.append(f"æ‰‹å‹•è¿½åŠ {len(manual_facs)}ä»¶å«ã‚€")
    m1_label = "æ–¹æ³•â‘ : è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ" + (f"ï¼ˆ{', '.join(extra_label)}ï¼‰" if extra_label else "")
    m1 = Method1Predictor().predict(
        lat or 0.0, lon or 0.0, merged_medical, nearby_pharmacies,
        mode_label=m1_label,
    ) if lat else None
    m2 = Method2Predictor().predict(
        lat or 0.0, lon or 0.0, nearby_pharmacies, area_density, commercial_r,
        density_source=density_source, radius_reason=r_reason,
        nearby_medical=merged_medical,  # v3.2: é–€å‰çš„ç«¶åˆåˆ¤å®šç”¨
    )
    progress.progress(100, text="å®Œäº†ï¼")
    progress.empty()

    st.session_state["analysis"] = FullAnalysis(
        pharmacy_name=candidate.name,
        pharmacy_address=pharmacy_address,
        pharmacy_lat=lat or 0.0,
        pharmacy_lon=lon or 0.0,
        geocode_display=geo_msg,
        geocoder_source=geo_src,
        mhlw_annual_rx=mhlw_rx,
        mhlw_source_url=mhlw_url,
        method1=m1, method2=m2,
        nearby_medical=nearby_medical,  # OSM ã®ã¿ï¼ˆæ‰‹å‹•è¿½åŠ ã¯åˆ¥ç®¡ç†ï¼‰
        nearby_pharmacies=nearby_pharmacies,
        area_density=area_density,
        area_density_source=density_source,
        commercial_radius=commercial_r,
        commercial_radius_reason=r_reason,
        is_gate_pharmacy=is_gate,
        gate_pharmacy_reason=gate_reason,
        search_log=log,
    )
    st.rerun()


def run_new_pharmacy_analysis(config: NewPharmacyConfig) -> None:
    """æ–°è¦é–‹å±€äºˆæ¸¬ ãƒ•ãƒ«åˆ†æï¼ˆv2.5/v2.6: area_dual / combined / gate_only / allï¼‰"""
    log: List[str] = []
    progress = st.progress(0, text="æ–°è¦é–‹å±€äºˆæ¸¬ã‚’é–‹å§‹â€¦")

    sc = config.scenario  # "area_dual" | "combined" | "gate_only" | "all"
    need_gate  = sc in ("combined", "gate_only", "all")
    need_area  = sc in ("area_dual", "combined", "all")
    need_m2    = sc in ("area_dual", "combined", "all")

    # A: å¯†åº¦è¨ˆç®—
    progress.progress(10, text="[1/5] ä½æ‰€ã‹ã‚‰äººå£å¯†åº¦ã‚’è¨ˆç®—ä¸­â€¦")
    area_density, density_source = get_population_density(config.address)
    initial_r, _ = calc_commercial_radius(area_density, False, "")
    search_r = max(int(initial_r * 1.5), 600)
    log.append(f"[å¯†åº¦] {area_density:,}äºº/kmÂ²ï¼ˆ{density_source}ï¼‰")

    # B: ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆGSIå„ªå…ˆï¼‰
    progress.progress(20, text="[2/5] åº§æ¨™ã‚’å–å¾—ä¸­ï¼ˆå›½åœŸåœ°ç†é™¢ï¼‰â€¦")
    gc = GeocoderService()
    lat, lon, geo_msg, geo_src = gc.geocode(config.address)
    log.append(f"[Geocoding({geo_src})] {geo_msg}")

    # C: Overpass â€” è¿‘éš£æ–½è¨­æ¤œç´¢
    nearby_medical: List[NearbyFacility] = []
    nearby_pharmacies: List[NearbyFacility] = []
    if lat and lon:
        progress.progress(40, text=f"[3/5] è¿‘éš£æ–½è¨­ã‚’æ¤œç´¢ä¸­ï¼ˆåŠå¾„{search_r}mï¼‰â€¦")
        time.sleep(0.5)
        ov = OverpassSearcher()
        nearby_medical, nearby_pharmacies, ov_msg = ov.search_nearby(lat, lon, search_r)
        log.append(f"[OSM] åŠå¾„{search_r}m â†’ {ov_msg}")

        # ç«¶åˆè–¬å±€ã®å‡¦æ–¹ç®‹æšæ•°ã‚’è‡ªå‹•å–å¾—ï¼ˆv3.2: å¸¸æ™‚å®Ÿè¡Œã€ä¸Šä½10ä»¶ï¼‰
        if nearby_pharmacies:
            progress.progress(55, text=f"[3.5/5] ç«¶åˆè–¬å±€ï¼ˆ{len(nearby_pharmacies[:10])}ä»¶ï¼‰ã®å‡¦æ–¹ç®‹æšæ•°ã‚’MHLWã‹ã‚‰å–å¾—ä¸­â€¦")
            rx_scraper2 = MHLWScraper()
            rx_scraper2.initialize_session()
            rx_data = rx_scraper2.get_rx_for_nearby_pharmacies(
                [p.name for p in nearby_pharmacies], limit=10
            )
            fetched_rx2 = 0
            for ph in nearby_pharmacies:
                if ph.name in rx_data and rx_data[ph.name]:
                    ph.mhlw_annual_outpatients = rx_data[ph.name]
                    log.append(f"  [ç«¶åˆè–¬å±€MHLW] {ph.name}: {rx_data[ph.name]:,}æš/å¹´")
                    fetched_rx2 += 1
            log.append(f"[ç«¶åˆè–¬å±€MHLW] {fetched_rx2}/{len(nearby_pharmacies[:10])}ä»¶ã§å‡¦æ–¹ç®‹æšæ•°å–å¾—")

        # v3.1: MHLWåŒ»ç™‚æ©Ÿé–¢ã‚¨ãƒªã‚¢è‡ªå‹•è£œå¡«ï¼ˆå¸¸æ™‚å®Ÿè¡Œï¼‰
        if lat:
            progress.progress(58, text="[3.7/5] MHLWã‹ã‚‰æœªåéŒ²åŒ»ç™‚æ©Ÿé–¢ã‚’è‡ªå‹•è£œå¡«ä¸­â€¦")
            pref_code = ""
            for pref_name, pc in PREFECTURE_CODES.items():
                if pref_name in config.address:
                    pref_code = pc
                    break
            new_facs, sup_log = fetch_mhlw_medical_supplement(
                pharmacy_lat=lat,
                pharmacy_lon=lon,
                pharmacy_address=config.address,
                pref_code=pref_code,
                existing_osm=nearby_medical,
                search_radius_m=search_r,
            )
            log.extend(sup_log)
            if new_facs:
                nearby_medical = nearby_medical + new_facs
                log.append(f"[MHLWè£œå¡«] {len(new_facs)}ä»¶ã‚’è¿‘éš£åŒ»ç™‚æ©Ÿé–¢ã«è¿½åŠ ")

        # åŒ»ç™‚æ©Ÿé–¢å¯†é›†è£œæ­£: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¤–æ¥æ‚£è€…æ•°ã‚’æŒã¤æ–½è¨­ãŒå¤šã„å ´åˆã€æ‚£è€…åˆ†æ•£ã‚’åæ˜ 
        nearby_medical = apply_clinic_congestion_factor(nearby_medical, log)

    # D: å•†åœåŠå¾„ç¢ºå®š
    progress.progress(65, text="[4/5] é–€å‰åˆ¤å®šãƒ»å•†åœåŠå¾„ã‚’ç¢ºå®šä¸­â€¦")
    if need_gate and not need_area:
        # ç´”ç²‹ãªé–€å‰ã‚·ãƒŠãƒªã‚ªA: åŒ»ç™‚æ©Ÿé–¢ä¾å­˜å‹ã®ãŸã‚å•†åœåŠå¾„ã‚’å°ã•ãå›ºå®š
        is_gate, gate_reason = True, "é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ã‚·ãƒŠãƒªã‚ªã‚’é¸æŠ"
        commercial_r, r_reason = 300, "é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´ â†’ åŒ»ç™‚æ©Ÿé–¢ä¾å­˜å‹ã®ãŸã‚300må›ºå®š"
    else:
        # é¢ã‚·ãƒŠãƒªã‚ªï¼ˆB/C/allï¼‰: äººå£å¯†åº¦ãƒ™ãƒ¼ã‚¹ã§å•†åœåŠå¾„ã‚’è¨ˆç®—
        is_gate, gate_reason = detect_gate_pharmacy(config.pharmacy_name, nearby_medical)
        commercial_r, r_reason = calc_commercial_radius(area_density, is_gate, gate_reason)
    log.append(f"[å•†åœ] åŠå¾„{commercial_r}mï¼ˆ{r_reason}ï¼‰")

    # E: äºˆæ¸¬è¨ˆç®—
    progress.progress(80, text="[5/5] äºˆæ¸¬è¨ˆç®—ä¸­â€¦")
    method1_gate: Optional[PredictionResult] = None
    method1_area: Optional[PredictionResult] = None
    method2:      Optional[PredictionResult] = None

    if lat:
        # -----------------------------------------------------------
        # æ–¹æ³•â‘ ï¼ˆé¢ã®ã¿ï¼‰: æ—¢å­˜è¿‘éš£åŒ»ç™‚æ–½è¨­ã ã‘ã§ Method1 ã‚’è¨ˆç®—
        #   â†’ ã‚·ãƒŠãƒªã‚ªB(area_dual) / C(combined) / all
        # -----------------------------------------------------------
        if need_area:
            method1_area = Method1Predictor().predict(
                lat, lon, nearby_medical, nearby_pharmacies,
                mode_label="ã‚·ãƒŠãƒªã‚ªB: é¢ã§ã®é›†å®¢ï¼ˆæ—¢å­˜è¿‘éš£æ–½è¨­ï¼‰"
            )
            log.append(f"[æ–¹æ³•â‘ (é¢ã®ã¿)] æ¨è¨ˆ: {method1_area.annual_rx:,}æš/å¹´")

        # -----------------------------------------------------------
        # æ–¹æ³•â‘ ï¼ˆé–€å‰è¾¼ã¿ï¼‰: ä»®æƒ³èª˜è‡´ã‚¯ãƒªãƒ‹ãƒƒã‚¯ + æ—¢å­˜è¿‘éš£ã§ Method1 ã‚’è¨ˆç®—
        #   â†’ ã‚·ãƒŠãƒªã‚ªA(gate_only) / C(combined) / all
        # -----------------------------------------------------------
        if need_gate:
            virtual_clinic = NearbyFacility(
                name=f"[èª˜è‡´äºˆå®š] {config.gate_specialty}ã‚¯ãƒªãƒ‹ãƒƒã‚¯",
                facility_type="clinic",
                lat=(lat + 0.000225),   # ~25m åŒ—ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                lon=lon,
                distance_m=25,
                specialty=config.gate_specialty,
                daily_outpatients=config.gate_daily_outpatients,
                has_inhouse_pharmacy=config.gate_has_inhouse,
            )
            all_medical_with_gate = [virtual_clinic] + nearby_medical
            method1_gate = Method1Predictor().predict(
                lat, lon, all_medical_with_gate, nearby_pharmacies,
                mode_label="ã‚·ãƒŠãƒªã‚ªC/A: é–€å‰ã‚¯ãƒªãƒ‹ãƒƒã‚¯èª˜è‡´è¾¼ã¿"
            )
            log.append(f"[æ–¹æ³•â‘ (é–€å‰è¾¼ã¿)] æ¨è¨ˆ: {method1_gate.annual_rx:,}æš/å¹´")
            if method1_area:
                gate_add = method1_gate.annual_rx - method1_area.annual_rx
                log.append(f"  â†’ é–€å‰èª˜è‡´ã®ä»˜åŠ ä¾¡å€¤: +{gate_add:,}æš/å¹´")

    # -----------------------------------------------------------
    # æ–¹æ³•â‘¡ï¼ˆå•†åœäººå£å‹•æ…‹ï¼‰: ã‚·ãƒŠãƒªã‚ªB / C / all
    # -----------------------------------------------------------
    if need_m2:
        method2 = Method2Predictor().predict(
            lat or 0.0, lon or 0.0, nearby_pharmacies,
            area_density, commercial_r,
            density_source=density_source, radius_reason=r_reason,
            nearby_medical=nearby_medical,  # v3.2: é–€å‰çš„ç«¶åˆåˆ¤å®šç”¨
        )
        log.append(f"[æ–¹æ³•â‘¡(å•†åœäººå£)] æ¨è¨ˆ: {method2.annual_rx:,}æš/å¹´")

    progress.progress(100, text="å®Œäº†ï¼")
    progress.empty()

    st.session_state["new_result"] = NewPharmacyResult(
        config=config,
        lat=lat, lon=lon,
        geocode_display=geo_msg,
        geocoder_source=geo_src,
        area_density=area_density,
        area_density_source=density_source,
        commercial_radius=commercial_r,
        commercial_radius_reason=r_reason,
        is_gate=is_gate,
        gate_reason=gate_reason,
        nearby_medical=nearby_medical,
        nearby_pharmacies=nearby_pharmacies,
        method1_gate=method1_gate,
        method1_area=method1_area,
        method2=method2,
        search_log=log,
    )
    st.rerun()


if __name__ == "__main__":
    main()
